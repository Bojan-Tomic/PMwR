#+TITLE: Portfolio Management with R
#+AUTHOR: Enrico Schumann
#+BIND: org-latex-default-packages-alist nil
#+BIND: org-use-sub-superscripts {}
#+PROPERTY: tangle yes
# ------------------ LATEX ------------------
#+LATEX_CLASS: scrbook
#+LATEX_HEADER: \addtokomafont{disposition}{\rmfamily}
#+LATEX_HEADER: \addtokomafont{descriptionlabel}{\rmfamily}
#+LATEX_HEADER: \setlength{\parindent}{0em}
#+LATEX_HEADER: \setlength{\parskip}{2ex plus0.5ex minus0.5ex}
#+LATEX_HEADER: \newcommand{\pmwr}{\textsc{pm}w\textsc{r}}
#+LATEX_HEADER: \newcommand{\pl}{\textsc{pl}}
#+LATEX_HEADER: \newcommand{\R}{\textsf{R}}
#+LATEX_HEADER: \usepackage[backend=bibtex,citestyle=authoryear]{biblatex}
#+LATEX_HEADER: \addbibresource{Library.bib}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmainfont{EB Garamond}
#+LATEX_HEADER: \setmonofont[Scale=0.91]{inconsolata}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \lstset{language=R,basicstyle=\ttfamily,frame=single,
#+LATEX_HEADER:         numberstyle=\ttfamily\footnotesize\color{gray}}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{hyperref}
#+PROPERTY: header-args:R :session *R*
# ------------------ HTML ------------------
#+HTML_HEAD: <style>
#+HTML_HEAD:     html,body {
#+HTML_HEAD:       padding: 0;
#+HTML_HEAD:       margin: 0;
#+HTML_HEAD:       line-height: 140%;
#+HTML_HEAD:     }
#+HTML_HEAD:     #content {
#+HTML_HEAD:       font-family: "localEBG", serif;
#+HTML_HEAD:       border: 1px solid #eeeeee;
#+HTML_HEAD:       border-radius: 3px;
#+HTML_HEAD:       color: #222222;
#+HTML_HEAD:       padding-top: 2ex;
#+HTML_HEAD:       padding: 1em;
#+HTML_HEAD:       margin-left: auto;
#+HTML_HEAD:       margin-right: auto;    
#+HTML_HEAD:       width: 700px;
#+HTML_HEAD:     }
#+HTML_HEAD:     @media (max-device-width: 700px) {
#+HTML_HEAD:         html,body {
#+HTML_HEAD:             width: 98%;
#+HTML_HEAD:         }
#+HTML_HEAD:         .coauthors {
#+HTML_HEAD:             font-size: 90%;
#+HTML_HEAD:         }
#+HTML_HEAD:         nav {
#+HTML_HEAD:             display: none;
#+HTML_HEAD:         }
#+HTML_HEAD:     }
#+HTML_HEAD:     .example {
#+HTML_HEAD:         border: 1px solid rgb(200,200,200);
#+HTML_HEAD:         padding: 4px;
#+HTML_HEAD:      }
#+HTML_HEAD:     .src {
#+HTML_HEAD:         border: 1px solid rgb(120,120,120);
#+HTML_HEAD:         color: rgb(60,60,60);
#+HTML_HEAD:         padding: 4px;
#+HTML_HEAD:      }
#+HTML_HEAD:     .src:hover {
#+HTML_HEAD:         background-color: rgb(200,200,200);
#+HTML_HEAD:         padding: 4px;
#+HTML_HEAD:      }
#+HTML_HEAD:     dt {
#+HTML_HEAD:       font-weight: bold;
#+HTML_HEAD:     }
#+HTML_HEAD:     li {
#+HTML_HEAD:       margin-bottom: 0.5ex;
#+HTML_HEAD:     }
#+HTML_HEAD:     code {
#+HTML_HEAD:       font-size: 115%;
#+HTML_HEAD:     }
#+HTML_HEAD: </style>

#+BEGIN_SRC R :exports none :results none
  options(continue = " ", digits = 3, width = 60, useFancyQuotes = FALSE)
  require("PMwR")
  require("zoo")
#+END_SRC



* Using R in portfolio management -- Two examples
  :PROPERTIES:
  :CUSTOM_ID: ch:intro
  :END:

** Preparing monthly-returns tables


** Computing the running maximum of a time-series

Idea, algorithm, implementation.


* An Overview of the PMwR Package

** The goals of writing the package

- Store a portfolio of assets and compute the value -- or other
  quantities such as Greeks -- for different data. Data may be market
  data, but also theoretical data (prices).

- Reevaluate a portfolio for specific scenarios (i.e., new market or
  artificial data).

- Read in transactions from various sources. That is done via a
  journal class.

- Show portfolio on certain day/time: create a /position/, evaluate
  this position $\to$ position class

- testing portfolios of options --> show payoff, simulate *paths*
  of underlier and vol surface

- run simulations for VaR

- various ways to compute pnl: weighted average, first-in-first-out
  and last-in-last-out


** Classes and Data structures

The following classes are implicitly defined (ie, S3 classes):

- journal :: keeps transactions. Internally, a object of class
     =journal= is named list of atomic vectors.

- position :: the numerical positions of different
     accounts/instruments at specific points in time. Always stored in
     a numeric matrix with attributes timestamp and instrument; points
     in time are in rows, instruments in columns.

- period returns :: numeric vector (potentially a matrix) with
     attributes timestamp and period. The class is called =p_returns=

- instrument :: term sheet (description etc); it does know notyhing
     about market data -- not yet implemented

- cashflow :: internal -- not yet implemented

- NAVseries :: store a time-series of net asset values

- pricetable :: a matrix of NAVs (or prices); each column corresponds
     to one asset. Additional attributes instrument and
     timestamp. Often, pricetables will be created corresponding to
     positions.




** Notes for developers

*** Methods for =returns=

Methods are responsible for `stripping' the input down do =x=
and =t=, calling `=returns.default=' or some other
method, and then to re-assemble the original class's structure. When
=period= is not specified, methods should keep timestamp
information for themselves and not pass it on. (That is,
=returns.default= should only ever receive a =timestamp=
when =period= is specified.)

*** Vectorisation

Functions should do vectorisation when it is beneficial in terms of
speed or clarity of code. An example should clarify this:
=drawdown= is internally computed through =cumsum=, so
even for a matrix of time series, it would need a loop. Such looping
should be left to the user. However, vectorisation should be used when
it makes computations faster.

*** Named vectors

In many instances, vectors that store scalar information of
instruments (such as price or multiplier) should be named by
instrument.

*** Functional programming

Do not rely on global options/settings. Exception are interative
functions, which essentially means =print= methods.



* Keeping track of transactions: journals

Many computations that the PMwR package provides are based on lists of
transactions. Conceptually, such lists are nothing more than
dataframes, but PMwR provides an =S3= class =journal= for handling
such transaction data.

A =journal= is a list of atomic vectors with a class attribute;
it is created through the function =journal=.%
\index{journal!compared with data.frame} %
Methods should not rely on this list being sorted in any particular
way: components of a journal should always be retrieved by name, never
by position. (In this respect a journal differs from a dataframe, for
which we can meaningfully speak of the \emph{n}th column.)  I will
refer to these journal components, such as =amount= or
=timestamp=, as fields.\index{journal!fields}

The simplicity of the class is intended, since it is meant for
interactive analyses. Thus, the user may -- and is expected to --
dissect the information in a =journal= at will; such
dissections include removing the class attribute.

What is actually stored in a =journal= is up to the user, but a
number of fields are required for certain operations and should thus
always be present:

- =timestamp= :: anything that can be sorted and that fits into an
     atomic vector

- =amount= :: the notional amount that is traded;

- =price= :: price;

- =instrument= :: description of the financial instrument;

- =id= :: (possibly unique) id;

- =account= :: description of the account;

- =...= :: other fields. They must be named, for instance
=fees = c(1,2,1)=

All fields can be missing, except =amount=.  Missing values will be
handled as =NA= with the exception of =id= and =account=, which will
be =NULL=.

Transactions in a journal can be organised in a hierachy
#+BEGIN_EXAMPLE
<account> => <instrument>
#+END_EXAMPLE
even though currently few functions use this hierarchy.  A simple
scheme[fn:1]
is to use specific characters or a pattern such as =::= to
introduce hierarchies into accounts, such as
#+BEGIN_EXAMPLE
pension::equities
#+END_EXAMPLE

** Creating journals

The function =journal= creates journal objects. At is very minimum, a
journal must contain amounts of something.
#+BEGIN_SRC R -n :exports both :results output
  amount <- c(+1, +2, -2, +2)
  jnl <- journal(amount = amount)
  jnl
#+END_SRC

#+RESULTS:
:    amount
: 1       1
: 2       2
: 3      -2
: 4       2
: 
: 4 transactions

To see the current position, which is nothing more than the sum over
all amounts, we can use =position=.
#+BEGIN_SRC R -n :exports both :results output
  position(jnl)
#+END_SRC

#+RESULTS:
:      [,1]
: <NA>    3

Only providing amounts is, admittedly, is not very useful. You can
keep track of positions, true. But a journal actually implies
chronological information, that is, flows. (As opposed to a ledger,
which gives you positions, or stocks.)

When the amount are actually sorted in time (though nothing in the
data structure could make sure they are), then you can at least track
positions over time.

Suppose you wanted you keep track of how many bottles of milk and wine
you have stored in your basement. Whenever you add to your storage,
you have a positive amount; whenever you retrieve bottles.

## TODO: example


Suppose now

#+BEGIN_SRC R -n :exports both
J <- journal(timestamp  = as.Date("2012-01-01") + 0:3, 
              amount     = c(1, 2, -2, 5),
              instrument = c("EUR", "EUR", "CHF", "CHF"))
J
#+END_SRC

#+RESULTS:
| EUR | 2012-01-01 |  1 | nil |
| EUR | 2012-01-02 |  2 | nil |
| CHF | 2012-01-03 | -2 | nil |
| CHF | 2012-01-04 |  5 | nil |

For details about the function and methods for =journal=
objects, see =?journal=\,. A =print= method defines how
to display a journal.
#+BEGIN_SRC R -n :exports both
print(J, max.print = 2, exclude = "instrument")
#+END_SRC

#+RESULTS:
| EUR | 2012-01-01 |  1 | nil |
| EUR | 2012-01-02 |  2 | nil |
| CHF | 2012-01-03 | -2 | nil |
| CHF | 2012-01-04 |  5 | nil |

Journals can be combined with =c=.\index{journal!c@=c=}
#+BEGIN_SRC R -n :exports both
J2 <- J
J2$fees <- rep(1,4)
c(J, J2)
#+END_SRC

#+RESULTS:
| EUR | 2012-01-01 |  1 | nil | nil |
| EUR | 2012-01-02 |  2 | nil | nil |
| CHF | 2012-01-03 | -2 | nil | nil |
| CHF | 2012-01-04 |  5 | nil | nil |
| EUR | 2012-01-01 |  1 | nil |   1 |
| EUR | 2012-01-02 |  2 | nil |   1 |
| CHF | 2012-01-03 | -2 | nil |   1 |
| CHF | 2012-01-04 |  5 | nil |   1 |


** Subsetting journals

In interactive sessions, we can use =subset= to select particular
transactions. %
\index{journal!subset@=subset=}
#+BEGIN_SRC R -n :exports both
subset(J, amount > 1) 
#+END_SRC

#+RESULTS:
| EUR | 2012-01-02 | 2 | nil |
| CHF | 2012-01-04 | 5 | nil |

With subset, you need not quote the expression that selects trades and
you can directly access a journal's fields.  Because of the way
=subset= evaluates its arguments, it should not be used within
functions.

More generally, to extract or change a field, use its name, either
through the =\$= operator or double brackets =[[...]]=.
#+BEGIN_SRC R -n :exports both
J$amount
#+END_SRC 

#+RESULTS:
|  1 |
|  2 |
| -2 |
|  5 |

#+BEGIN_SRC R -n :exports both
J[["amount"]] <- c(1 ,2, -2, 8)
J
#+END_SRC 

#+RESULTS:
| EUR | 2012-01-01 |  1 | nil |
| EUR | 2012-01-02 |  2 | nil |
| CHF | 2012-01-03 | -2 | nil |
| CHF | 2012-01-04 |  8 | nil |

The =`[`= method works with integers or logicals, returning
the respective transactions.
#+BEGIN_SRC R -n :exports both
J[2:3]
J[J$amount < 0]
#+END_SRC 

#+RESULTS:
| CHF | 2012-01-03 | -2 | nil |

You can also pass a string, which is then interpreted as a regular
expression that is matched against fields =instrument= and (if
available) =account=.
#+BEGIN_SRC R -n :exports both
J["eur"]
#+END_SRC 

#+RESULTS:
| EUR | 2012-01-01 | 1 | nil |
| EUR | 2012-01-02 | 2 | nil |

By default, case is ignored, but you can set =ignore.case= to
=FALSE=.  You can also specify the fields to match the string
against.
#+BEGIN_SRC R -n :exports both
J <- journal(timestamp  = as.Date("2012-01-01") + 0:5, 
             amount     = rep(1, 6),
             instrument = c("Equity A", "Equity A", 
                            "Equity B", 
                            "Bond exp 2019", "Bond exp 2017", 
                            "Bond exp 2021"),
             comment = c("pension plan", "pension plan", 
                          "", "", "", ""))
J
J["equ", ignore.case = FALSE]
J["equ", ignore.case = TRUE]
J["[Pp]ension"]
J["[Pp]ension", match.against = "comment"]
#+END_SRC 

#+RESULTS:
| Equity A | 2012-01-01 | 1 | nil | pension plan |
| Equity A | 2012-01-02 | 1 | nil | pension plan |

\section{Examples: positions, profits and losses}

\subsection{Single-entry accounting}

For many purposes, single-entry accounting is sufficient.  The
=position= function gives the current balance of all
instruments.
#+BEGIN_SRC R -n :exports both
position(J)
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 2 | 1 |

To get the position at a specific date, use the =when= argument.
#+BEGIN_SRC R -n :exports both
position(J, when = as.Date("2012-01-03"))
#+END_SRC

#+RESULTS:
| 0 | 0 | 0 | 2 | 1 |

To get a time series of positions, you can use specific keywords for
=when=: `=all=' will print the position at all
timestamps in the journal.
#+BEGIN_SRC R -n :exports both
position(J, when = "all")
#+END_SRC

#+RESULTS:
| 0 | 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 2 | 0 |
| 0 | 0 | 0 | 2 | 1 |
| 0 | 1 | 0 | 2 | 1 |
| 1 | 1 | 0 | 2 | 1 |
| 1 | 1 | 1 | 2 | 1 |

We are not limited to the timestamps that exist in the journal.
#+BEGIN_SRC R -n :exports both
position(J, when = seq(from = as.Date("2011-12-30"), 
                          to = as.Date("2012-01-06"),
                          by = "1 day"))
#+END_SRC 

#+RESULTS:
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 2 | 0 |
| 0 | 0 | 0 | 2 | 1 |
| 0 | 1 | 0 | 2 | 1 |
| 1 | 1 | 0 | 2 | 1 |
| 1 | 1 | 1 | 2 | 1 |

It's actually tedious to enter journals that way, in particular if
we want to update it over time.  So, for practical use, we may write
transactions into files, like this:

\begin{verbatim}
|  timestamp | amount | comment          |
|------------+--------+------------------|
| 2012-01-01 |    100 | a comment        |
| 2012-01-02 |    200 | another comment  |
| 2012-01-03 |   -200 | bought something |
| 2012-02-04 |    500 | got a present    |
\end{verbatim}

(In case you use Org-mode, such tables should look familiar.) % 
\marginpar{\url{http://orgmode.org/}} %
#+BEGIN_SRC perl :eval never
system("perl -ne 'print $_ if /^\\s*\\| /;' < ex1.txt > ex1.jnl")
#+END_SRC 
We can then write functions to read in such journal files.
%% TODO: replace ex1 with inline code
%% TODO: reference to org package
#+BEGIN_SRC R -n :exports both :eval never
  readjnl <- function(file) {
      ans <- read.table(file,
                        header = TRUE, sep = "|", as.is = TRUE)
      ans <- as.list(ans[ ,apply(ans, 2, function(x) !all(is.na(x)))])
      journal(timestamp = ans$timestamp,
              amount    = ans$amount,
              comment   = ans$comment)
  }
  (J <- readjnl("ex1.jnl"))
  J <- structure(list(instrument = c(NA_character_, NA_character_,
                                     NA_character_, NA_character_), 
                      timestamp = structure(c(15340, 15341, 15342, 
                                              15374),
                                            class = "Date"),
                      amount = c(100, 200, -200, 500),
                      price = c(NA, NA, NA, NA),
                      comment = c(" a comment", " another comment  ", 
                                  " bought something ", " got a present")),
                 .Names = c("instrument", 
                            "timestamp", "amount", "price", "comment"),
                 class = "journal")    
#+END_SRC 
Some of these transactions may mean a gain or loss to us, such as a
dividend payment).  Others are neutral, for example a transfer between
bank accounts.  There are several ways to deal with this.



FN{That is very much Perl style.  I like Perl.}

One way to deal with that is to switch to double-entry
accounting (see the next section).  A second way is to add
descriptions like ="expense"= and then subset by these
descriptions.

And yet another approach is to use prices.  Whenever you evaluate the
balances of your cash account, say that the price per unit is one.
That is reasonable: if my account has a balance of `120.2', it
actually means `120.2 euros'.  The price of one euro is one euro.

An expense should be a negative amount; income should go with positive
amounts.  When you add such an entry, make its price 0; when you
compute that value of a position, make its price 1.  An example:

#+BEGIN_SRC R -n :exports both
J <- journal(timestamp = c("day 1", "day 2", "day 3"), 
               amount    = c(100,100,-200), 
               price     = c(  1,  0,   0),
               comment   = c("neutral", "income", "expense"),
               account   = "my account")
J
#+END_SRC

#+RESULTS:
| nil | my account | day 1 |  100 | 1 | neutral |
| nil | my account | day 2 |  100 | 0 | income  |
| nil | my account | day 3 | -200 | 0 | expense |

The current balance is 0.
#+BEGIN_SRC R -n :exports both
position(J)
#+END_SRC 

#+RESULTS:
: 0

In terms of income and expenses we have made a loss of~100, which is
exactly what the function =pl= reports.  (There will be more
examples for computing profit and loss in the next chapter.)
#+BEGIN_SRC R -n :exports both
pl(J, current.price = 1)
#+END_SRC 

#+RESULTS:

Let us do some more typical financial transactions.  We buy five
times 1~unit of some unspecified asset.
#+BEGIN_SRC R -n :exports both
J1 <- journal(timestamp = 1:5, 
               amount   = 1, 
               price    = c(2,2,2,3,4), 
               account  = "my account")
J1
#+END_SRC

#+RESULTS:
| nil | my account | 1 | 1 | 2 |
| nil | my account | 2 | 1 | 2 |
| nil | my account | 3 | 1 | 2 |
| nil | my account | 4 | 1 | 3 |
| nil | my account | 5 | 1 | 4 |

We close the trade by selling 5~units.
#+BEGIN_SRC R -n :exports both
J2 <- journal(timestamp =  6L, 
               amount   = -5, 
               price    =  3, 
               account  = "my account")
#+END_SRC

#+RESULTS:
| nil | my account | 6 | -5 | 3 |

We can combine these journals with =c=.
#+BEGIN_SRC R -n :exports both
c(J1, J2)
#+END_SRC 

#+RESULTS:
| nil | my account | 1 |  1 | 2 |
| nil | my account | 2 |  1 | 2 |
| nil | my account | 3 |  1 | 2 |
| nil | my account | 4 |  1 | 3 |
| nil | my account | 5 |  1 | 4 |
| nil | my account | 6 | -5 | 3 |

(Note that I have written =6L= for the timestamp in
=J2=.  If I had not, a warning would have been issued saying
that the timestamps in the journals have different classes.
=1:5= is integer whereas =6= is numeric.  In the case
here, the warning would have been harmless and could have been
ignored.)

Since the position is now zero, it is easy to compute the \pl.  We can
use the function =pl=, again.
#+BEGIN_SRC R -n :exports both
pl(c(J1, J2))
#+END_SRC

#+RESULTS:

There is little difference when we have several accounts. An example:
#+BEGIN_SRC R -n :exports both
trades <- read.table(textConnection(
    "account; ticker; timestamp; amount; price
    private ; A ; 1;   100; 60
    private ; A ; 2;   100; 70
    private ; A ; 3;  -100; 66
    longterm; A ; 1; 100; 60
    longterm; B ; 1; 100; 5"),
                     sep =";", header = TRUE,
                     strip.white = TRUE, 
                     stringsAsFactors = FALSE)

(J <- journal(timestamp = trades$timestamp, 
                amount    = trades$amount,
                price     = trades$price, 
                instrument = trades$ticker, account = 
                trades$account))
#+END_SRC

#+RESULTS:
| A | private  | 1 |  100 | 60 |
| A | private  | 2 |  100 | 70 |
| A | private  | 3 | -100 | 66 |
| A | longterm | 1 |  100 | 60 |
| B | longterm | 1 |  100 |  5 |

There are two accounts.
#+BEGIN_SRC R -n :exports both
table(J$account)
#+END_SRC 

#+RESULTS:
| longterm | 2 |
| private  | 3 |

Per default, =position= does not care about accounts.  
We have asset =A= in account =longterm= and in
=private=, but we get the sum over all accounts.
#+BEGIN_SRC R -n :exports both
position(J)
#+END_SRC

#+RESULTS:
| 200 | 100 |

There are at least two ways to deal with this.  One is to concatenate
=account= and =instrument=.
#+BEGIN_SRC R -n :exports both
J2 <- J
J2$instrument <- paste0(J$account, ":", J$instrument)
position(J2)
#+END_SRC 

#+RESULTS:
| 100 | 100 | 100 |

The other is to use =split= on the journal.
#+BEGIN_SRC R -n :exports both
lapply(split(J, J$account), position)
#+END_SRC 

#+RESULTS:

\subsection{Double-entry accounting}

\emph{to be added}



* Backtesting


This chapter explains how to test trading strategies with the =btest=
function.

** Decisions

At any instant of time (in actual life, `now'), a trader need to
answer the following questions:

- Do I want to compute a new target portfolio, yes or no? If yes,
  go ahead and compute the new target portfolio.

- Given the target portfolio and the actual portfolio, do I~want
  to rebalance (ie, close the gap between the actual portfolio and the
  target portfolio)? If yes, rebalance.

If such a decision is not just hypothetical, then the answer to the
second question may lead to a number of orders sent to a broker.  Note
that many traders do not think in terms of \emph{stock} (ie, balances)
as we did here; rather, they think in terms of \emph{flow} (ie,
orders).  Both approaches are equivalent, but the described one makes
it easier to handle missed trades and synchronise accounts.

During a backtest, we will simulate the decisions of the trader.  How
precisely we simulate depends on the trading strategy.  The
=btest= function is meant as a helper function to simulate
these decisions.  The logic for the decisions described above is coded
in the functions =do.signal=, =signal= and
=do.rebalance=.

Implementing =btest= required a number of decision, too:
(i)~what to model (ie, how to simulate the trader), and (ii)~how to
code it.  As an example for point~(i): how precisely do we want to
model the order process (eg, use limit orders?  Allow partial fills?)
Example for~(ii): the backbone of =btest= is a loop that runs
through the data.  Loops are slow in \R\ when compared with compiled
languages, so should we vectorise instead?  Vectorisation is indeed
often possible, namely if trading is not path-dependent.  If we have
already a list of trades, we can efficiently transform them into a
profit-and-loss in \R\ without relying on an explicit loop.  Yet, one
advantage of looping is that the trade logic is more similar to actual
trading; we may even be able to reuse some code in live trading.

Altogether, the aim is to stick to the functional paradigm as much as
possible.  Functions receive arguments and evaluate to results; but
they do not change their arguments, nor do they assign or change other
variables `outside' their environment, nor do the results depend on
some variable outside the function.  This creates a problem, namely
how to keep track of state.  If we know what variables need to be
persistent, we could pass them into the function and always return
them.  But we would like to be more flexible, so we can pass an
environment; examples are below.  To make that clear: functional
programming should not be seen as a yes-or-no decision, but it is a
matter of degree.  And more of the functional approach can help
already.

** Data structure

We have one or several price series of length =T=. Internally, these
prices are stored in numeric matrices.

For a single asset, it is a matrix of prices with four columns: open,
high, low and close. For =n= assets, a list of length four:
=prices[[1]\]= is then a matrix with =n= columns containing
the open prices for the assets; =prices[[]]= is a matrix with
the high prices, and so on. If only close prices are used, then for
a single asset, either a matrix of one column or a numeric vector;
for multiple assets a list of length one, containing the matrix of
close prices. (For example, with 100 close prices of 5 assets, the
prices should be arranged in a matrix =p= of size 100 times 5;
and =prices = list(p)=.)

For a single asset:
#+BEGIN_EXAMPLE
open  high   low  close
 +-+   +-+   +-+   +-+
 | |   | |   | |   | |
 | |   | |   | |   | |
 | |   | |   | |   | |
 | |   | |   | |   | |
 | |   | |   | |   | |
 +-+   +-+   +-+   +-+
#+END_EXAMPLE

With two assets:

#+BEGIN_EXAMPLE
 open    high    low    close
+-+-+   +-+-+   +-+-+   +-+-+  
| | |   | | |   | | |   | | |
| | |   | | |   | | |   | | |
| | |   | | |   | | |   | | |
| | |   | | |   | | |   | | |
| | |   | | |   | | |   | | |
+-+-+   +-+-+   +-+-+   +-+-+
#+END_EXAMPLE

The =btest= function runs from =b + 1= to =T=. The variable~=b= is the
burn-in\index{burn-in},% \marginpar{=b=\qquad burn-in} % and it needs
to be a positive integer; in rare cases it may be zero.  When we take
decisions that are based on past data, we will lose at least one data
point.

Here is an important default: at time~=t=, we can use information up
to time =t - 1=.  Suppose that =t= were~4.  We may use all information
up to time~3, and trade at the =open= in period~4.

#+BEGIN_EXAMPLE
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS    X                        <- trade here
5    HH:MM:SS
#+END_EXAMPLE

We could also trade at the =close=.

#+BEGIN_EXAMPLE
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS                       X     <-- trade here
5    HH:MM:SS
#+END_EXAMPLE


No, we cannot trade at the high or low. (Some people like the idea, as
a robustness check -- always buy at the high, sell at the low.
Robustness checks -- forcing a bit of bad luck into the simulation --
are a good idea, notably bad executions.  High/low ranges can inform
such checks, but using these ranges does not go far enough, and is
more of a good story than a meaningful test.)

** Functions

=btest= expects a number of functions. The default is to not
specify arguments to these functions, because they can all access the
following objects. These objects are themselves functions that can
access certain data; there are no replacement functions.

- Open :: access open prices
- High :: access high prices
- Low :: access low prices
- Close :: access close prices
- Wealth :: the total wealth (cash plus positions) at a given point in
     time
- Cash :: cash (in accounting currency)
- Time :: current time (an integer)
- Timestamp :: access =timestamp= when it is specified; if not,
     it defaults to =Time=
- Portfolio :: the current portfolio
- SuggestedPortfolio :: the currently-suggested portfolio
- Globals :: an environment

All the functions have the argument =lag=, which defaults
to =1=.  That can be a vector, too: the expression
#+BEGIN_SRC R :eval never :output none
Close(Time():1)
#+END_SRC
for instance will return all available close prices. Alternatively, we
can use the argument =n= to retrieve a number of past data
points. So the above example is equivalent to
#+BEGIN_SRC R :eval never :output none
Close(n = Time())
#+END_SRC
and
#+BEGIN_SRC R :eval never :output none
Close(n = 5)
#+END_SRC
 
returns the last five closing prices.

*** signal

The =signal= function uses information until \texttt{t -
  1} and returns the suggested portfolio (a vector) to be held at
=t=.

*** do.signal

=do.signal= uses information until =t - 1= and must
return =TRUE= or =FALSE=.  If the function is not
specified, it defaults to =function() TRUE=.

*** do.rebalance

=do.rebalance= uses information until =t - 1= and
returns =TRUE= or =FALSE=. If the function is not
specified, it defaults to =function() TRUE=.

*** print.info

The function is called at the end of an iteration. It should not
return anything but is called for its side effect: print
information to the screen, into a file or into some other
connection.

** Examples: Single assets

It is best to describe the =btest= function through a number of
simple examples.

*** A useless first example

I really like simple examples. Suppose we have a single
instrument, and we use only close prices. The trading rule is to
buy, and then to hold forever. All we need is the time series of
the prices and the signal function. As an instrument we use the EURO
STOXX 50 future with expiry September 2015.
#+BEGIN_SRC R -n :exports both
timestamp <- structure(c(16679L, 16680L, 16681L, 16682L, 
                         16685L, 16686L, 16687L, 16688L, 
                         16689L, 16692L, 16693L), 
                       class = "Date")
prices <- c(3182, 3205, 3272, 3185, 3201, 
            3236, 3272, 3224, 3194, 3188, 3213)
#+END_SRC

#+RESULTS:
| 3182 |
| 3205 |
| 3272 |
| 3185 |
| 3201 |
| 3236 |
| 3272 |
| 3224 |
| 3194 |
| 3188 |
| 3213 |


#+BEGIN_SRC R -n :exports both
par(mar=c(3,3,1,1), las = 1, mgp = c(2.5,0.5,0), tck = 0.005, bty = "n",
    ps = 11)
plot(timestamp, prices, type = "l", xlab = "", ylab = "")
#+END_SRC

#+RESULTS:

The =signal= function is very simple indeed.
#+BEGIN_SRC R -n :exports both
signal <- function()
    1
#+END_SRC

#+RESULTS:

=signal= must be written so that it returns the suggested
position in units of the asset. In this first example, the suggested
position always is one unit. It is only a =suggested= portfolio
because we can specify rules whether or not to trade. Examples follow
below.

To test this strategy, we call =btest=.  The initial cash is
zero per default, so initial wealth is also zero in this case. We can
change it through the argument =initial.cash=.

#+BEGIN_SRC R -n :exports both
(solution <- btest(prices = prices, signal = signal))
#+END_SRC 

#+RESULTS:

The function returns a list with a number of components, but they
are not printed. Instead, a simple print method displays some
information about the results.

We arrange more details into a =data.frame=. =sp= is the
suggested position; =p= is the actual position.
#+BEGIN_SRC R -n :exports both
makeTable <- function(solution, prices)
    data.frame(prices = prices,
               sp     = solution$suggested.position,
               p      = solution$position,
               wealth = solution$wealth,
               cash   = solution$cash)

makeTable(unclass(solution), prices)
#+END_SRC 

#+RESULTS:
| 3182 | 0 | 0 |   0 |     0 |
| 3205 | 1 | 1 |   0 | -3205 |
| 3272 | 1 | 1 |  67 | -3205 |
| 3185 | 1 | 1 | -20 | -3205 |
| 3201 | 1 | 1 |  -4 | -3205 |
| 3236 | 1 | 1 |  31 | -3205 |
| 3272 | 1 | 1 |  67 | -3205 |
| 3224 | 1 | 1 |  19 | -3205 |
| 3194 | 1 | 1 | -11 | -3205 |
| 3188 | 1 | 1 | -17 | -3205 |
| 3213 | 1 | 1 |   8 | -3205 |

We bought in the second period because the default setting for the
burnin =b= is 1. Thus, we lose one observation. In the case
here we do not rely in any way on the past; hence, we set =b=
to zero. With this setting, we buy at the first price and hold until
the end of the data.
#+BEGIN_SRC R -n :exports both
solution <- btest(prices = prices, signal = signal, b  = 0)
makeTable(solution, prices)
#+END_SRC 

#+RESULTS:
| 3182 | 1 | 1 |  0 | -3182 |
| 3205 | 1 | 1 | 23 | -3182 |
| 3272 | 1 | 1 | 90 | -3182 |
| 3185 | 1 | 1 |  3 | -3182 |
| 3201 | 1 | 1 | 19 | -3182 |
| 3236 | 1 | 1 | 54 | -3182 |
| 3272 | 1 | 1 | 90 | -3182 |
| 3224 | 1 | 1 | 42 | -3182 |
| 3194 | 1 | 1 | 12 | -3182 |
| 3188 | 1 | 1 |  6 | -3182 |
| 3213 | 1 | 1 | 31 | -3182 |

If you prefer the trades only, the solution also contains a
=journal=.
#+BEGIN_SRC R -n :exports both
journal(solution)
#+END_SRC

#+RESULTS:
| 1 | 1 | 3182 | asset 1 |

To make the journal more informative, we can pass timestamp and
instrument information.
#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, b  = 0,
              timestamp = timestamp, instrument = "FESX SEP 2015"))
#+END_SRC 

#+RESULTS:
| 2015-09-01 | 1 | 3182 | FESX SEP 2015 |


*** More useful examples

Now we make our strategy slightly more selective. The trading rule is
to have a position of 1 unit of the asset whenever the last observed
price is below 3200 and to have no position when it the price is above
3200. The =signal= function could look like this.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Close() < 3200)
        1 else 0
#+END_SRC

#+RESULTS:

We call =btest=.
#+BEGIN_SRC R -n :exports both
solution <- btest(prices = prices, signal = signal)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R -n :exports both
makeTable(solution, prices)
#+END_SRC 

#+RESULTS:
| 3182 | 0 | 0 |   0 |     0 |
| 3205 | 1 | 1 |   0 | -3205 |
| 3272 | 0 | 0 |  67 |    67 |
| 3185 | 0 | 0 |  67 |    67 |
| 3201 | 1 | 1 |  67 | -3134 |
| 3236 | 0 | 0 | 102 |   102 |
| 3272 | 0 | 0 | 102 |   102 |
| 3224 | 0 | 0 | 102 |   102 |
| 3194 | 0 | 0 | 102 |   102 |
| 3188 | 1 | 1 | 102 | -3086 |
| 3213 | 1 | 1 | 127 | -3086 |

The argument =initial.position= specifies the initial position;
default is no position. Suppose we had already held one unit of the
asset.
#+BEGIN_SRC R -n :exports both
solution <- btest(prices = prices, signal = signal,
                  initial.position = 1)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R -n :exports both
makeTable(solution, prices)
#+END_SRC 

#+RESULTS:
| 3182 | 1 | 1 | 3182 |    0 |
| 3205 | 1 | 1 | 3205 |    0 |
| 3272 | 0 | 0 | 3272 | 3272 |
| 3185 | 0 | 0 | 3272 | 3272 |
| 3201 | 1 | 1 | 3272 |   71 |
| 3236 | 0 | 0 | 3307 | 3307 |
| 3272 | 0 | 0 | 3307 | 3307 |
| 3224 | 0 | 0 | 3307 | 3307 |
| 3194 | 0 | 0 | 3307 | 3307 |
| 3188 | 1 | 1 | 3307 |  119 |
| 3213 | 1 | 1 | 3332 |  119 |

%% TODO: is this right? should be suggested position not be 1 in t==2?

Internally, =btest= stores \textsc{ohlc} prices in matrices.
So even for a single instrument we have four matrices: one for open
prices, one for high prices, and so on. In the single asset case, each
matrix has one column. If we were dealing with two assets, we would
again have four matrices, each with two columns. And so on.

%% TODO: add picture of matrices

We do not access these data directly. A function =Close= is
defined by =btest= and passed as an argument to
=signal=. Note that we do not add it as a formal argument to
=signal= since this is done automatically. In fact, doing it
manually would trigger an error message:
#+BEGIN_SRC R -n :exports both :eval never
signal <- function(Close = NULL)
    1
cat(try(btest(prices = prices, signal = signal)))
#+END_SRC

Similarly, we have functions =Open=, =High= and
=Low= (see Section~\ref{functions} above for a available
functions).

Suppose we wanted to add a variable, like a =threshold=
that tells us when to buy. This would need to be an argument to
=signal=; but it would also need to be passed with the
=\dots= argument of =btest=.
#+BEGIN_SRC R -n :exports both
signal <- function(threshold)
    if (Close() < threshold)
        1 else 0

solution <- btest(prices = prices, signal = signal,
                  threshold = 3200)      

makeTable(solution, prices)
#+END_SRC

#+RESULTS:
| 3182 | 0 | 0 |   0 |     0 |
| 3205 | 1 | 1 |   0 | -3205 |
| 3272 | 0 | 0 |  67 |    67 |
| 3185 | 0 | 0 |  67 |    67 |
| 3201 | 1 | 1 |  67 | -3134 |
| 3236 | 0 | 0 | 102 |   102 |
| 3272 | 0 | 0 | 102 |   102 |
| 3224 | 0 | 0 | 102 |   102 |
| 3194 | 0 | 0 | 102 |   102 |
| 3188 | 1 | 1 | 102 | -3086 |
| 3213 | 1 | 1 | 127 | -3086 |

So far we have treated =Close= as a function without arguments,
but actually it has an argument =lag= that defaults to
=1=. Suppose the rule were to buy if the last close is below the
second-to-last close. =signal= could look like this.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Close(1L) < Close(2L))
        1 else 0
#+END_SRC 

#+RESULTS:

We could also have written =(Close() < Close(2L))=. This rule
rule needs the close price of yesterday and of the day before
yesterday, so we need to increase =b=.
#+BEGIN_SRC R -n :exports both
makeTable(btest(prices = prices, signal = signal, b = 2), prices)
#+END_SRC

#+RESULTS:
| 3182 | 0 | nil | nil |     0 |
| 3205 | 0 |   0 |   0 |     0 |
| 3272 | 0 |   0 |   0 |     0 |
| 3185 | 0 |   0 |   0 |     0 |
| 3201 | 1 |   1 |   0 | -3201 |
| 3236 | 0 |   0 |  35 |    35 |
| 3272 | 0 |   0 |  35 |    35 |
| 3224 | 0 |   0 |  35 |    35 |
| 3194 | 1 |   1 |  35 | -3159 |
| 3188 | 1 |   1 |  29 | -3159 |
| 3213 | 1 |   1 |  54 | -3159 |

If we wanted to trade any other size, we would change our signal as
follows.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Close() < 3200)
        2 else 0

makeTable(btest(prices = prices, signal = signal), prices)
#+END_SRC

#+RESULTS:
| 3182 | 0 | 0 |   0 |     0 |
| 3205 | 2 | 2 |   0 | -6410 |
| 3272 | 0 | 0 | 134 |   134 |
| 3185 | 0 | 0 | 134 |   134 |
| 3201 | 2 | 2 | 134 | -6268 |
| 3236 | 0 | 0 | 204 |   204 |
| 3272 | 0 | 0 | 204 |   204 |
| 3224 | 0 | 0 | 204 |   204 |
| 3194 | 0 | 0 | 204 |   204 |
| 3188 | 2 | 2 | 204 | -6172 |
| 3213 | 2 | 2 | 254 | -6172 |

A typical way to specify a trading strategy is to map past prices into
=+1=, =0= or =-1= for long, flat or short. A
signal is often only given at a specified point (like in `buy one unit
now'). Example: suppose the third day is a Thursday, and our rule says
`buy after Thursday'.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Time() == 3L)
        1 else 0

makeTable(btest(prices = prices, signal = signal,
                initial.position = 0, initial.cash = 100),
          prices)
#+END_SRC

#+RESULTS:
| 3182 | 0 | 0 | 100 |   100 |
| 3205 | 0 | 0 | 100 |   100 |
| 3272 | 0 | 0 | 100 |   100 |
| 3185 | 1 | 1 | 100 | -3085 |
| 3201 | 0 | 0 | 116 |   116 |
| 3236 | 0 | 0 | 116 |   116 |
| 3272 | 0 | 0 | 116 |   116 |
| 3224 | 0 | 0 | 116 |   116 |
| 3194 | 0 | 0 | 116 |   116 |
| 3188 | 0 | 0 | 116 |   116 |
| 3213 | 0 | 0 | 116 |   116 |

But this is probably not what we wanted. If the rule is to buy and
then keep the long position, we should have written it like this.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Time() == 3L)
        1 else Portfolio()
#+END_SRC

#+RESULTS:

The function =Portfolio= evaluates to last period's
portfolio. Like =Close=, its first argument sets the time
=lag=, which defaults to~1.
#+BEGIN_SRC R -n :exports both
makeTable(btest(prices = prices, signal = signal), prices)
#+END_SRC

#+RESULTS:
| 3182 | 0 | 0 |  0 |     0 |
| 3205 | 0 | 0 |  0 |     0 |
| 3272 | 0 | 0 |  0 |     0 |
| 3185 | 1 | 1 |  0 | -3185 |
| 3201 | 1 | 1 | 16 | -3185 |
| 3236 | 1 | 1 | 51 | -3185 |
| 3272 | 1 | 1 | 87 | -3185 |
| 3224 | 1 | 1 | 39 | -3185 |
| 3194 | 1 | 1 |  9 | -3185 |
| 3188 | 1 | 1 |  3 | -3185 |
| 3213 | 1 | 1 | 28 | -3185 |

A common scenario is also a =signal= that evaluates to a
weight; for instance, after a portfolio optimisation. (Be sure to have
a meaningful initial wealth: 5 percent of nothing is nothing.)
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Close() < 3200)
        0.05 else 0

solution <- btest(prices = prices,
                  signal = signal,
                  initial.cash = 100,
                  convert.weights = TRUE)
makeTable(solution, prices)
#+END_SRC

#+RESULTS:
| 3182 |                   0 |                   0 |              100 |              100 |
| 3205 | 0.00157133878064111 | 0.00157133878064111 |              100 | 94.9638592080452 |
| 3272 |                   0 |                   0 | 100.105279698303 | 100.105279698303 |
| 3185 |                   0 |                   0 | 100.105279698303 | 100.105279698303 |
| 3201 | 0.00157151145523239 | 0.00157151145523239 | 100.105279698303 | 95.0748715301041 |
| 3236 |                   0 |                   0 | 100.160282599236 | 100.160282599236 |
| 3272 |                   0 |                   0 | 100.160282599236 | 100.160282599236 |
| 3224 |                   0 |                   0 | 100.160282599236 | 100.160282599236 |
| 3194 |                   0 |                   0 | 100.160282599236 | 100.160282599236 |
| 3188 | 0.00156794431119656 | 0.00156794431119656 | 100.160282599236 | 95.1616761351415 |
| 3213 | 0.00157089527288639 | 0.00156794431119656 | 100.199481207016 | 95.1616761351415 |

Note that now we rebalance in every period. Suppose we did not want
that.
#+BEGIN_SRC R -n :exports both
do.rebalance <- function() {
    if (sum(abs(SuggestedPortfolio(0) - SuggestedPortfolio())) > 0.02)
        TRUE else FALSE
}

solution <- btest(prices = prices,
                  signal = signal,
                  initial.cash = 100,
                  do.rebalance = do.rebalance,
                  convert.weights = TRUE)

makeTable(solution, prices)
#+END_SRC

#+RESULTS:
| 3182 |                   0 | 0 | 100 | 100 |
| 3205 | 0.00157133878064111 | 0 | 100 | 100 |
| 3272 |                   0 | 0 | 100 | 100 |
| 3185 |                   0 | 0 | 100 | 100 |
| 3201 | 0.00156985871271586 | 0 | 100 | 100 |
| 3236 |                   0 | 0 | 100 | 100 |
| 3272 |                   0 | 0 | 100 | 100 |
| 3224 |                   0 | 0 | 100 | 100 |
| 3194 |                   0 | 0 | 100 | 100 |
| 3188 | 0.00156543519098309 | 0 | 100 | 100 |
| 3213 | 0.00156838143036386 | 0 | 100 | 100 |

See also the =tol= argument.  %% TODO: expand

**** Passing environments

To keep information persistent, we can use environments.
#+BEGIN_SRC R -n :exports both
external <- new.env()
external$vec <- numeric(length(prices))
signal <- function(threshold, external) {
    external$vec[Time()] <- Close()
    if (Close() < threshold)
        1 else 0
}

solution <- btest(prices = prices,
                     signal = signal,
                     threshold = 100,
                     external = external)

cbind(makeTable(solution, prices), external$vec)
#+END_SRC

#+RESULTS:
| 3182 | 0 | 0 | 0 | 0 | 3182 |
| 3205 | 0 | 0 | 0 | 0 | 3205 |
| 3272 | 0 | 0 | 0 | 0 | 3272 |
| 3185 | 0 | 0 | 0 | 0 | 3185 |
| 3201 | 0 | 0 | 0 | 0 | 3201 |
| 3236 | 0 | 0 | 0 | 0 | 3236 |
| 3272 | 0 | 0 | 0 | 0 | 3272 |
| 3224 | 0 | 0 | 0 | 0 | 3224 |
| 3194 | 0 | 0 | 0 | 0 | 3194 |
| 3188 | 0 | 0 | 0 | 0 | 3188 |
| 3213 | 0 | 0 | 0 | 0 |    0 |

** Examples: Multiple assets


#+BEGIN_COMMENT
##%% \subsection{Again, a simple example}
##%% 
##%% <<>>=
##%% prices1 <- c(100,98, 98, 97, 96, 98,97,98,99,101)
##%% prices2 <- c(100,99,100,102,101,100,96,97,95,82)
##%% prices <- cbind(prices1, prices2)
##%% 
##%% signal <- function()
##%%     if (Close()[1L] > Close()[2L])
##%%         c(1, 0) else c(0, 1)
##%% 
##%% 
##%% (solution <- btest(prices = list(prices),
##%%                    signal = signal,
##%%                    b=2))
##%% #+END_SRC
##%% 
##%% We can also give more useful names to the assets.
##%% <<>>=
##%% prices <- cbind(AA = prices1, BB = prices2)
##%% solution <- btest(prices = list(prices),
##%%                                signal = signal, b=2)
##%% makeTable(solution, prices)
##%% 
##%% #+END_SRC
##%% 
#+END_COMMENT

** Common tasks

There is more than one ways to accomplish a certain task.  I describe
how I have handled some specific tasks.

*** Remembering an entry price
In signal: use the current price and assign in =Globals=.

*** Delaying signals

*** Losing signals

*** Various ways to specify when to do something

btest takes two functions, do.signal and do.rebalance, that tell the
algorithm when to compute a new portfolio and when to rebalance. There
are a number of shortcuts.

#+BEGIN_SRC R -n :exports both
tmp <- structure(c(3490, 3458, 3434, 3358, 3287, 3321, 3419, 3535, 3589, 
                   3603, 3626, 3677, 3672, 3689, 3646, 3633, 3631, 3599, 3517, 3549, 
                   3572, 3578, 3598, 3634, 3618, 3680, 3669, 3640, 3675, 3604, 3492, 
                   3513, 3495, 3503, 3497, 3433, 3356, 3256, 3067, 3228, 3182, 3286, 
                   3279, 3269, 3182, 3205, 3272, 3185, 3201, 3236, 3272, 3224, 3194, 
                   3188, 3213, 3255, 3261), .Dim = c(57L, 1L), 
                 .Dimnames = list(
                     NULL, "fesx201509"), 
                 index = structure(c(16617L, 16618L, 
                                     16619L, 16622L, 16623L, 16624L, 16625L, 
                                     16626L, 16629L, 16630L, 
                                     16631L, 16632L, 16633L, 16636L, 16637L, 
                                     16638L, 16639L, 16640L, 
                                     16643L, 16644L, 16645L, 16646L, 16647L, 16650L, 
                                     16651L, 16652L, 
                                     16653L, 16654L, 16657L, 16658L, 16659L, 16660L, 
                                     16661L, 16664L, 
                                     16665L, 16666L, 16667L, 16668L, 16671L, 16672L, 
                                     16673L, 16674L, 
                                     16675L, 16678L, 16679L, 16680L, 16681L, 16682L, 
                                     16685L, 16686L, 
                                     16687L, 16688L, 16689L, 16692L, 16693L, 16694L, 
                                     16695L), class = "Date"), class = "zoo")

prices <- coredata(tmp)
timestamp <- index(tmp)
signal <- function()
    Time()
journal(btest(prices = prices, signal = signal))
#+END_SRC 

#+RESULTS:
|  2 | 1 | 3458 | fesx201509 |
|  3 | 1 | 3434 | fesx201509 |
|  4 | 1 | 3358 | fesx201509 |
|  5 | 1 | 3287 | fesx201509 |
|  6 | 1 | 3321 | fesx201509 |
|  7 | 1 | 3419 | fesx201509 |
|  8 | 1 | 3535 | fesx201509 |
|  9 | 1 | 3589 | fesx201509 |
| 10 | 1 | 3603 | fesx201509 |
| 11 | 1 | 3626 | fesx201509 |
| 12 | 1 | 3677 | fesx201509 |
| 13 | 1 | 3672 | fesx201509 |
| 14 | 1 | 3689 | fesx201509 |
| 15 | 1 | 3646 | fesx201509 |
| 16 | 1 | 3633 | fesx201509 |
| 17 | 1 | 3631 | fesx201509 |
| 18 | 1 | 3599 | fesx201509 |
| 19 | 1 | 3517 | fesx201509 |
| 20 | 1 | 3549 | fesx201509 |
| 21 | 1 | 3572 | fesx201509 |
| 22 | 1 | 3578 | fesx201509 |
| 23 | 1 | 3598 | fesx201509 |
| 24 | 1 | 3634 | fesx201509 |
| 25 | 1 | 3618 | fesx201509 |
| 26 | 1 | 3680 | fesx201509 |
| 27 | 1 | 3669 | fesx201509 |
| 28 | 1 | 3640 | fesx201509 |
| 29 | 1 | 3675 | fesx201509 |
| 30 | 1 | 3604 | fesx201509 |
| 31 | 1 | 3492 | fesx201509 |
| 32 | 1 | 3513 | fesx201509 |
| 33 | 1 | 3495 | fesx201509 |
| 34 | 1 | 3503 | fesx201509 |
| 35 | 1 | 3497 | fesx201509 |
| 36 | 1 | 3433 | fesx201509 |
| 37 | 1 | 3356 | fesx201509 |
| 38 | 1 | 3256 | fesx201509 |
| 39 | 1 | 3067 | fesx201509 |
| 40 | 1 | 3228 | fesx201509 |
| 41 | 1 | 3182 | fesx201509 |
| 42 | 1 | 3286 | fesx201509 |
| 43 | 1 | 3279 | fesx201509 |
| 44 | 1 | 3269 | fesx201509 |
| 45 | 1 | 3182 | fesx201509 |
| 46 | 1 | 3205 | fesx201509 |
| 47 | 1 | 3272 | fesx201509 |
| 48 | 1 | 3185 | fesx201509 |
| 49 | 1 | 3201 | fesx201509 |
| 50 | 1 | 3236 | fesx201509 |
| 51 | 1 | 3272 | fesx201509 |
| 52 | 1 | 3224 | fesx201509 |
| 53 | 1 | 3194 | fesx201509 |
| 54 | 1 | 3188 | fesx201509 |
| 55 | 1 | 3213 | fesx201509 |
| 56 | 1 | 3255 | fesx201509 |
| 57 | 1 | 3261 | fesx201509 |

#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, 
              do.signal = c(10, 20, 30)))
#+END_SRC 

#+RESULTS:
| 10 |  9 | 3603 | fesx201509 |
| 20 | 10 | 3549 | fesx201509 |
| 30 | 10 | 3604 | fesx201509 |

#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600))
#+END_SRC 

#+RESULTS:
| 10 | 9 | 3603 | fesx201509 |
| 11 | 1 | 3626 | fesx201509 |
| 12 | 1 | 3677 | fesx201509 |
| 13 | 1 | 3672 | fesx201509 |
| 14 | 1 | 3689 | fesx201509 |
| 15 | 1 | 3646 | fesx201509 |
| 16 | 1 | 3633 | fesx201509 |
| 17 | 1 | 3631 | fesx201509 |
| 24 | 7 | 3634 | fesx201509 |
| 25 | 1 | 3618 | fesx201509 |
| 26 | 1 | 3680 | fesx201509 |
| 27 | 1 | 3669 | fesx201509 |
| 28 | 1 | 3640 | fesx201509 |
| 29 | 1 | 3675 | fesx201509 |
| 30 | 1 | 3604 | fesx201509 |

#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600,
              do.rebalance = FALSE))
#+END_SRC 

#+RESULTS:

#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600,
              do.rebalance = c(26, 30)))
#+END_SRC 

#+RESULTS:
| 26 | 25 | 3680 | fesx201509 |
| 30 |  4 | 3604 | fesx201509 |

When =timestamp= is specified, certain calendar times are also
supported; =timestamp= must of a type that can be coerced to
=Date=.
#+BEGIN_SRC R -n :exports both
cat(try(journal(btest(prices = prices, signal = signal, 
                      do.signal = "firstofmonth"))))
#+END_SRC 

#+RESULTS:

#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, 
              do.signal = "firstofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
| 2015-08-03 | 23 | 3634 | fesx201509 |
| 2015-09-01 | 21 | 3182 | fesx201509 |

#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, 
              do.signal = "lastofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
| 2015-07-31 | 22 | 3598 | fesx201509 |
| 2015-08-31 | 21 | 3269 | fesx201509 |
| 2015-09-17 | 13 | 3261 | fesx201509 |

#+BEGIN_SRC R -n :exports both
journal(btest(prices = prices, signal = signal, 
              do.signal = TRUE,
              do.rebalance = "lastofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
| 2015-07-31 | 22 | 3598 | fesx201509 |
| 2015-08-31 | 21 | 3269 | fesx201509 |
| 2015-09-17 | 13 | 3261 | fesx201509 |

There is also a function Timestamp.
#+BEGIN_SRC R -n :exports both
signal <- function(timestamp) {
    if (Close() > 3500) {
        cat("Lagged price is > 3600 on", as.character(Timestamp()), "\n") 
        1
    } else 
        0
    
}
journal(btest(prices = prices, 
              signal = signal,
              ##signal = function() if (Close() > 3500) 1 else 0, 
              do.signal = TRUE,
              do.rebalance = "lastofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
| 2015-07-31 |  1 | 3598 | fesx201509 |
| 2015-08-31 | -1 | 3269 | fesx201509 |

*** Testing rebalancing frequency

*** Writing a log
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Close() < 3200)
        1 else 0

print.info <- function() {
    cat("period",
        sprintf("%2d", Time(0L)), "...",
        sprintf("%3d", Wealth(0)), "\n")
    flush.console()
}

solution <- btest(prices = prices,
                     print.info = print.info,
                     signal = signal)

makeTable(solution, prices)

#+END_SRC

#+RESULTS:
| 3490 | 0 | 0 |   0 |     0 |
| 3458 | 0 | 0 |   0 |     0 |
| 3434 | 0 | 0 |   0 |     0 |
| 3358 | 0 | 0 |   0 |     0 |
| 3287 | 0 | 0 |   0 |     0 |
| 3321 | 0 | 0 |   0 |     0 |
| 3419 | 0 | 0 |   0 |     0 |
| 3535 | 0 | 0 |   0 |     0 |
| 3589 | 0 | 0 |   0 |     0 |
| 3603 | 0 | 0 |   0 |     0 |
| 3626 | 0 | 0 |   0 |     0 |
| 3677 | 0 | 0 |   0 |     0 |
| 3672 | 0 | 0 |   0 |     0 |
| 3689 | 0 | 0 |   0 |     0 |
| 3646 | 0 | 0 |   0 |     0 |
| 3633 | 0 | 0 |   0 |     0 |
| 3631 | 0 | 0 |   0 |     0 |
| 3599 | 0 | 0 |   0 |     0 |
| 3517 | 0 | 0 |   0 |     0 |
| 3549 | 0 | 0 |   0 |     0 |
| 3572 | 0 | 0 |   0 |     0 |
| 3578 | 0 | 0 |   0 |     0 |
| 3598 | 0 | 0 |   0 |     0 |
| 3634 | 0 | 0 |   0 |     0 |
| 3618 | 0 | 0 |   0 |     0 |
| 3680 | 0 | 0 |   0 |     0 |
| 3669 | 0 | 0 |   0 |     0 |
| 3640 | 0 | 0 |   0 |     0 |
| 3675 | 0 | 0 |   0 |     0 |
| 3604 | 0 | 0 |   0 |     0 |
| 3492 | 0 | 0 |   0 |     0 |
| 3513 | 0 | 0 |   0 |     0 |
| 3495 | 0 | 0 |   0 |     0 |
| 3503 | 0 | 0 |   0 |     0 |
| 3497 | 0 | 0 |   0 |     0 |
| 3433 | 0 | 0 |   0 |     0 |
| 3356 | 0 | 0 |   0 |     0 |
| 3256 | 0 | 0 |   0 |     0 |
| 3067 | 0 | 0 |   0 |     0 |
| 3228 | 1 | 1 |   0 | -3228 |
| 3182 | 0 | 0 | -46 |   -46 |
| 3286 | 1 | 1 | -46 | -3332 |
| 3279 | 0 | 0 | -53 |   -53 |
| 3269 | 0 | 0 | -53 |   -53 |
| 3182 | 0 | 0 | -53 |   -53 |
| 3205 | 1 | 1 | -53 | -3258 |
| 3272 | 0 | 0 |  14 |    14 |
| 3185 | 0 | 0 |  14 |    14 |
| 3201 | 1 | 1 |  14 | -3187 |
| 3236 | 0 | 0 |  49 |    49 |
| 3272 | 0 | 0 |  49 |    49 |
| 3224 | 0 | 0 |  49 |    49 |
| 3194 | 0 | 0 |  49 |    49 |
| 3188 | 1 | 1 |  49 | -3139 |
| 3213 | 1 | 1 |  74 | -3139 |
| 3255 | 0 | 0 | 116 |   116 |
| 3261 | 0 | 0 | 116 |   116 |

And since =cat= has a =file= argument, we can also write
such information into a logfile.


*** Selecting parameters

Suppose you have a strategy that depends on a parameter
vector~$\theta$.  For a given $\theta$, the signal for the strategy
would look like this. 
\begin{verbatim}
signal = function(theta) {
    compute signal(theta)
}
\end{verbatim}
Now suppose we do not know theta.  We might want to test several
values, and then keep the best one.  For this, we need to call btest
recursively: at a point in time t, the strategy simulates the results
for various values for theta and chooses the best theta, according to
some criterion~$f$.

A useful idiom is this:
\begin{verbatim}
signal = function(theta0) {
    if (not defined theta0) {
        ## run btest with theta_1, ... \theta_n, select best theta
        theta = argmin_theta f(btest(theta_i))
    } else
        theta = theta0

    compute indicator(theta)
    compute signal
}
\end{verbatim}

Let us look at an actual example.


#+BEGIN_SRC R :eval never

require("tseries")
require("zoo")

tmp <- get.hist.quote("^GSPC", start = "2011-01-01", end = "2013-12-31", quote = "Close")

signal <- function(Data) {
    
    if (is.na(Data$N)) {
        
        price <- Close(Data$hist:1)
        Data0 <- list(N = 10, hist = 50)
        res1 <- btest(price, signal, Data = Data0, b = 100)
        Data0 <- list(N = 20, hist = 50)
        res2 <- btest(price, signal, Data = Data0, b = 100)
        if (tail(res1$wealth, 1) > tail(res2$wealth, 1))
            N <- 10 else N <- 20
        
    } else 
        N <- Data$N

    MA <- runStats("mean", Close(Data$hist:1), N = N)
    pos <- 0
    if (Close() > tail(MA, 1))
        pos <- 1
    pos
}
    
Data <- list(N = NA, hist = 200)
res <- btest(tmp$Close, signal, Data = Data, b = 202, initial.cash = 100, 
             convert.weights = TRUE)    
par(mfrow = c(2,1))
plot(index(tmp), res$wealth, type = "s")    
plot(tmp)

#+END_SRC 




* Computing profit and (or) loss

\section{The simple case}

We have an account, currency is euro.  We buy one asset at a price of
100~euro and sell it again at 102~euro.  We have made a profit of
2~euros.  This simple case happens often enough to make the required
computation simple as well.  Computing profit-or-loss (\pl) can be handled
through the function =pl=.
#+BEGIN_SRC R -n :exports both
pl(price  = c(100, 102), 
    amount = c(  1,  -1))
#+END_SRC 

#+RESULTS:

Now suppose that a trader bought one~unit at 50, one~unit at 90 and
sold two~units at 100, resulting in a profit of 60.  But suppose that
the actual order of the trades was\medskip

buy at 90 \quad $\Rightarrow$ \quad buy at 50 \quad $\Rightarrow$ \quad
sell at 100\,.\medskip

Even if we know nothing about what was traded and when, some
information is provided by the order of the trades: the position had a
drawdown of at least~40 before it recovered.  For situations like
this, the argument =along.timestamp= can be used. (Note that we
do not provide an actual timestamp, in which case the function will
implicitly use integers 1, 2, \ldots, =length(amount)=\,.)
#+BEGIN_SRC R -n :exports both
pl(price  = c( 90, 50, 100), 
    amount = c(  1,  1,  -2), along.timestamp = TRUE)
#+END_SRC 

#+RESULTS:

With no further arguments, the function will compute the
running position and evaluate it at every trade with the trade's
price.  This may not be accurate because of bid--ask spreads or other
transaction costs, but it provides more information than only
computing the \pl\ for the trades.
#+BEGIN_SRC R -n :exports both
J <- journal(price     = c( 90, 50, 100), 
              amount    = c(  1,  1,  -2),
              timestamp = c(  2,  4,   7))
pl(J, along.timestamp = FALSE)
#+END_SRC 

#+RESULTS:

Suppose we also have a time series of the prices between times 1
and~10.  We can evaluate the position at every time instant, and then
plot position, \pl\ and the price of the traded instrument.

#+BEGIN_SRC R -n :exports both
## [TODO]
price <- c(100,90,70,50,60,80,100,90,110,105)

## position
position(J, when = 1:10)

## pl
## value position at when = 1:10
## compute value if journal at 1:10 => subtract

#+END_SRC 

#+RESULTS:
| 0 |
| 1 |
| 1 |
| 2 |
| 2 |
| 2 |
| 0 |
| 0 |
| 0 |
| 0 |

A more-useful example for =pl= with =along.timestamp= is
a trading history of a high-frequency strategy.  Suppose for example
we had traded EURUSD 200~times in single day and wished to plot the
result.  At such a frequency, the prices at which the trades were
executed is useful to value any open position.

#+BEGIN_SRC R -n :exports both
## [TODO]
#+END_SRC 

#+RESULTS:

We may also want to compute the \pl\ between two points in
time.  If our only data source is a journal, this may be impossible
since we need to evaluate the position at both points in time.  A simple
example follows; the data first.
#+BEGIN_SRC R -n :exports both
timestamp <- 1:20
amount <- c(-5, 5, 5, -5, -5, 5, 5, 5, 5, 
            -5, 5, 5, -5, 5, 5, -5, -5, -5, 
            -5, -5)
price <- c(106, 101, 110, 110, 105, 105, 105, 104, 110, 104, 
           103, 108, 106, 102, 108, 107, 103, 104, 109, 104)
(J <- journal(timestamp = timestamp, amount = amount, price = price))
#+END_SRC 

#+RESULTS:
| nil |  1 | -5 | 106 |
| nil |  2 |  5 | 101 |
| nil |  3 |  5 | 110 |
| nil |  4 | -5 | 110 |
| nil |  5 | -5 | 105 |
| nil |  6 |  5 | 105 |
| nil |  7 |  5 | 105 |
| nil |  8 |  5 | 104 |
| nil |  9 |  5 | 110 |
| nil | 10 | -5 | 104 |
| nil | 11 |  5 | 103 |
| nil | 12 |  5 | 108 |
| nil | 13 | -5 | 106 |
| nil | 14 |  5 | 102 |
| nil | 15 |  5 | 108 |
| nil | 16 | -5 | 107 |
| nil | 17 | -5 | 103 |
| nil | 18 | -5 | 104 |
| nil | 19 | -5 | 109 |
| nil | 20 | -5 | 104 |

Suppose we want the pl between times 5 and~8. Conceptually, it is
simple: we first compute the position at~5 and treat it as a trade.
Clearly, for this we need the price of the instruments in the position
at timestamp~5.  Then we extract all the trades that occured later
than 5, up to 8.  The final position, again, would be treated as a
trade, but with signs reversed. That, we close the position, if any
exists.  Here, again, we need the prices of the instruments.

The function =pl= does (most of) these tasks for us.
#+BEGIN_SRC R -n :exports both
from <- 5
to   <- 8
price.from <- 106
price.to   <- 105
position.from <- position(J, when = from)
trades <- J[J$timestamp > from & J$timestamp <= to]

pl(trades, 
   initial.position = position.from, 
   initial.price = price.from,
   current.price = price.to)   
#+END_SRC 

#+RESULTS:


You can also use this mechanism if you wish to compute the \pl\
of a complete journal, but with some positions not closed yet.  The
simplest example: a journal of just one trade.
#+BEGIN_SRC R -n :exports both
(J <- J[1])
#+END_SRC 

#+RESULTS:
| nil | 1 | -5 | 106 |

There is no way to tell the pl of this trades\ldots 
#+BEGIN_SRC R -n :exports both
pl(J)
#+END_SRC 

#+RESULTS:

\ldots unless the current price is supplied.
#+BEGIN_SRC R -n :exports both
pl(J, current.price = 105)
#+END_SRC 

#+RESULTS:

\section{More  complicated cases}


%% TODO:

%% - example EUR investor buys INTC

%% - pure FX portfolio

Unfortunately, in real life computing \pl\ is often more complicated:

\begin{itemize}

\item One asset-price unit may not translate into one currency unit:
  we have multipliers or contract factors.  That is easy to solve by
  computing effective position sizes, but it may take some thinking to
  come up with a reusable scheme (eg, looking up multipliers in a
  table).
    
\item Asset positions may map into cashflows in non-obvious ways.  The
  simple case is the delay in actual payment and delivery of an asset,
  which is often two or three days.  The more problematic cases are
  derivatives with daily adjustments of margins.

\item Assets may be denominated in various currencies.
  
\item Currencies themselves may be assets in the portfolio.  Depending
  on how they are traded (cash, forwards, \emph{\&c.}), computing \pl\ 
  may not be straightforward.
\end{itemize}

How (or rather: to what degree) these troubles are handled is, as
always, up to the user.  For a single instrument, computing
profit/loss in units of the instrument is always meaningful (though,
perhaps, not always intuitive).  But \emph{adding up} the profits and
losses of several assets often does not work because of multipliers or
different currencies.  The simplest and most transparent way is then
to manipulate the journal before \pl\ is computed (eg, multiply
notionals by their multipliers).




We look at two examples: (i)~computing the \pl\ of several assets in
currency units; and (ii)~computing time-weighted returns of a
portfolio of assets.

\subsection{Several assets}

In this example we compute the \pl\ in currency units of a portfolio
over time.  We start with the following journal.

#+BEGIN_SRC R
## dput(ISOdatetime(2013,c(11,11,12,12,11,12), c(28,28,2,3,27,2), 
##                     c(9,12,13,9,9,13),c(35,50,21,57,52,54),0))
timestamp <- structure(c(1385627700, 1385639400, 1385986860, 1386061020, 1385542320, 
                         1385988840), class = c("POSIXct", "POSIXt"), tzone = "")

(J <- journal(amount    = c(100,100,-50,-150, 100,-50),
             timestamp = timestamp,
             price = c(11.6, 11.62, 11.67, 11.47, 25.1,26.29),
             instrument = c(rep("DTE", 4), rep("DPW", 2))))
#+END_SRC 

#+RESULTS:
| DTE | 2013-11-28 09:35:00 |  100 |  11.6 |
| DTE | 2013-11-28 12:50:00 |  100 | 11.62 |
| DTE | 2013-12-02 13:21:00 |  -50 | 11.67 |
| DTE | 2013-12-03 09:57:00 | -150 | 11.47 |
| DPW | 2013-11-27 09:52:00 |  100 |  25.1 |
| DPW | 2013-12-02 13:54:00 |  -50 | 26.29 |

We shall compute end-of-day \pl\ of these trades.  In case you
wondered: \textsc{dte} stands for Deutsche Telekom and \textsc{dpw} is
Deutsche Post, both traded on \textsc{xetra}.  Thus, end-of-day is
17:30 in Frankfurt am Main, Germany.

(There is nothing special about end-of-day.  We could just as well
have decided to have hourly numbers, say.  But I would like to keep
this example small.)  The prices at these timestamps are stored
in a matrix =price.table=.
#+BEGIN_SRC R
price.table <- structure(c(25.71, 25.965, 26.03, 26.32, 25.305,
                           11.65, 11.655, 11.685, 11.62, 11.375), 
                         .Dim = c(5L, 2L), 
                         .Dimnames = list(NULL, c("DPW", "DTE")))

## times <- as.POSIXct(c("2013-11-27 17:30:00", "2013-11-28 17:30:00", "2013-11-29 17:30:00", 
##                       "2013-12-02 17:30:00", "2013-12-03 17:30:00"))
when <- times <- structure(c(1385569800, 1385656200, 1385742600, 
                     1386001800, 1386088200), 
                   class = c("POSIXct", "POSIXt"), 
                   tzone = "")
rownames(price.table) <- as.character(times)
#+END_SRC 

#+RESULTS:
| 2013-11-27 17:30:00 |
| 2013-11-28 17:30:00 |
| 2013-11-29 17:30:00 |
| 2013-12-02 17:30:00 |
| 2013-12-03 17:30:00 |

#+BEGIN_SRC R -n :exports both
price.table
#+END_SRC 

#+RESULTS:
|  25.71 |  11.65 |
| 25.965 | 11.655 |
|  26.03 | 11.685 |
|  26.32 |  11.62 |
| 25.305 | 11.375 |

\subsubsection*{Step 1: compute value of portfolio}

We first need the position sizes at the timestamps at which we want to
compute \pl.  We store them in a vector =when=.
#+BEGIN_SRC R -n :exports both
when
#+END_SRC 

#+RESULTS:
| 2013-11-27 17:30:00 |
| 2013-11-28 17:30:00 |
| 2013-11-29 17:30:00 |
| 2013-12-02 17:30:00 |
| 2013-12-03 17:30:00 |

The position at =when= is quickly computed.
#+BEGIN_SRC R -n :exports both
(pos <- position(J, when = when))
#+END_SRC 

#+RESULTS:
| 100 |   0 |
| 100 | 200 |
| 100 | 200 |
|  50 | 150 |
|  50 |   0 |

Note that each element in the position matrix corresponds to an
element in the matrix =price.table=.  That is, the rows refer
to the timestamps:
#+BEGIN_SRC R -n :exports both
attr(pos, "timestamp")
#+END_SRC 

#+RESULTS:
| 2013-11-27 17:30:00 |
| 2013-11-28 17:30:00 |
| 2013-11-29 17:30:00 |
| 2013-12-02 17:30:00 |
| 2013-12-03 17:30:00 |

The columns must be ordered like the instruments:
#+BEGIN_SRC R -n :exports both 
attr(pos, "instrument")
#+END_SRC 

#+RESULTS:
| DPW |
| DTE |

Thus, we need to multiply both matrices element-by-element, which is
exactly what the function =valuation= does.  A warning: the
function does currently not at all check =price.table=.
#+BEGIN_SRC R :eval never
PMwR:::valuation(pos, price.table = price.table)
#+END_SRC 
We care about the row sums of the results.
#+BEGIN_SRC R :eval never
(v <- PMwR:::valuation(pos, price.table = price.table, do.sum = TRUE))
#+END_SRC
If the assets have specific multipliers, we can pass them as a named
vector.  (That is the preferred way, at least.  An unnamed vector will
do as well, as will a single number, which is recycled.)
#+BEGIN_SRC R :eval never
PMwR:::valuation(pos, price.table = price.table, 
          multiplier = c(DTE = 5, DPW = 0.5))
#+END_SRC

\subsubsection*{Step 2: compute cashflows that led to portfolio}

We create a vector =cf= that will store the cashflows.
#+BEGIN_SRC R -n :exports both
cf <- numeric(length(attr(pos, "timestamp")))
names(cf) <- as.character(attr(pos, "timestamp"))
#+END_SRC 

#+RESULTS:
| 2013-11-27 17:30:00 |
| 2013-11-28 17:30:00 |
| 2013-11-29 17:30:00 |
| 2013-12-02 17:30:00 |
| 2013-12-03 17:30:00 |


#+BEGIN_SRC R -n :exports both
## tmp <- PMwR:::valuation(J)
## tmp$timestamp <- pos$timestamp[PMwR:::matchOrNext(tmp$timestamp, pos$timestamp)]
## cash <- aggregate(tmp$amount, list(tmp$timestamp), sum)
## cf[match(cash[[1]], pos$timestamp)] <- cash[[2]]
## (v.net <- v + cumsum(cf))
#+END_SRC 

#+RESULTS:

TODO: check -- create interface journal/when/price.table?

\subsubsection*{Summary}

\begin{enumerate}
\item Fix =when=; compute position at =when=.
\item Prepare a matrix price.table of =length(when)= rows,
  whose columns correspond to the assets in the portfolio.
\item Call =valuation(position)= and store the result as
  =v=.
\item Call =valuation(journal)=; map the timestamps of the new
  journal to =when=; sum the cashflows by timestamp; subtract
  the resulting cashflows from =v=.
\end{enumerate}

To compute returns, choose a suitable total portfolio value and divide
by it.



* Computing returns

The function =returns= computes returns for various types of
objects. The return of an asset in period~$t$ is defined as
\begin{align} \label{eq:return}
  r_t = \frac{P_t}{P_{t-1}}-1 = R_t+1\,.
\end{align}


For computing pl (in currency units), see Chapter~XX.


** Numeric vectors and matrices, data frames

#+BEGIN_SRC R -n :exports both
x <- c(100, 102, 101, 100)
returns(x)
#+END_SRC 

#+RESULTS:
|                 0.02 |
| -0.00980392156862742 |
| -0.00990099009900991 |

To replace the lost first observation, specify =pad=.
#+BEGIN_SRC R -n :exports both
returns(x, pad = 0)
returns(x, pad = NA)
#+END_SRC 

#+RESULTS:
|                  nil |
|                 0.02 |
| -0.00980392156862742 |
| -0.00990099009900991 |

When =x= is a matrix or a data.frame, returns are computed
for each column.
#+BEGIN_SRC R -n :exports both
X <- cbind(x, x, x)
returns(X, pad = NA)
returns(as.data.frame(X), pad = NA)
#+END_SRC 

#+RESULTS:
|                  nil |                  nil |                  nil |
|                 0.02 |                 0.02 |                 0.02 |
| -0.00980392156862742 | -0.00980392156862742 | -0.00980392156862742 |
| -0.00990099009900991 | -0.00990099009900991 | -0.00990099009900991 |

\section{=zoo= objects}

Vectors.
#+BEGIN_SRC R -n :exports both
z <- zoo(x, as.Date("2015-1-5") + 0:2)
returns(z)
returns(z, pad = NA)
#+END_SRC 

#+RESULTS:
|                  nil |
|                 0.02 |
| -0.00980392156862742 |

Matrices.
#+BEGIN_SRC R -n :exports both
z <- zoo(X, as.Date("2015-1-5") + 0:2)
returns(z)
returns(z, pad = NA)
#+END_SRC 

#+RESULTS:
|                  nil |                  nil |                  nil |
|                 0.02 |                 0.02 |                 0.02 |
| -0.00980392156862742 | -0.00980392156862742 | -0.00980392156862742 |

\section{Period returns}

When a timestamp is available, =returns= can compute
period returns. The semantics for these computations are somewhat
different; the result is a vector of returns with attributes and class
=preturns=. Most useful is a =print= method.
#+BEGIN_SRC R -n :exports both
set.seed(45)
t <- as.Date("2014-11-1") + 0:80
x <- cumprod(1 + rnorm(length(t), sd = 0.01))
returns(x, t = t, period = "month")
returns(x, t = t, period = "year")
#+END_SRC 

#+RESULTS:

See =?print.preturns= for more display options. For instance:
#+BEGIN_SRC R -n :exports both
print(returns(zoo(x, t), period = "month"), 
      digits = 2, year.rows = FALSE)
#+END_SRC 

#+RESULTS:

To get annualised returns, use period `=ann='.
#+BEGIN_SRC R -n :exports both
returns(x, t = t,  period = "ann")
returns(zoo(x, t), period = "ann")
#+END_SRC 

#+RESULTS:

But note that the function did \emph{not} annualise: it does
not annualise if the time period is shorter than one year.
#+BEGIN_SRC R -n :exports both
x[length(x)]/x[1] - 1
#+END_SRC 

#+RESULTS:
: 0.0690193782880717

To force annualising, add a `=!='. The exclamation mark serves
as a mnenomic that it is now imperative to annualise.
#+BEGIN_SRC R -n :exports both
returns(x, t, period = "ann!")
#+END_SRC 

#+RESULTS:

There are methods to =toLatex= and =toHTML=
for monthly returns.  In Sweave documents, you need to use
=<\/<results = tex,echo = false>\/>== in the chunk options:

\noindent\begin{tabular}{rrrrrrrrrrrrrr}
<<results=tex,echo=false>>=
toLatex(returns(x, t = t, period = "month"))
#+END_SRC 
\end{tabular}

** Rebalanced returns

#+BEGIN_SRC R -n :exports both
  X <- array(c(100,105,110,100,100,100), dim = c(3,2))

  w <- c(0.5,0.5)
  budget <- 1
  position <- budget/X[1,]*w

  returns(X %*% position)
  returns(X) %*% w
#+END_SRC 

#+RESULTS:
|              0.025 |
| 0.0238095238095238 |



* Valuation

#+BEGIN_COMMENT

Valuing a position can mean two things: compute theoretical prices, or
market prices.

Theoretical valuation takes places via the generic function value:

=value(x, ..., dots2args = NULL) = 

The simplest case:
=x= is character, then a call will be generated as

=do.call(x, list(...))=

=dots2args.default <- function(x, ...) list(...)=

Note that this will be the =default= method; notably, an
explicit =character= method is left unspecified (meant for the
user).


A more typical case: collect all market data in a list =Data=:
EvaluationDate, Prices, Vols, Irates.

dots2args will react on =x=, retrieve the required information,
and 


\begin{itemize}
\item evaluates to list ="value"=, ="delta"= etc
\item =Instrument[names(result)] <- result=
\end{itemize}


%% #+BEGIN_SRC R -n :exports both
%% Time   <- as.Date("2013-05-28")
%% Prices <- list(DAX = 8472)
%% Irates <- list(EUR = function(t) 0.1)
%% Vols   <- list(DAX = function(x,t) 0.2)

%% DATA <- list(Time = Time, 
%%              Prices = Prices, 
%%              IRates = Irates, 
%%              Vols = Vols)
%% DATA
%% DATA$Vols$DAX(8000, 0.2)
%% DATA$IRates$EUR(0.5)

%% #+END_SRC      


\section{Instruments and portfolios}



\subsubsection{Instrument}

classes: Fund Equity Account Currency Future Index


%% fields:

%% id
%% isin
%% description
%% underlier
%% expirydate
%% expirytime
%% strike
%% type c/p
%% exercise e/a
%% pricing premium/future
%% class

#+END_COMMENT


* Rebalacing a portfolio

\noindent The function =rebalance= computes the transactions
necessary for moving from one portfolio to another.

\section{Usage with unnamed vectors}

The =current= portfolio is given in currency units; the
=target= portfolio is given in weights.  To compute the
required order sizes, we also need the current prices of the assets.
When current, target and price are unnamed, the assets' positions in
the vectors need to match.

#+BEGIN_SRC R -n :exports both
current <- c(0,0,100,100)
prices  <- c(1,1,1,1)
target  <- c(0.25, 0.25, 0.25, 0.25)
rebalance(current, target, prices, match.names = FALSE)
#+END_SRC 

#+RESULTS:

The current portfolio may also be empty, in which case
=current= can be set to 0.  Then, of course, we need to specify
the =notional= of the target portfolio.
#+BEGIN_SRC R -n :exports both
current <- 0
rebalance(current, target, prices, match.names = FALSE, notional = 100)
#+END_SRC

#+RESULTS:

We may also specify the target portfolio as a single number.  
#+BEGIN_SRC R -n :exports both
current <- c(5,5,100,100)

target <- 0    ## liquidate the portfolio
rebalance(current, target, prices, match.names = FALSE)

target <- 0.2  ## every assets gets a weight of 20% 
rebalance(current, target, prices, match.names = FALSE, notional = 100)
#+END_SRC 

#+RESULTS:

\section{Usage with named vectors}

More usefully, =rebalance= can also use the names of the
vectors current etc.  The argument =match.names= must be set to
=TRUE= for this (the default, actually).
#+BEGIN_SRC R -n :exports both
names(prices) <- letters[1:4]
current <- c(b = 10)
target  <- c(d = 0.5)

rebalance(current, target, prices)
#+END_SRC 

#+RESULTS:

To also show all instruments, specify =drop.zero= as
=FALSE=.
#+BEGIN_SRC R -n :exports both
print(rebalance(current, target, prices), drop.zero = FALSE)
#+END_SRC 

#+RESULTS:




* Analysing trades

** Exposure

We have the following trades and times.

#+BEGIN_SRC R -n :exports code :results none
  amount <- c(1,3,-3,1,-3,1)
  time <- c(0,1,3,4,7,12)
#+END_SRC

The holding period (duration) of these trades can be computed
so:
#+BEGIN_SRC R -n :exports both :colnames yes :results output
  data.frame(position = cumsum(amount)[-length(amount)], 
             from = time[-length(time)],
             to   = time[-1L],
             duration = diff(time))

#+END_SRC

#+RESULTS:
:   position from to duration
: 1        1    0  1        1
: 2        4    1  3        2
: 3        1    3  4        1
: 4        2    4  7        3
: 5       -1    7 12        5


We can plot the exposure.

#+BEGIN_SRC R -n :results graphics :file exposure.pdf :width 4 :height 3 :exports both
par(bty = "n", mar = c(4, 4, 0, 0), tck = 0.005, 
    las = 1, cex = 0.8)
plot(c(time[1], time), cumsum(c(0, amount)), 
     type = "s", xlab = "time", ylab = "position")
#+END_SRC

#+RESULTS:
[[file:exposure.pdf]]

#+ATTR_HTML: :width 20% :height 20%
#+BEGIN_HTML
<object data="exposure.pdf" type="application/pdf">Your browser cannot display embedded pdfs. Please follow the link above.</object>
#+END_HTML


Thus, we have had a position from time zero to 12 (hours into the
trading day, say), but its size varied.  The function
=twExposure= (time-weighted exposure) computes the average
absolute exposure.
#+BEGIN_SRC R -n :exports both
twExposure(amount, time)
#+END_SRC

#+RESULTS:
: 1.75

To give a simple example: suppose we bought at the open of a trading
day and sold at noon.  The average exposure for the day is thus half a
contract.

#+BEGIN_SRC R -n :exports both
amount <- c(1, -1 , 0)
time   <- c(0,0.5,1)
twExposure(amount, time)
#+END_SRC

#+RESULTS:
: 0.5

 


** Splitting and rescaling

Suppose we have the following trades and impose a limit that the
maximum absolute exposure for the trader should only be 2.


#+BEGIN_SRC R -n :exports both :results output
t <- 1:6
n <- c(-1,-1,-1,1,1,1)
p <- c(100,99,98,98,99,100)
limit(n, p, t, lim = 2)
#+END_SRC

#+RESULTS:
: $amount
: [1] -1 -1  1  1
: 
: $price
: [1] 100  99  99 100
: 
: $timestamp
: [1] 1 2 5 6


Scaling the trades.

#+BEGIN_SRC R -n :exports both :results output
scaleToUnity(n)
#+END_SRC

#+RESULTS:
: [1] -0.3333333 -0.3333333 -0.3333333  0.3333333  0.3333333  0.3333333

Closing the trade at once.
#+BEGIN_SRC R -n :exports both :results output
closeOnFirst(n)
#+END_SRC

#+RESULTS:
: [1] -1 -1 -1  3  0  0



* Math

\begin{equation}
1+1
\end{equation}



* Plotting irregularly-spaced series during trading hours


We are given these prices of the Bund future contract, traded at the
Eurex in Germany:%
\footnote{Note that I leave the time zone to the operating system.
  Since my computer is typically located in the time zone that the
  =tz database= (\url{http://www.iana.org/time-zones}) 
  calls `Europe/Berlin', the first time should be
  =2012-10-18 20:00:09=.  Suppose your computer was in
  `America/Chicago' and you recompiled this vignette.  Then the first
  time would become =2012-10-18 13:00:09=.  Which is right: it
  is the correct time, only translated into Chicago local time.} %

#+BEGIN_SRC R -n :exports both
prices <- c(139.82, 139.82, 139.8, 139.81, 139.77, 139.85, 
            139.76, 139.76, 139.77, 139.8, 139.86, 140.46, 
            140.39, 140.14, 140.15)

times <- structure(c(1350583209, 1350583271, 1350583319, 
                     1350583289, 1350584209, 1350586249, 
                     1350588199, 1350589299, 1350590399, 
                     1350630970, 1350632971, 1350673969, 
                     1350675751, 1350888315, 1350889533), 
                   class = c("POSIXct", "POSIXt"), tzone = "")
data.frame(times, prices)
#+END_SRC

A =plot= of price against time looks like this.

<<fig=true, width = 5, height = 3.5>>=
plot(times, prices, type = "s")
#+END_SRC

Such a plot is fine for many purposes, but the contract for which we
have prices is only traded from Monday to Friday (not on weekends),
and only from 08:00 to 22:00 Europe/Berlin time.  So the plot should
omit those times at which no trading takes place.  This is what the
function =plotTradingHours= does.

<<fig=true, width = 5, height = 3.5>>=
tmp <- plotTradingHours(x = prices, t = times, 
                        interval = "1 sec", 
                        labels = "day",
                        fromHHMMSS = "080000", 
                        toHHMMSS = "220000",
                        type = "s")
#+END_SRC

What we need for such a plot is a function that maps actual time to a
point on the \mbox{$x$-scale}, while the \mbox{$y$-scale} stays
unchanged.  If we were talking only about days, not times, we needed
something like this: \medskip

\begin{tabular}{rrr}
  \emph{day} & \emph{$x$-position} & \emph{mapped $x$-position} \\
  Thursday   & 1                   & 1                          \\
  Friday     & 2                   & 2                          \\
  Saturday   & 3                   & =<removed>=         \\
  Sunday     & 4                   & =<removed>=         \\
  Monday     & 5                   & 3                          \\
\end{tabular}\medskip

\noindent This mapping is what =plotTradingHours= provides. And not 
much more: the design goal of the function is to make it as much as
possible an ordinary plot; or more specifically, to make it as similar
as possible to the =plot= function. Indeed,
=plotTradingHours= calls =plot= with a small number of
default settings:
<<eval = FALSE>>=
list(type = "l", xaxt = "n", xlab = "", ylab = "")
#+END_SRC 
These settings can all be overridden: =\ldots= arguments are
passed to =plot= (note that we already set =s= as the
plot's =type= in the last code chunk).  The only required
setting is suppressing the \mbox{$x$-axis} with =xaxt = "n"=,
because =plotTradingHours= will create its own $x$-axis via a
call to =axis(1, \ldots)=.  In case you wish to use your own
axis specification, either set =do.plotAxis= to =FALSE=
or pass settings to =axis= through the argument
=axis1.par=.


\section{More examples}

Like =plot=, =plotTradingHours= is typically called for
its side effect: creating a plot.  But it also returns useful
information (invisibly, unless called with =do.plot = FALSE=).

#+BEGIN_SRC R -n :exports both
str(tmp)
#+END_SRC 
This information can be used to add elements to plots.

\subsection{Adding grid lines}

We can add grid lines with =abline=.  The $y$-axis poses no
special problem.  The positions of the $x$-axis ticks are returned
from =plotTradingHours=.

<<fig=true, width = 5, height = 3.5>>=
tmp <- plotTradingHours(x = prices, t = times, 
                        interval = "1 sec", 
                        labels = "day",
                        fromHHMMSS="080000", 
                        toHHMMSS = "220000",
                        type = "s")
abline(h = axTicks(2), v = tmp$axis.pos, 
       col = "lightgrey", lty = "dotted")
#+END_SRC 

If we wan to add to a specific time, say 19 October, 13:10:23, we can
use the function =map= that the call to
=plotTradingHours= returns.  We first create the specific time
with, for example, =ISOdatetime= or =strptime=.

#+BEGIN_SRC R -n :exports both
## Again, I do not specify a time zone since time zones depend on the 
## operating system. To reproduce the example, you may also use this
## representation:
## mytime <- structure(1350645023, 
##                     class = c("POSIXct", "POSIXt"), tzone = "")
##

mytime <- ISOdatetime(2012, 10, 19, 13, 10, 23)
mytime
#+END_SRC 

\noindent Now we use =map= to translate this time into the appropriate
$x$-position.


<<fig=true, width = 5, height = 3.5>>=
tmp <- plotTradingHours(x = prices, t = times, 
                        interval = "1 sec", labels = "day",
                        fromHHMMSS="080000", 
                        toHHMMSS = "220000",
                        type = "s")
abline(h = axTicks(2), v = tmp$axis.pos, 
       col = "lightgrey", lty = "dotted")
abline(v = tmp$map(mytime)$t, col = "red")
#+END_SRC 

\noindent The function =map= returns a list with two components,
=t= and =ix=.
#+BEGIN_SRC R -n :exports both
tmp$map(mytime)
#+END_SRC 
The first component is the appropriate position on the
\mbox{$x$-axis}; since it is a time it is called =t=.  The
second component gives the subscripts to values that should actually
be plotted. Example: suppose that, for whatever reason, we wish to
plot points at several prices at 21:00:00 for several days.

#+BEGIN_SRC R -n :exports both
## moretimes <- structure(c(1350586800, 1350673200, 1350759600), 
##                        class = c("POSIXct", "POSIXt"), tzone = "")
##

moretimes <- ISOdatetime(2012, 10, 18:20, 21, 00, 00)
values <- seq(140, 140.20, length.out = length(moretimes))
data.frame(times = moretimes, 
           weekday = format(moretimes, "%A"), 
           values)
#+END_SRC 
But 20 October 2012 falls on a Saturday, and so it does not appear in the plot. 
#+BEGIN_SRC R -n :exports both
tmp$map(moretimes)
#+END_SRC 
The values that should be plotted can conveniently be found by use
=ix=.
#+BEGIN_SRC R -n :exports both
values[tmp$map(moretimes)$ix]
#+END_SRC



* A graphic

#+BEGIN_SRC R :results graphics :file test.pdf :width 7 :height 6 :exports results
  plot(1:10)
#+END_SRC

#+ATTR_LATEX: :width 4cm :height 2.5cm
#+RESULTS:
[[file:test.pdf]]

#+ATTR_HTML: :width 20% :height 20%
#+BEGIN_HTML
<object data="test.pdf" type="application/pdf">Your browser cannot display embedded pdfs. Please follow the link above.</object>
#+END_HTML


#+BEGIN_LATEX
\nocite{Gilli2011b}
\printbibliography
#+END_LATEX


* Scaling series

\noindent The function =scale1= rescales time-series.  It is a
generic function; currently there are methods for numeric vectors and
for =zoo= objects.

\section{Numeric matrices}

#+BEGIN_SRC R -n :exports both
x <- c(9400.04, 9435.15, 9428, 9506.2, 9497.84, 9421.61, 9473.24, 
       9510.17, 9540.51, 9733.81, 9717.71, 9742.96, 9715.9, 9730.12, 
       9720.11, 9631.04, 9392.02, 9349.22, 9406.91, 9336.73, 9373.48, 
       9306.48)
t <- structure(c(16072, 16073, 16076, 16077, 16078, 
                 16079, 16080, 16083, 16084, 16085, 
                 16086, 16087, 16090, 16091, 16092, 
                 16093, 16094, 16097, 16098, 16099, 
                 16100, 16101), 
               class = "Date")

scale1(x)
#+END_SRC 

With =centre=, the daily mean \emph{return} is subtracted.
#+BEGIN_SRC R -n :exports both
scale1(x, centre = TRUE)
#+END_SRC 

With =scale=, the daily \emph{returns} are rescaled to to that
standard deviation.
#+BEGIN_SRC R -n :exports both
sd(returns(scale1(x, scale = 0.02)))
plot(x, type = "l")
plot(scale1(x, scale = 0.02))
#+END_SRC 

%% \section{Handling NAs}




* FAQ/@@latex:\,@@FRC (Frequently-required computations)

** I need to value a financial instrument

** I have a list of trades (bought or sold what, when and at what price) and I need to compute the profit or loss.

\begin{mdframed}
  If all trades are closed (ie, the current positions are all zero),
  use =pl=.
\end{mdframed}

\begin{mdframed}
  \emph{I have a list of trades in an instrument and want to plot
    these trades against the price of the traded instrument.}
\end{mdframed}

\begin{mdframed}
  \emph{I have a signal series (=+1=, =0=, =0=,
    =+1=, \ldots{}) and need to transform it into a
    profit-and-loss series.}
\end{mdframed}

\begin{mdframed}
  \emph{I have a list of trades and need to determine the
    profit-and-loss between two timestamps.}
\end{mdframed}

Call the two timestamps =t0= and =t1=.  Unless the
position was zero at t0 and t1, we can compute the profit/loss only if
we have prices for the positions at these points in time.  In case the
position was indeed zero, you can use =pl=; the transactions
are stored in a journal =j=.

<<eval=false>>=
subset(j, timestamp >= t0 & timestamp <=t1)
@

But even the more general case is not so complicated, after all.

\begin{enumerate}
\item Compute the position at =t0= and make it a journal j0.

\item Take all transactions at $t > t_\mathrm{0}$ and $t \leq
   t_\mathrm{1}$ and put them into a journal $J$.

\item Compute the position at $t_\mathrm{1}$, and make it a journal
   $J_1$, but \emph{multiply all amounts by $-1$}.

\item Combine $J_0$, $J$, and $J_1$ and compute the PL.
\end{enumerate}

\begin{mdframed}
  \emph{I need to determine the month-to-date profit-and-loss.}
\end{mdframed}

1) compute position on last day of last month

2) make journal from position (add prices)

3) combine with journal since month start

4) use average (=avg=) on all instruments





* Appendix: Output of =sessionInfo()=

#+BEGIN_SRC R :results output :exports results
sessionInfo()
#+END_SRC

#+RESULTS:
#+begin_example
R version 3.2.1 (2015-06-18)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 15.04

locale:
 [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_GB.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_GB.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] portfolioTools_0.0-5 pstplots_0.1-1       NMOF_0.36-2         
 [4] zoo_1.7-12           textutils_0.0-5      org_0.0-2           
 [7] mailtools_0.1-3      datetimeutils_0.0-5  RODBC_1.3-11        
[10] PMwR_0.1-74          database_0.1-37     

loaded via a namespace (and not attached):
[1] lattice_0.20-33 grid_3.2.1      xts_0.9-7       fastmatch_1.0-4
[5] tools_3.2.1     parallel_3.2.1  compiler_3.2.1  base64enc_0.1-2
[9] IBrokers_0.9-12
#+end_example


* Footnotes

[fn:1] This notation is inspired by the syntax of =ledger=
  files. See [[http://www.ledger-cli.org/]] .



