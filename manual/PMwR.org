#+COMMENT: -*- fill-column: 65; -*-
#+TITLE: Portfolio Management with R 
#+AUTHOR: Enrico Schumann
#+DATE: 30 November 2015
#+OPTIONS: toc:nil
#+BIND: org-latex-default-packages-alist nil
#+BIND: org-use-sub-superscripts {}
#+PROPERTY: tangle yes
# ------------------ LATEX ------------------
#+LATEX_CLASS: scrbook
#+LaTeX_CLASS_OPTIONS: [a4paper,fontsize=11pt]
#+LATEX_HEADER: \addtokomafont{disposition}{\rmfamily}
#+LATEX_HEADER: \addtokomafont{descriptionlabel}{\rmfamily}
#+LATEX_HEADER: \setlength{\parindent}{0em}
#+LATEX_HEADER: \setlength{\parskip}{2ex plus0.5ex minus0.5ex}
#+LATEX_HEADER: \newcommand{\pmwr}{\textsc{pm}w\textsc{r}}
#+LATEX_HEADER: \newcommand{\pl}{\textsc{pl}}
#+LATEX_HEADER: \newcommand{\R}{\textsf{R}}
#+LATEX_HEADER: \usepackage[backend=bibtex,citestyle=authoryear]{biblatex}
#+LATEX_HEADER: \addbibresource{Library.bib}
#+LATEX_HEADER: %% \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmainfont{EB Garamond}
#+LATEX_HEADER: \setmonofont[Scale=0.91]{inconsolata}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \lstset{language=R,basicstyle=\ttfamily,frame=single,
#+LATEX_HEADER:         numberstyle=\ttfamily\footnotesize\color{gray}}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \newenvironment{FAQ}
#+LATEX_HEADER:  {\begin{mdframed}}{\end{mdframed}}
#+LATEX_HEADER: \newenvironment{FAA}
#+LATEX_HEADER:  {\begin{mdframed}}{\end{mdframed}}
#+LATEX_HEADER: \usepackage{makeidx}\makeindex
#+LATEX_HEADER: \usepackage{hyperref}
#+PROPERTY: header-args:R :session *R*
# ------------------ HTML ------------------
#+HTML_HEAD: <style>
#+HTML_HEAD:     html,body {
#+HTML_HEAD:       padding: 0;
#+HTML_HEAD:       margin: 0;
#+HTML_HEAD:       line-height: 120%;
#+HTML_HEAD:     }
#+HTML_HEAD:     #content {
#+HTML_HEAD:       font-family: "localEBG", serif;
#+HTML_HEAD:       border: 1px solid #eeeeee;
#+HTML_HEAD:       border-radius: 3px;
#+HTML_HEAD:       color: #222222;
#+HTML_HEAD:       padding-top: 2ex;
#+HTML_HEAD:       padding: 1em;
#+HTML_HEAD:       margin-left: auto;
#+HTML_HEAD:       margin-right: auto;    
#+HTML_HEAD:       width: 700px;
#+HTML_HEAD:     }
#+HTML_HEAD:     @media (max-width: 700px) {
#+HTML_HEAD:         html,body {
#+HTML_HEAD:             width: 92%;
#+HTML_HEAD:         }
#+HTML_HEAD:     }
#+HTML_HEAD:     .example {
#+HTML_HEAD:         border: 1px solid rgb(200,200,200);
#+HTML_HEAD:         padding: 4px;
#+HTML_HEAD:      }
#+HTML_HEAD:     .src {
#+HTML_HEAD:         border: 1px solid rgb(120,120,120);
#+HTML_HEAD:         color: rgb(60,60,60);
#+HTML_HEAD:         padding: 4px;
#+HTML_HEAD:      }
#+HTML_HEAD:     .src:hover {
#+HTML_HEAD:         background-color: rgb(240,240,240);
#+HTML_HEAD:         padding: 4px;
#+HTML_HEAD:      }
#+HTML_HEAD:     dt {
#+HTML_HEAD:       font-weight: bold;
#+HTML_HEAD:     }
#+HTML_HEAD:     li {
#+HTML_HEAD:       margin-bottom: 0.5ex;
#+HTML_HEAD:     }
#+HTML_HEAD:     code {
#+HTML_HEAD:       font-size: 115%;
#+HTML_HEAD:     }
#+HTML_HEAD:     .org-right {
#+HTML_HEAD:       text-align: right;
#+HTML_HEAD:     }
#+HTML_HEAD: </style>
#+BEGIN_HTML
<p>
    <a href = "http://enricoschumann.net">Enrico Schumann</a>&nbsp;&nbsp;&nbsp;
    <time datetime="2015-11-30">30 November 2015</time>&nbsp;&nbsp;&nbsp;
    <a href = "PMwR.pdf">[PDF]</a>
</p>
#+END_HTML

#+TOC: headlines 2 

#+BEGIN_SRC R :exports none :results none
  options(continue = " ", digits = 3, width = 60, useFancyQuotes = FALSE)
  require("PMwR")
  require("zoo")
#+END_SRC

* About PMwR
  
  This manual describes how to use the PMwR package. The package
  grew out of various pieces of software that I have written
  since 2008 or so, first at the University of Geneva, later
  during my work at financial firms.

  The package is currently under development and changes
  frequently. This is mainly because the code has been written
  over many years and is in need of being groomed for general use.

  Consequently, this manual is only a draft, and it will change
  as frequently as the package. I am grateful for comments and
  suggestions.

  The latest version of the package is available from
  [[http://enricoschumann.net/R/packages/PMwR/index.htm]].  To
  install the package from within R, type

#+BEGIN_SRC R :eval never :results silent :export code
install.packages("PMwR", 
                 repos = "http://enricoschumann.net/R", 
                 type  = "source")
#+END_SRC

to download and install it. The package depends on several other
packages, which can be obtained from the same repository.

(There is currently no automatic build for Windows. If you wish
to use the package on Windows and have problems building it, then
please contact me and I will provide you with a Windows version.)


* Using R in portfolio management -- Two examples                  :noexport:
  :PROPERTIES:
  :CUSTOM_ID: ch:intro
  :END:

** Preparing monthly-returns tables


** Computing the running maximum of a time-series

Idea, algorithm, implementation.


* An Overview of the PMwR Package                                  :noexport:

** The goals of writing the package

- Store a portfolio of assets and compute the value --
  or other quantities such as Greeks -- for different
  data. Data may be market data, but also theoretical
  data (prices).

- Reevaluate a portfolio for specific scenarios (i.e.,
  new market or artificial data).

- Read in transactions from various sources. That is
  done via a journal class.

- Show portfolio on certain day/time: create a /position/, evaluate
  this position --> position class

- testing portfolios of options --> show payoff, simulate *paths* of
  underlier and vol surface

- run simulations for VaR

- various ways to compute pnl: weighted average, first-in-first-out
  and last-in-last-out


** Classes and Data structures

The following classes are implicitly defined (ie, S3 classes):

- journal :: keeps transactions. Internally, a object of class
     =journal= is named list of atomic vectors.

- position :: the numerical positions of different
     accounts/instruments at specific points in time. Always stored in
     a numeric matrix with attributes timestamp and instrument; points
     in time are in rows, instruments in columns.

- period returns :: numeric vector (potentially a matrix) with
     attributes timestamp and period. The class is called =p_returns=

- instrument :: term sheet (description etc); it does know notyhing
     about market data -- not yet implemented

- cashflow :: internal -- not yet implemented

- NAVseries :: store a time-series of net asset values

- pricetable :: a matrix of NAVs (or prices); each column corresponds
     to one asset. Additional attributes instrument and
     timestamp. Often, pricetables will be created corresponding to
     positions.




** Notes for developers

*** Methods for =returns=

    Methods are responsible for `stripping' the input down do =x= and
    =t=, calling `=returns.default=' or some other method, and then to
    re-assemble the original class's structure. When =period= is not
    specified, methods should keep timestamp information for
    themselves and not pass it on. (That is, =returns.default= should
    only ever receive a =timestamp= when =period= is specified.)

*** Vectorisation

    Functions should do vectorisation when it is beneficial in terms
    of speed or clarity of code. An example should clarify this:
    =drawdown= is internally computed through =cumsum=, so even for a
    matrix of time series, it would need a loop. Such looping should
    be left to the user. However, vectorisation should be used when it
    makes computations faster.

*** Named vectors

    In many instances, vectors that store scalar information of
    instruments (such as price or multiplier) should be named by
    instrument.

*** Functional programming

    Do not rely on global options/settings. Exception are interative
    functions, which essentially means =print= methods.







* Keeping track of transactions: journals
  :PROPERTIES:
  :CUSTOM_ID: ch:journals
  :END:

#+INDEX: journal!definition

  Many computations that the PMwR package provides are based on
  lists of transactions. Conceptually, you can think of such
  lists as dataframes, but PMwR provides an =S3= class =journal=
  for handling them.

  A =journal= is a list of atomic vectors with a class
  attribute. Such a list is created through the function
  =journal=. Methods should not rely on this list being sorted in
  any particular way: components of a journal should always be
  retrieved by name, never by position. (In this respect a
  journal differs from a dataframe, where we can meaningfully
  refer to the /n/-th column.)
  #+INDEX: journal!comparison with dataframe
  I will call to these journal components, such as =amount= or
  =timestamp=, fields.
  
  The simplicity of the class is intended, because it is meant
  for interactive analyses. The user may -- and is expected to --
  dissect the information in a =journal= at will; such
  dissections include removing the class attribute.

  What is actually stored in a =journal= is up to the user. A
  number of fields are, however, required for certain operations
  and should always be present:

- =amount= :: the notional amount that is transacted

- =timestamp= :: numeric or character vector; should typically be
     sortable

- =price= :: well, price

- =instrument= :: description of the financial instrument; typically
     rather an identifier (a.k.a. ticker or symbol)

- =id= :: (possibly unique) id

- =account= :: description of the account

- =...= :: other fields. They must be named, as in =fees = c(1,2,1)=

All fields can be completely missing, except =amount=. Missing fields
will be 'added back' as =NA= with the exception of =id= and =account=,
which will be =NULL=. (Note that =amount= could be a vector with only
=NA= values in it; but =amount= cannot be left out when the journal is
created. This will become clearer with the examples below.)

Transactions in a journal can be organised in hierachies, such as
#+BEGIN_EXAMPLE
<account> => <instrument>
#+END_EXAMPLE
even though currently no functions use this hierarchy. A simple scheme
is to use specific characters or a pattern such as =::= to introduce
hierarchies into accounts,[fn:1] such as
#+BEGIN_EXAMPLE
pension::equities
#+END_EXAMPLE


** Creating journals and combining

The function =journal= creates journal objects. For details about
the function and methods for =journal= objects, see =?journal=.
@@latex:\index{journal@\texttt{journal} (function)}@@


At is very minimum, a journal must contain amounts of something.
#+BEGIN_SRC R -n :exports both :results output
  amount <- c(+1, +2, -2, +3)
  jnl <- journal(amount = amount)
  jnl
#+END_SRC

#+RESULTS:
:  
:   amount
: 1       1
: 2       2
: 3      -2
: 4       3
: 
: 4 transactions

Actually, that is not true. On occasion it is useful to create an empty
journal, one with no entries at all. You can do this by saying
#+BEGIN_SRC R -n :exports both :results output
journal()
#+END_SRC

#+RESULTS:
: no transactions

To see the current balance, which is nothing more than the sum
over all amounts, we can use =position=.
#+BEGIN_SRC R -n :exports both :results output
  position(jnl)
#+END_SRC

#+RESULTS:
:      [,1]
: [1,]    4

Only providing amounts is, admittedly, not overly useful. You can keep
track of positions, true. But a [[https://en.wikipedia.org/wiki/General_journal][journal]] implies chronological
information, that is, flows. (As opposed to a [[https://en.wikipedia.org/wiki/Ledger][ledger]], which gives you
positions, or stocks.)

When the amounts are actually sorted in time -- though nothing in the
data structure that we created above could make sure they are --, then
we can at least track positions over time.

Suppose you wanted to note how many bottles of milk and wine you have
stored in your basement. Whenever you add to your storage, you have a
positive amount; whenever you retrieve bottles, you have a negative
amount.

#+name: tab_wine
| what | amount |
|------+--------|
| wine |     +1 |
| wine |     +4 |
| milk |     +1 |
| wine |     -2 |
| milk |     -1 |
| milk |     +1 |
| milk |     -1 |
| milk |     +1 |
| wine |     -1 |

#+BEGIN_SRC R :var jnl=tab_wine :results code :exports none
  ##jnl <- as.journal(jnl)
  jnl <- as.journal(jnl)
  capture.output(dput(jnl))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC R
structure(list(instrument = c(NA_character_, NA_character_, NA_character_, 
NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
NA_character_), timestamp = c(NA, NA, NA, NA, NA, NA, NA, NA, 
NA), amount = c(1L, 4L, 1L, -2L, -1L, 1L, -1L, 1L, -1L), price = c(NA, 
NA, NA, NA, NA, NA, NA, NA, NA), what = c("wine", "wine", "milk", 
"wine", "milk", "milk", "milk", "milk", "wine")), .Names = c("instrument", 
"timestamp", "amount", "price", "what"), class = "journal")
#+END_SRC


The journal would look like this.

#+BEGIN_SRC R :results output :exports both :colnames yes
jnl
#+END_SRC

#+RESULTS:
#+begin_example
   amount  what
1       1  wine
2       4  wine
3       1  milk
4      -2  wine
5      -1  milk
6       1  milk
7      -1  milk
8       1  milk
9      -1  wine

9 transactions
#+end_example

You could check your drinking habits for patterns, say. But
perhaps we better switch to a financial example.


#+BEGIN_SRC R -n :exports both :results output
  (J <- journal(timestamp  = as.Date("2012-01-01") + 0:3, 
                amount     = c(1, 2, -2, 5),
                instrument = c("EUR", "EUR", "CHF", "CHF")))
#+END_SRC

#+RESULTS:
:      instrument   timestamp  amount
: 1         EUR  2012-01-01       1
: 2         EUR  2012-01-02       2
: 3         CHF  2012-01-03      -2
: 4         CHF  2012-01-04       5
: 
: 4 transactions

A =print= method defines how to display a journal.
#+INDEX: journal!print journals (print method)
#+BEGIN_SRC R -n :exports both :results output
print(J, max.print = 2, exclude = "instrument")
#+END_SRC

#+RESULTS:
:     timestamp  amount
: 1  2012-01-01       1
: 2  2012-01-02       2
: [ .... ]
: 
: 4 transactions

Journals can be combined with =c=.
#+INDEX: journal!concatenating journals
#+INDEX: journal!combining journals
#+BEGIN_SRC R -n :exports both :results output
J2 <- J
J2$fees <- rep(1,4)
c(J, J2)
#+END_SRC

#+RESULTS:
#+begin_example
 
  instrument   timestamp  amount  fees
1         EUR  2012-01-01       1    NA
2         EUR  2012-01-02       2    NA
3         CHF  2012-01-03      -2    NA
4         CHF  2012-01-04       5    NA
5         EUR  2012-01-01       1     1
6         EUR  2012-01-02       2     1
7         CHF  2012-01-03      -2     1
8         CHF  2012-01-04       5     1

8 transactions
#+end_example


** Selecting transactions

In an interactive session, you can use =subset= to select particular
transactions.
#+INDEX: journal!subsetting
#+BEGIN_SRC R -n :exports both :results output
subset(J, amount > 1) 
#+END_SRC

#+RESULTS:
:    instrument   timestamp  amount
: 1         EUR  2012-01-02       2
: 2         CHF  2012-01-04       5
: 
: 2 transactions

With =subset=, you need not quote the expression that selects
trades and you can directly access a journal's fields. Because of
the way =subset= evaluates its arguments, it should not be used
within functions. (See the Examples section in =?journal= for
what can happen then.)

More generally, to extract or change a field, use its name, either
through the =$= operator or double brackets =[[...]]=.
#+BEGIN_SRC R -n :exports both :results output
J$amount
#+END_SRC 

#+RESULTS:
: [1]  1  2 -2  5

You can also replace specific fields.
#+BEGIN_SRC R -n :exports both :results output
J[["amount"]] <- c(1 ,2, -2, 8)
J
#+END_SRC 

#+RESULTS:
:    instrument   timestamp  amount
: 1         EUR  2012-01-01       1
: 2         EUR  2012-01-02       2
: 3         CHF  2012-01-03      -2
: 4         CHF  2012-01-04       8
: 
: 4 transactions

The =`[`= method works with integers or logicals, returning
the respective transactions.
#+BEGIN_SRC R -n :exports both :results output
J[2:3]
#+END_SRC 

#+RESULTS:
:    instrument   timestamp  amount
: 1         EUR  2012-01-02       2
: 2         CHF  2012-01-03      -2
: 
: 2 transactions

#+BEGIN_SRC R -n :exports both :results output
J[J$amount < 0]
#+END_SRC 

#+RESULTS:
:    instrument   timestamp  amount
: 1         CHF  2012-01-03      -2
: 
: 1 transaction


You can also pass a string, which is then interpreted as a regular
expression that is matched against all character fields in the
journal.
#+BEGIN_SRC R -n :exports both :results output
J["eur"]
#+END_SRC 

#+RESULTS:
:    instrument   timestamp  amount
: 1         EUR  2012-01-01       1
: 2         EUR  2012-01-02       2
: 
: 2 transactions

By default, case is ignored, but you can set =ignore.case= to
=FALSE=.  You can also specify the fields to match the string
against.
#+BEGIN_SRC R -n :exports both :results output
J["eur", ignore.case = FALSE]
#+END_SRC 

#+RESULTS:
: no transactions

#+BEGIN_SRC R -n :exports both :results output
J["eur", ignore.case = TRUE]
#+END_SRC 

#+RESULTS:
:    instrument   timestamp  amount
: 1         EUR  2012-01-01       1
: 2         EUR  2012-01-02       2
: 
: 2 transactions

#+BEGIN_SRC R -n :exports both :results output
J$comment <- c("", "", "EUR", "EUR")
J["eur", match.against = "comment"]
#+END_SRC 

#+RESULTS:
:    instrument   timestamp  amount  comment
: 1         CHF  2012-01-03      -2      EUR
: 2         CHF  2012-01-04       8      EUR
: 
: 2 transactions


** Computing balances

As already mentioned, the function =position= gives the current
balance of all instruments.
@@latex:\index{position@\texttt{position} (function)}@@


#+BEGIN_SRC R -n :exports both :results output
position(J)
#+END_SRC

#+RESULTS:
:     2012-01-04
: CHF          6
: EUR          3

To get the position at a specific date, use the =when= argument.
#+BEGIN_SRC R -n :exports both :results output
position(J, when = as.Date("2012-01-03"))
#+END_SRC

#+RESULTS:
:     2012-01-03
: CHF         -2
: EUR          3

If you don't like that view, consider splitting the journal.
#+INDEX: journal!splitting
#+BEGIN_SRC R -n :exports both :results output
lapply(split(J, J$instrument), 
       position, when = as.Date("2012-01-03"))
#+END_SRC 

#+RESULTS:
:  $CHF
:     2012-01-03
: CHF         -2
: 
: $EUR
:     2012-01-03
: EUR          3


To get a time series of positions, you can use specific keywords for
=when=: =all= will print the position at all timestamps in the
journal.
#+BEGIN_SRC R -n :exports both :results output
position(J, when = "all")
#+END_SRC

#+RESULTS:
:            CHF EUR
: 2012-01-01   0   1
: 2012-01-02   0   3
: 2012-01-03  -2   3
: 2012-01-04   6   3

We are not limited to the timestamps that exist in the journal.
#+BEGIN_SRC R -n :exports both :results output
position(J, when = seq(from = as.Date("2011-12-30"), 
                         to = as.Date("2012-01-06"),
                         by = "1 day"))
#+END_SRC 

#+RESULTS:
:              CHF EUR
: 2011-12-30   0   0
: 2011-12-31   0   0
: 2012-01-01   0   1
: 2012-01-02   0   3
: 2012-01-03  -2   3
: 2012-01-04   6   3
: 2012-01-05   6   3
: 2012-01-06   6   3



#+BEGIN_SRC sh :results output :exports none
  notify-send "Chapter 1" "Finished"
#+END_SRC

#+RESULTS:


** Appendix: Tutorials                                             :noexport:

*** Double-entry accounting

    Double-entry account builds on the identity 
#+BEGIN_EXAMPLE
assets + expenses = liabilities + income + equity
#+END_EXAMPLE

    The left-hand side states what you did with your capital; the
    right-hand side tells you where it came from.



* Computing profit and (or) loss
  :PROPERTIES:
  :CUSTOM_ID: ch:pl
  :END:

** Simple cases

We have an account, currency is euro. We buy one asset at a price
of 100 euro and sell it again at 102 euro. We have made a profit
of 2 euros. This simple case is frequent enough to make the
required computation simple as well. Computing profit-or-loss
(P/L) can be handled through the function =pl=.
#+BEGIN_SRC R -n :exports both :results output
  pl(price  = c(100, 102), 
     amount = c(  1,  -1))
#+END_SRC 

#+RESULTS:
:  PnL total    2
: average buy  100
: average sell 102
: volume       2
: 
: 'total PnL' is in units of instrument;
: 'volume' is total /absolute/ amount of traded instruments.

Suppose that a trader bought one unit at 50, one unit at 90 and sold
two units at 100, resulting in a profit of 60. 
#+BEGIN_SRC R -n :exports both :results output
jnl <- journal(price  = c( 90, 50, 100), 
               amount = c(  1,  1,  -2))
pl(jnl)
#+END_SRC 

#+RESULTS:
:  PnL total    60
: average buy  70
: average sell 100
: volume       4
: 
: 'total PnL' is in units of instrument;
: 'volume' is total /absolute/ amount of traded instruments.


But suppose that the actual order of the trades was

#+BEGIN_EXAMPLE
buy at 90  =>  buy at 50  =>  sell at 100.
#+END_EXAMPLE

You may have noticed that the =journal= that we created above
already has the trades ordered this way. We may know nothing
about what was traded and when, but there is clearly some
information by the order of the trades and the drawdown that it
implies: the position had a drawdown of at least 40 before it
recovered. For situations like this, the argument
=along.timestamp= can be used. (Note that we do not provide an
actual timestamp, in which case the function will implicitly use
integers 1, 2, ..., =length(amount)= .)
#+BEGIN_SRC R -n :exports both :results output
pl(jnl, along.timestamp = TRUE)
#+END_SRC 

#+RESULTS:
: PnL total    0 -40 60
:     realised   0 0 60
:     unrealised 0 -40 0
: average buy  70
: average sell 100
: volume       1 2 4
: 
: 'total PnL' is in units of instrument;
: 'volume' is total /absolute/ amount of traded instruments.

With no further arguments, the function will compute the running
position and evaluate it at every trade with the trade's
price. This may not be accurate because of bid--ask spreads or
other transaction costs. But it provides more information than
only computing the P/L for the trades.

We can also use =pl= for a journal in which some positions not
closed yet.  The simplest example is a journal of just one trade.
#+BEGIN_SRC R -n :exports both :results output
  pl(jnl <- journal(amount = 1, price = 100))  
#+END_SRC

#+RESULTS:
#+begin_example
PnL total    NA
average buy  100
average sell .
volume       1

'total PnL' is in units of instrument;
'volume' is total /absolute/ amount of traded instruments.
Warning message:
In pl.default(amount, price, timestamp, instrument, multiplier = multiplier,  :
  'sum(amount)' is not zero; specify 'eval.price' to compute p/l.
#+end_example

To close the trade, only for the purpose of computing P/L,
specify =eval.price=.
#+BEGIN_SRC R -n :exports both :results output
  pl(jnl <- journal(amount = 1, price = 100), eval.price = 101)  
#+END_SRC

#+RESULTS:
: PnL total    1
: average buy  100
: average sell 101
: volume       1
: 
: 'total PnL' is in units of instrument;
: 'volume' is total /absolute/ amount of traded instruments.

Note that /average buy/ and /average sell/ reflect the specified
evaluation price; but /volume/ does not since nothing is actually
traded.



** More complicated cases

   Unfortunately, in real life computing P/L is often more
   complicated:

- One asset-price unit may not translate into one currency unit:
  we have multipliers or contract factors. That is easy to solve
  by computing effective position sizes, but it may take some
  thinking to come up with a reusable scheme (e.g., looking up
  multipliers in a table).
    
- Asset positions may map into cashflows in non-obvious ways. The
  simple case is the delay in actual payment and delivery of an
  asset, which is often two or three days. The more problematic
  cases are derivatives with daily adjustments of margins. In
  such cases, one may need to model (i.e. keep track of) the
  actual account balances.

- Assets may be denominated in various currencies.
  
- Currencies themselves may be assets in the portfolio.
  Depending on how they are traded (cash, forwards, /&c./),
  computing P/L may not be straightforward.

How -- or rather, to what degree -- these troubles are handled
is, as always, up to the user. For a single instrument, computing
P/L in units of the instrument is always meaningful, though
perhaps not always intuitive.  But /adding up/ the profits and
losses of several assets often will often not work because of
multipliers or different currencies. A simple and transparent way
is then to manipulate the journal before P/L is computed (e.g.,
multiply notionals by their multipliers).

## We look at two examples: (i)\nbsp{}computing the /pl/ of
## several assets in currency units; and (ii)\nbsp{}computing
## time-weighted returns of a portfolio of assets.

*** An example: P/L for lists of incomes and expenses

Suppose you keep a journal just to keep track of your personal
income and expenses. An aside: it's tedious to enter journals by
hand, in particular if we want to update them over time.  So, for
practical use, we may write transactions into files, like this:

#+BEGIN_EXAMPLE
|  timestamp | amount | comment          |
|------------+--------+------------------|
| 2012-01-01 |    100 | a comment        |
| 2012-01-02 |    200 | another comment  |
| 2012-01-03 |   -200 | bought something |
| 2012-02-04 |    500 | got a present    |
#+END_EXAMPLE

In case you use [[http://orgmode.org/][Org-mode]], such tables should look familiar.  The
org package http://enricoschumann.net/R/packages/org/index.htm
provides a function =readOrg= to read such tables.

Some of these transactions may mean a gain or loss to us, such as
a dividend payment. Others are neutral, for example a transfer
between bank accounts. There are several ways to deal with
this.[fn:2]

One way to deal with that is to switch to double-entry accounting. A
second way is to add descriptions like =expense= and then subset by
these descriptions.

And yet another approach is to use prices. Whenever we evaluate
the balances of a cash account, we say that the price per unit is
one. That is actually reasonable: if my account has a balance of
120.2, it actually means `120.2 euros'. The price of one euro --
no surprise here -- is one euro.

An expense should be a negative amount; income should go with
positive amounts.  When we add such an entry that is supposed to
mean gain or loss to us, we make its price 0. Then, when we
compute that value of a position, we make its price 1.  An
example:

#+BEGIN_SRC R -n :exports both :results output
J <- journal(timestamp = c("day 1", "day 2", "day 3"), 
               amount    = c(100,100,-200), 
               price     = c(  1,  0,   0),
               comment   = c("neutral", "income", "expense"),
               account   = "my account")
J
#+END_SRC

#+RESULTS:
:    timestamp  amount  price     account  comment
: 1      day 1     100      1  my account  neutral
: 2      day 2     100      0  my account   income
: 3      day 3    -200      0  my account  expense
: 
: 3 transactions

The current balance is 0.
#+BEGIN_SRC R -n :exports both :results output
position(J)
#+END_SRC 

#+RESULTS:
:      day 3
: [1,]     0

In terms of income and expenses we have made a loss of\nbsp{}100, which is
exactly what the function =pl= reports.  (There will be more examples
for using this function in [[#ch:pl][Computing profit and (or) loss]].)
#+BEGIN_SRC R -n :exports both :results output
pl(J, current.price = 1)
#+END_SRC 

#+RESULTS:
: PnL total    -100
: average buy  0.5
: average sell 0
: volume       400
: 
: 'total PnL' is in units of instrument;
: 'volume' is total /absolute/ amount of traded instruments.



** Comment                                                         :noexport:

Suppose we also have a time series of the prices between times 1
and 10. We can evaluate the position at every time instant, and
then plot position, /pl/ and the price of the traded instrument.

#+BEGIN_SRC R -n :exports both :results output
## [TODO]
price <- c(100,90,70,50,60,80,100,90,110,105)

## position
position(J, when = 1:10)

## pl
## value position at when = 1:10
## compute value if journal at 1:10 => subtract

#+END_SRC 

#+RESULTS:
#+begin_example
 
  [,1]
1     0
2     0
3     0
4     0
5     0
6     0
7     0
8     0
9     0
10    0
#+end_example

A more-useful example for =pl= with =along.timestamp= is a trading
history of a high-frequency strategy.  Suppose for example we had
traded EURUSD 200 times in single day and wished to plot the result.
At such a frequency, the prices at which the trades were executed is
useful to value any open position.

#+BEGIN_SRC R -n :exports both
## [TODO]
#+END_SRC 

#+RESULTS:

We may also want to compute the /pl/ between two points in
time. If our only data source is a journal, this may be impossible
since we need to evaluate the position at both points in time.  A simple
example follows; the data first.
#+BEGIN_SRC R -n :exports both :results output
timestamp <- 1:20
amount <- c(-5, 5, 5, -5, -5, 5, 5, 5, 5, 
            -5, 5, 5, -5, 5, 5, -5, -5, -5, 
            -5, -5)
price <- c(106, 101, 110, 110, 105, 105, 105, 104, 110, 104, 
           103, 108, 106, 102, 108, 107, 103, 104, 109, 104)
(J <- journal(timestamp = timestamp, amount = amount, price = price))
#+END_SRC 

#+RESULTS:
#+begin_example
    timestamp  amount  price
1           1      -5    106
2           2       5    101
3           3       5    110
4           4      -5    110
5           5      -5    105
6           6       5    105
7           7       5    105
8           8       5    104
9           9       5    110
10         10      -5    104
11         11       5    103
12         12       5    108
13         13      -5    106
14         14       5    102
15         15       5    108
16         16      -5    107
17         17      -5    103
18         18      -5    104
19         19      -5    109
20         20      -5    104

20 transactions
#+end_example

Suppose we want the P/L between times 5
and\nbsp{}8. Conceptually, it is simple: we first compute the
position at\nbsp{}5 and treat it as a trade.  Clearly, for this
we need the price of the instruments in the position at
timestamp\nbsp{}5.  Then we extract all the trades that occured
later than 5, up to 8.  The final position, again, would be
treated as a trade, but with signs reversed. That, we close the
position, if any exists.  Here, again, we need the prices of the
instruments.

The function =pl= does (most of) these tasks for us.
#+BEGIN_SRC R -n :exports both :results output
from <- 5
to   <- 8
price.from <- 106
price.to   <- 105
position.from <- position(J, when = from)
trades <- J[J$timestamp > from & J$timestamp <= to]

pl(trades, 
   initial.position = position.from, 
   initial.price = price.from,
   current.price = price.to)   
#+END_SRC 

#+RESULTS:
#+begin_example
 
  PnL total    NA
average buy  105
average sell .
volume       15

'total PnL' is in units of instrument;
'volume' is total /absolute/ amount of traded instruments.
Warning message:
In pl.default(amount, price, timestamp, instrument, multiplier = multiplier,  :
  'sum(amount)' is not zero; specify 'eval.price' to compute p/l.
#+end_example



## \section{More  complicated cases}


##%% TODO:

##%% - example EUR investor buys INTC

## %% - pure FX portfolio


** Several assets                                                  :noexport:

In this example we compute the /pl/ in currency units of a portfolio
over time.  We start with the following journal.

#+BEGIN_SRC R R -n :exports both :results output
## dput(ISOdatetime(2013,c(11,11,12,12,11,12), c(28,28,2,3,27,2), 
##                     c(9,12,13,9,9,13),c(35,50,21,57,52,54),0))
timestamp <- structure(c(1385627700, 1385639400, 1385986860, 1386061020, 1385542320, 
                         1385988840), class = c("POSIXct", "POSIXt"), tzone = "")

(J <- journal(amount    = c(100,100,-50,-150, 100,-50),
             timestamp = timestamp,
             price = c(11.6, 11.62, 11.67, 11.47, 25.1,26.29),
             instrument = c(rep("DTE", 4), rep("DPW", 2))))
#+END_SRC 

#+RESULTS:
:       instrument            timestamp  amount  price
: 1         DTE  2013-11-28 09:35:00     100   11.6
: 2         DTE  2013-11-28 12:50:00     100   11.6
: 3         DTE  2013-12-02 13:21:00     -50   11.7
: 4         DTE  2013-12-03 09:57:00    -150   11.5
: 5         DPW  2013-11-27 09:52:00     100   25.1
: 6         DPW  2013-12-02 13:54:00     -50   26.3
: 
: 6 transactions

We shall compute end-of-day /pl/ of these trades.  In case you
wondered: \textsc{dte} stands for Deutsche Telekom and \textsc{dpw} is
Deutsche Post, both traded on \textsc{xetra}. End-of-day is 17:30 in
Frankfurt am Main, Germany.

(There is nothing special about end-of-day.  We could just as well
have decided to have hourly prices, say.  But I would like to keep
this example small.)  The prices at these timestamps are stored in a
matrix =price.table=.
#+BEGIN_SRC R -n :exports both :results output
  price.table <- structure(c(25.71, 25.965, 26.03, 26.32, 25.305,
                             11.65, 11.655, 11.685, 11.62, 11.375), 
                           .Dim = c(5L, 2L), 
                           .Dimnames = list(NULL, c("DPW", "DTE")))

  ## times <- as.POSIXct(c("2013-11-27 17:30:00", "2013-11-28 17:30:00", "2013-11-29 17:30:00", 
  ##                       "2013-12-02 17:30:00", "2013-12-03 17:30:00"))
  when <- times <- structure(c(1385569800, 1385656200, 1385742600, 
                       1386001800, 1386088200), 
                     class = c("POSIXct", "POSIXt"), 
                     tzone = "")
  rownames(price.table) <- as.character(times)
#+END_SRC 

#+RESULTS:

#+BEGIN_SRC R -n :exports both :results output
price.table
#+END_SRC 

#+RESULTS:
:                      DPW  DTE
: 2013-11-27 17:30:00 25.7 11.7
: 2013-11-28 17:30:00 26.0 11.7
: 2013-11-29 17:30:00 26.0 11.7
: 2013-12-02 17:30:00 26.3 11.6
: 2013-12-03 17:30:00 25.3 11.4


*** Step 1: compute value of portfolio

We first need the position sizes at the timestamps at which we want to
compute pl.  We store them in a vector =when=.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
when
#+END_SRC 

#+RESULTS:
: [1] "2013-11-27 17:30:00 CET" "2013-11-28 17:30:00 CET"
: [3] "2013-11-29 17:30:00 CET" "2013-12-02 17:30:00 CET"
: [5] "2013-12-03 17:30:00 CET"



The position at =when= is quickly computed.
#+BEGIN_SRC R -n :exports both :results output
(pos <- position(J, when = when))
#+END_SRC 

#+RESULTS:
:                     DPW DTE
: 2013-11-27 17:30:00 100   0
: 2013-11-28 17:30:00 100 200
: 2013-11-29 17:30:00 100 200
: 2013-12-02 17:30:00  50 150
: 2013-12-03 17:30:00  50   0

Note that each element in the position matrix corresponds to an
element in the matrix =price.table=.  That is, the rows correspond to
the timestamps of the position (which is equal to =when=).
#+BEGIN_SRC R -n :exports both :results output
attr(pos, "timestamp")
#+END_SRC 

#+RESULTS:
: [1] "2013-11-27 17:30:00 CET" "2013-11-28 17:30:00 CET"
: [3] "2013-11-29 17:30:00 CET" "2013-12-02 17:30:00 CET"
: [5] "2013-12-03 17:30:00 CET"

The columns must be ordered like the instruments:
#+BEGIN_SRC R -n :exports both :results output
attr(pos, "instrument")
#+END_SRC 

#+RESULTS:
: [1] "DPW" "DTE"

Thus, we need to multiply both matrices element-by-element, which is
exactly what the function =valuation= does.  A warning: the
function does currently not at all check =price.table=.
#+BEGIN_SRC R :eval never
PMwR:::valuation(pos, price.table = price.table)
#+END_SRC 
We care about the row sums of the results.
#+BEGIN_SRC R :eval never
(v <- PMwR:::valuation(pos, price.table = price.table, do.sum = TRUE))
#+END_SRC
If the assets have specific multipliers, we can pass them as a named
vector.  (That is the preferred way, at least.  An unnamed vector will
do as well, as will a single number, which is recycled.)
#+BEGIN_SRC R :eval never 
PMwR:::valuation(pos, price.table = price.table, 
          multiplier = c(DTE = 5, DPW = 0.5))
#+END_SRC

*** Step 2: compute cashflows that led to portfolio

We create a vector =cf= that will store the cashflows.
#+BEGIN_SRC R -n :exports both :results output
cf <- numeric(length(attr(pos, "timestamp")))
names(cf) <- as.character(attr(pos, "timestamp"))
cf
#+END_SRC 

#+RESULTS:
: 2013-11-27 17:30:00 2013-11-28 17:30:00 2013-11-29 17:30:00 
:                   0                   0                   0 
: 2013-12-02 17:30:00 2013-12-03 17:30:00 
:                   0                   0


#+BEGIN_SRC R -n :exports both
## tmp <- PMwR:::valuation(J)
## tmp$timestamp <- pos$timestamp[PMwR:::matchOrNext(tmp$timestamp, pos$timestamp)]
## cash <- aggregate(tmp$amount, list(tmp$timestamp), sum)
## cf[match(cash[[1]], pos$timestamp)] <- cash[[2]]
## (v.net <- v + cumsum(cf))
#+END_SRC 

#+RESULTS:

## TODO: check -- create interface journal/when/price.table?

*** Summary

- Fix =when=; compute position at =when=.
- Prepare a matrix price.table of =length(when)= rows, whose columns
  correspond to the assets in the portfolio.
- Call =valuation(position)= and store the result as =v=.
- Call =valuation(journal)=; map the timestamps of the new journal to
  =when=; sum the cashflows by timestamp; subtract the resulting
  cashflows from =v=.

(To compute returns, choose a suitable total portfolio value and divide
by it.)


#+BEGIN_SRC sh :results output :exports none
  notify-send "Chapter PL" "Finished"
#+END_SRC

#+RESULTS:


* Computing returns
  :PROPERTIES:
  :CUSTOM_ID: ch:returns
  :END:

The function =returns= computes returns for various types of
objects. The return of an asset in period /t/ is defined as
\begin{equation} \label{eq:return}
  r_t = \frac{P_t}{P_{t-1}}-1 = R_t-1\,,
\end{equation}
so we always compute simple returns. For computing profit/loss in
currency units, see [[#ch:pl][Computing profit and (or) loss]].



** Numeric vectors and matrices, data frames

#+BEGIN_SRC R -n :exports both :results output
x <- c(100, 102, 101, 100)
returns(x)
#+END_SRC 

#+RESULTS:
: [1]  0.0200 -0.0098 -0.0099

To replace the lost first observation, specify =pad=.
#+BEGIN_SRC R -n :exports both :results output
returns(x, pad = 0)
returns(x, pad = NA)
#+END_SRC 

#+RESULTS:
: [1]  0.0000  0.0200 -0.0098 -0.0099
: [1]      NA  0.0200 -0.0098 -0.0099

When =x= is a matrix or a data.frame, returns are computed
for each column.
#+BEGIN_SRC R -n :exports both :results output
X <- cbind(x, x, x)
returns(X, pad = NA)
returns(as.data.frame(X), pad = NA)
#+END_SRC 

#+RESULTS:
#+begin_example
           x       x       x
[1,]      NA      NA      NA
[2,]  0.0200  0.0200  0.0200
[3,] -0.0098 -0.0098 -0.0098
[4,] -0.0099 -0.0099 -0.0099
 
       x       x       x
1      NA      NA      NA
2  0.0200  0.0200  0.0200
3 -0.0098 -0.0098 -0.0098
4 -0.0099 -0.0099 -0.0099
#+end_example

=returns= is a generic function, which goes along with some
overhead. If you need to compute returns on simple data
structures as in the examples above and need fast computation,
then you may also use =.returns=. This function is the actual
workhorse that performs the raw returns calculation.


** =zoo= objects

=returns= has a method for =zoo= objects.
#+INDEX: zoo

#+BEGIN_SRC R -n :exports both :results output
  require("zoo", quietly = TRUE, warn.conflicts = FALSE)
  z <- zoo(x, as.Date("2015-1-5") + 0:2)
  returns(z)
  returns(z, pad = NA)
#+END_SRC 

#+RESULTS:
: 2015-01-06 2015-01-07 
:     0.0200    -0.0098
: 2015-01-05 2015-01-06 2015-01-07 
:         NA     0.0200    -0.0098


Matrices work as well.
#+BEGIN_SRC R -n :exports both :results output
z <- zoo(X, as.Date("2015-1-5") + 0:2)
returns(z)
returns(z, pad = NA)
#+END_SRC 

#+RESULTS:
:                  x       x       x
: 2015-01-06  0.0200  0.0200  0.0200
: 2015-01-07 -0.0098 -0.0098 -0.0098
:  
:                 x       x       x
: 2015-01-05      NA      NA      NA
: 2015-01-06  0.0200  0.0200  0.0200
: 2015-01-07 -0.0098 -0.0098 -0.0098


** Period returns

#+INDEX: returns!for calendar period
#+INDEX: returns!monthly
When a timestamp is available, =returns= can compute returns for
specific calendar periods. The result is a vector of returns with
attributes and class =p_returns=. Most useful is a =print= method.
#+BEGIN_SRC R -n :exports both :results output
t <- as.Date("2014-11-1") + 0:80
x <- cumprod(1 + rnorm(length(t), sd = 0.01))
returns(x, t = t, period = "month")
#+END_SRC 

#+RESULTS:
:  
:     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov  Dec  YTD
: 2014                                         6.0 -5.9 -0.3
: 2015 0.3                                               0.3


#+INDEX: returns!yearly

#+BEGIN_SRC R -n :exports both :results output
returns(x, t = t, period = "year")
#+END_SRC 

#+RESULTS:
: 2014 2015 
: -0.3  0.3

See =?print.preturns= for more display options. For instance:
#+BEGIN_SRC R -n :exports both :results output
print(returns(zoo(x, t), period = "month"), 
      digits = 2, year.rows = FALSE)
#+END_SRC 

#+RESULTS:
#+begin_example
       2014  2015
Jan         0.26
Feb             
Mar             
Apr             
May             
Jun             
Jul             
Aug             
Sep             
Oct             
Nov   5.99      
Dec  -5.93      
YTD  -0.30  0.26
#+end_example

To get annualised returns, use period `=ann='.
#+INDEX: returns!annualised
#+INDEX: annualised returns
#+BEGIN_SRC R -n :exports both :results output
returns(x, t = t,  period = "ann")
returns(zoo(x, t), period = "ann")
#+END_SRC 

#+RESULTS:
: 0.0% p.a.   [01 Nov 2014 -- 20 Jan 2015, less than one year]
: 0.0% p.a.   [01 Nov 2014 -- 20 Jan 2015, less than one year]

But note that the function did /not/ annualise: it does not annualise
if the time period is shorter than one year.
#+BEGIN_SRC R -n :exports both :results output
x[length(x)]/x[1] - 1
#+END_SRC 

#+RESULTS:
: [1] -0.000374

To force annualising, add a `=!='. The exclamation mark serves
as a mnenomic that it is now imperative to annualise.
#+BEGIN_SRC R -n :exports both :results output
returns(x, t, period = "ann!")
#+END_SRC 

#+RESULTS:
: -0.2% p.a.   [01 Nov 2014 -- 20 Jan 2015, less than one year]

There are methods to =toLatex= and =toHTML=
for monthly returns.  In Sweave documents, you need to use
=results = tex= and =echo = false= in the chunk options:

#+BEGIN_SRC tex :eval never
\noindent
\begin{tabular}{rrrrrrrrrrrrrr}
<<results=tex,echo=false>>=
toLatex(returns(x, t = t, period = "month"))
\end{tabular}
#+END_SRC


** Rebalanced returns                                             


#+BEGIN_SRC R -n :exports none :results output 
## TODO simple example: difference holdings, weights
  X <- array(c(100,105,110,100,100,100), dim = c(3,2))

  w <- c(0.5,0.5)
  budget <- 1
  position <- budget/X[1,]*w

  returns(X %*% position)
  returns(X) %*% w
#+END_SRC 


   We can also compute returns from fixed weights and assumptions
   when the portfolio is rebalanced. For instance, we may want to
   see how a constant allocation [0.1, 0.5, 0.4] to three funds
   would have done, assuming that a portfolio is rebalanced once
   a month.

   If more detail is necessary, then =btest= can be used; see
   [[#ch:backtesting][Backtesting]]. But the simple case can be done with
   =returns= already. Here is an example.

#+BEGIN_SRC R -n :exports both :results output 
  prices <- c(100, 102, 104, 104, 104.5,
                2, 2.2, 2.4, 2.3,   2.5,
              3.5,   3, 3.1, 3.2,   3.1)

  dim(prices) <- c(5, 3)
  prices

#+END_SRC

#+RESULTS:
:      [,1] [,2] [,3]
: [1,]  100  2.0  3.5
: [2,]  102  2.2  3.0
: [3,]  104  2.4  3.1
: [4,]  104  2.3  3.2
: [5,]  104  2.5  3.1

Now suppose we want a constant weight vector, [0.2, 0.5, 0.3],
but only rebalance at times 1 and 4.

#+BEGIN_SRC R -n :exports both :results output 
  returns(prices,
          weights = c(10, 50, 40)/100,
          rebalance.when = c(1, 4))
#+END_SRC

#+RESULTS:
#+begin_example
  [1] -0.00514  0.06376 -0.01282  0.03146
attr(,"holdings")
      [,1]  [,2]  [,3]
[1,] 0.001 0.250 0.114
[2,] 0.001 0.250 0.114
[3,] 0.001 0.250 0.114
[4,] 0.001 0.227 0.131
[5,] 0.001 0.227 0.131
attr(,"contributions")
         [,1]    [,2]    [,3]
[1,] 0.000000  0.0000  0.0000
[2,] 0.002000  0.0500 -0.0571
[3,] 0.002010  0.0503  0.0115
[4,] 0.000000 -0.0236  0.0108
[5,] 0.000481  0.0435 -0.0125
#+end_example

The result is the actual return series plus two additional pieces
of information.

- holdings :: A matrix whose dimensions correspond to those of
     =x=, and which gives the hypothetical holdings were used to
     compute the returns.
- contributions :: Another matrix; it procides the return
     contributions of the single assets.
 




* Backtesting
  :PROPERTIES:
  :CUSTOM_ID: ch:backtesting
  :END:

This chapter explains how to test trading strategies with the =btest=
function.
@@latex:\index{btest@\texttt{btest} (function)}@@

** Decisions

At any instant of time (in actual life, `now'), a trader needs to
answer the following questions:

- Do I want to compute a new target portfolio, yes or no? If yes,
  go ahead and compute the new target portfolio.

- Given the target portfolio and the actual portfolio, do I\nbsp{}want
  to rebalance (ie, close the gap between the actual portfolio and the
  target portfolio)? If yes, rebalance.

If such a decision is not just hypothetical, then the answer to the
second question may lead to a number of orders sent to a broker.  Note
that many traders do not think in terms of /stock/ (i.e. balances) as
we did here; rather, they think in terms of /flow/ (i.e.
orders). Both approaches are equivalent, but the described one makes
it easier to handle missed trades and synchronise accounts.

During a backtest, we will simulate the decisions of the trader.  How
precisely we simulate depends on the trading strategy.  The =btest=
function is meant as a helper function to simulate these decisions.
The logic for the decisions described above is coded in the functions
=do.signal=, =signal= and =do.rebalance=.

Implementing =btest= required a number of decision, too: (i)\nbsp{}what
to model (ie, how to simulate the trader), and (ii)\nbsp{}how to code
it.  As an example for point\nbsp{}(i): how precisely do we want to
model the order process (eg, use limit orders?  Allow partial fills?)
Example for\nbsp{}(ii): the backbone of =btest= is a loop that runs
through the data.  Loops are slow in R when compared with compiled
languages, so should we vectorise instead?  Vectorisation is indeed
often possible, namely if trading is not path-dependent.  If we have
already a list of trades, we can efficiently transform them into a
profit-and-loss in R without relying on an explicit loop.  Yet, one
advantage of looping is that the trade logic is more similar to actual
trading; we may even be able to reuse some code in live trading.

Altogether, the aim is to stick to the functional paradigm as much as
possible.  Functions receive arguments and evaluate to results; but
they do not change their arguments, nor do they assign or change other
variables `outside' their environment, nor do the results depend on
some variable outside the function.  This creates a problem, namely
how to keep track of state.  If we know what variables need to be
persistent, we could pass them into the function and always return
them.  But we would like to be more flexible, so we can pass an
environment; examples are below.  To make that clear: functional
programming should not be seen as a yes-or-no decision, but it is a
matter of degree.  And more of the functional approach can help
already.

** Data structure

We have one or several price series of length =T=. Internally, these
prices are stored in numeric matrices.

For a single asset, it is a matrix of prices with four columns: open,
high, low and close. For =n= assets, a list of length four:
=prices[[1]\]= is then a matrix with =n= columns containing
the open prices for the assets; =prices[[]]= is a matrix with
the high prices, and so on. If only close prices are used, then for
a single asset, either a matrix of one column or a numeric vector;
for multiple assets a list of length one, containing the matrix of
close prices. (For example, with 100 close prices of 5 assets, the
prices should be arranged in a matrix =p= of size 100 times 5;
and =prices = list(p)=.)

For a single asset, there is one matrix with one column each:
#+BEGIN_EXAMPLE
open   high    low   close
 +-+    +-+    +-+    +-+
 | |    | |    | |    | |
 | |    | |    | |    | |
 | |    | |    | |    | |
 | |    | |    | |    | |
 | |    | |    | |    | |
 +-+    +-+    +-+    +-+
#+END_EXAMPLE

With two assets, there are four matrices with two columns each:
#+BEGIN_EXAMPLE
 open     high     low     close
+-+-+    +-+-+    +-+-+    +-+-+  
| | |    | | |    | | |    | | |
| | |    | | |    | | |    | | |
| | |    | | |    | | |    | | |
| | |    | | |    | | |    | | |
| | |    | | |    | | |    | | |
+-+-+    +-+-+    +-+-+    +-+-+
#+END_EXAMPLE

The =btest= function runs from =b + 1= to =T=. The variable\nbsp{}=b= is
the burn-in and it needs
#+INDEX: burn-in
to be a positive integer; in rare cases it may be zero.  When we take
decisions that are based on past data, we will lose at least one data
point.

Here is an important default: at time\nbsp{}=t=, we can use information up
to time =t - 1=.  Suppose that =t= were\nbsp{}4.  We may use all information
up to time\nbsp{}3, and trade at the =open= in period\nbsp{}4.

#+BEGIN_EXAMPLE
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS    X                        <- trade here
5    HH:MM:SS
#+END_EXAMPLE

We could also trade at the =close=.

#+BEGIN_EXAMPLE
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS                       X     <-- trade here
5    HH:MM:SS
#+END_EXAMPLE

No, we cannot trade at the high or low. (Some people like the idea, as
a robustness check, to always buy at the high, sell at the low.
Robustness checks -- forcing a bit of bad luck into the simulation --
are a good idea, notably bad executions.  High/low ranges can inform
such checks, but using these ranges does not go far enough, and is
more of a good story than a meaningful test.)

** Functions

=btest= expects a number of functions. The default is to not
specify arguments to these functions, because they can all access the
following objects. These objects are themselves functions that can
access certain data; there are no replacement functions.

- Open :: access open prices
- High :: access high prices
- Low :: access low prices
- Close :: access close prices
- Wealth :: the total wealth (cash plus positions) at a given point in
     time
- Cash :: cash (in accounting currency)
- Time :: current time (an integer)
- Timestamp :: access =timestamp= when it is specified; if not,
     it defaults to =Time=
- Portfolio :: the current portfolio
- SuggestedPortfolio :: the currently-suggested portfolio
- Globals :: an environment

All the functions have the argument =lag=, which defaults
to =1=.  That can be a vector, too: the expression
#+BEGIN_SRC R :eval never :output none
Close(Time():1)
#+END_SRC
for instance will return all available close prices. Alternatively, we
can use the argument =n= to retrieve a number of past data
points. So the above example is equivalent to
#+BEGIN_SRC R :eval never :output none
Close(n = Time())
#+END_SRC
and
#+BEGIN_SRC R :eval never :output none
Close(n = 5)
#+END_SRC
 
returns the last five closing prices.

*** signal

The =signal= function uses information until \texttt{t -
  1} and returns the suggested portfolio (a vector) to be held at
=t=.

*** do.signal

=do.signal= uses information until =t - 1= and must return
=TRUE= or =FALSE=.  If the function is not specified, it
defaults to =function() TRUE=.

*** do.rebalance
#+INDEX: rebalance!during backtest

=do.rebalance= uses information until =t - 1= and returns =TRUE=
or =FALSE=. If the function is not specified, it defaults to
=function() TRUE=.

*** print.info

The function is called at the end of an iteration. It should not
return anything but is called for its side effect: print
information to the screen, into a file or into some other
connection.

** Examples: Single assets

It is best to describe the =btest= function through a number of
simple examples.

*** A useless first example

I really like simple examples. Suppose we have a single
instrument, and we use only close prices. The trading rule is to
buy, and then to hold forever. All we need is the time series of
the prices and the signal function. As an instrument we use the EURO
STOXX 50 future with expiry September 2015.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
timestamp <- structure(c(16679L, 16680L, 16681L, 16682L, 
                         16685L, 16686L, 16687L, 16688L, 
                         16689L, 16692L, 16693L), 
                       class = "Date")
prices <- c(3182, 3205, 3272, 3185, 3201, 
            3236, 3272, 3224, 3194, 3188, 3213)
data.frame(timestamp, prices)
#+END_SRC

#+RESULTS:
#+begin_example
    timestamp prices
1  2015-09-01   3182
2  2015-09-02   3205
3  2015-09-03   3272
4  2015-09-04   3185
5  2015-09-07   3201
6  2015-09-08   3236
7  2015-09-09   3272
8  2015-09-10   3224
9  2015-09-11   3194
10 2015-09-14   3188
11 2015-09-15   3213
#+end_example


#+BEGIN_SRC R -n :exports both
par(mar=c(3,3,1,1), las = 1, mgp = c(2.5,0.5,0), tck = 0.005, bty = "n",
    ps = 11)
plot(timestamp, prices, type = "l", xlab = "", ylab = "")
#+END_SRC

#+RESULTS:

The =signal= function is very simple indeed.
#+BEGIN_SRC R -n :exports both
signal <- function()
    1
#+END_SRC

#+RESULTS:

=signal= must be written so that it returns the suggested
position in units of the asset. In this first example, the suggested
position always is one unit. It is only a =suggested= portfolio
because we can specify rules whether or not to trade. Examples follow
below.

To test this strategy, we call =btest=.  The initial cash is
zero per default, so initial wealth is also zero in this case. We can
change it through the argument =initial.cash=.

#+BEGIN_SRC R -n :exports both :results output :colnames yes
(solution <- btest(prices = prices, signal = signal))
#+END_SRC 

#+RESULTS:
: initial wealth 0  =>  final wealth  8

The function returns a list with a number of components, but they
are not printed. Instead, a simple print method displays some
information about the results.

We arrange more details into a =data.frame=. =sp= is the
suggested position; =p= is the actual position.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
makeTable <- function(solution, prices)
    data.frame(prices = prices,
               sp     = solution$suggested.position,
               p      = solution$position,
               wealth = solution$wealth,
               cash   = solution$cash)

makeTable(unclass(solution), prices)
#+END_SRC 

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth  cash
1    3182  0       0      0     0
2    3205  1       1      0 -3205
3    3272  1       1     67 -3205
4    3185  1       1    -20 -3205
5    3201  1       1     -4 -3205
6    3236  1       1     31 -3205
7    3272  1       1     67 -3205
8    3224  1       1     19 -3205
9    3194  1       1    -11 -3205
10   3188  1       1    -17 -3205
11   3213  1       1      8 -3205
#+end_example

We bought in the second period because the default setting for the
burnin =b= is 1. Thus, we lose one observation. In the case
here we do not rely in any way on the past; hence, we set =b=
to zero. With this setting, we buy at the first price and hold until
the end of the data.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
solution <- btest(prices = prices, signal = signal, b  = 0)
makeTable(solution, prices)
#+END_SRC 

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth  cash
1    3182  1       1      0 -3182
2    3205  1       1     23 -3182
3    3272  1       1     90 -3182
4    3185  1       1      3 -3182
5    3201  1       1     19 -3182
6    3236  1       1     54 -3182
7    3272  1       1     90 -3182
8    3224  1       1     42 -3182
9    3194  1       1     12 -3182
10   3188  1       1      6 -3182
11   3213  1       1     31 -3182
#+end_example

If you prefer the trades only, the solution also contains a
=journal=.
#+INDEX: journal!backtest
#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(solution)
#+END_SRC

#+RESULTS:
:    instrument  timestamp  amount  price
: 1     asset 1          1       1   3182
: 
: 1 transaction

To make the journal more informative, we can pass timestamp and
instrument information.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, b  = 0,
              timestamp = timestamp, instrument = "FESX SEP 2015"))
#+END_SRC 

#+RESULTS:
:        instrument   timestamp  amount  price
: 1  FESX SEP 2015  2015-09-01       1   3182
: 
: 1 transaction



*** More useful examples

Now we make our strategy slightly more selective. The trading rule is
to have a position of 1 unit of the asset whenever the last observed
price is below 3200 and to have no position when it the price is above
3200. The =signal= function could look like this.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Close() < 3200)
        1 else 0
#+END_SRC

#+RESULTS:

We call =btest=.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
solution <- btest(prices = prices, signal = signal)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R -n :exports both :results output :colnames yes
makeTable(solution, prices)
#+END_SRC 

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth  cash
1    3182  0       0      0     0
2    3205  1       1      0 -3205
3    3272  0       0     67    67
4    3185  0       0     67    67
5    3201  1       1     67 -3134
6    3236  0       0    102   102
7    3272  0       0    102   102
8    3224  0       0    102   102
9    3194  0       0    102   102
10   3188  1       1    102 -3086
11   3213  1       1    127 -3086
#+end_example

The argument =initial.position= specifies the initial position;
default is no position. Suppose we had already held one unit of the
asset.
#+BEGIN_SRC R -n :exports both 
solution <- btest(prices = prices, signal = signal,
                  initial.position = 1)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R -n :exports both :results output :colnames yes
makeTable(solution, prices)
#+END_SRC 

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth cash
1    3182  1       1   3182    0
2    3205  1       1   3205    0
3    3272  0       0   3272 3272
4    3185  0       0   3272 3272
5    3201  1       1   3272   71
6    3236  0       0   3307 3307
7    3272  0       0   3307 3307
8    3224  0       0   3307 3307
9    3194  0       0   3307 3307
10   3188  1       1   3307  119
11   3213  1       1   3332  119
#+end_example

%% TODO: is this right? should be suggested position not be 1 in t==2?

Internally, =btest= stores \textsc{ohlc} prices in matrices.
So even for a single instrument we have four matrices: one for open
prices, one for high prices, and so on. In the single asset case, each
matrix has one column. If we were dealing with two assets, we would
again have four matrices, each with two columns. And so on.


We do not access these data directly. A function =Close= is
defined by =btest= and passed as an argument to
=signal=. Note that we do not add it as a formal argument to
=signal= since this is done automatically. In fact, doing it
manually would trigger an error message:
#+BEGIN_SRC R -n :exports both :eval never
signal <- function(Close = NULL)
    1
cat(try(btest(prices = prices, signal = signal)))
#+END_SRC

Similarly, we have functions =Open=, =High= and
=Low= (see Section\nbsp{}\ref{functions} above for a available
functions).

Suppose we wanted to add a variable, like a =threshold=
that tells us when to buy. This would need to be an argument to
=signal=; but it would also need to be passed with the
=\dots= argument of =btest=.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
signal <- function(threshold)
    if (Close() < threshold)
        1 else 0

solution <- btest(prices = prices, signal = signal,
                  threshold = 3200)      

makeTable(solution, prices)
#+END_SRC

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth  cash
1    3182  0       0      0     0
2    3205  1       1      0 -3205
3    3272  0       0     67    67
4    3185  0       0     67    67
5    3201  1       1     67 -3134
6    3236  0       0    102   102
7    3272  0       0    102   102
8    3224  0       0    102   102
9    3194  0       0    102   102
10   3188  1       1    102 -3086
11   3213  1       1    127 -3086
#+end_example

So far we have treated =Close= as a function without arguments,
but actually it has an argument =lag= that defaults to
=1=. Suppose the rule were to buy if the last close is below the
second-to-last close. =signal= could look like this.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Close(1L) < Close(2L))
        1 else 0
#+END_SRC 

#+RESULTS:

We could also have written =(Close() < Close(2L))=. This rule
rule needs the close price of yesterday and of the day before
yesterday, so we need to increase =b=.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
makeTable(btest(prices = prices, signal = signal, b = 2), prices)
#+END_SRC

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth  cash
1    3182  0      NA     NA     0
2    3205  0       0      0     0
3    3272  0       0      0     0
4    3185  0       0      0     0
5    3201  1       1      0 -3201
6    3236  0       0     35    35
7    3272  0       0     35    35
8    3224  0       0     35    35
9    3194  1       1     35 -3159
10   3188  1       1     29 -3159
11   3213  1       1     54 -3159
#+end_example

If we wanted to trade any other size, we would change our signal as
follows.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
signal <- function()
    if (Close() < 3200)
        2 else 0

makeTable(btest(prices = prices, signal = signal), prices)
#+END_SRC

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth  cash
1    3182  0       0      0     0
2    3205  2       2      0 -6410
3    3272  0       0    134   134
4    3185  0       0    134   134
5    3201  2       2    134 -6268
6    3236  0       0    204   204
7    3272  0       0    204   204
8    3224  0       0    204   204
9    3194  0       0    204   204
10   3188  2       2    204 -6172
11   3213  2       2    254 -6172
#+end_example

A typical way to specify a trading strategy is to map past prices into
=+1=, =0= or =-1= for long, flat or short. A
signal is often only given at a specified point (like in `buy one unit
now'). Example: suppose the third day is a Thursday, and our rule says
`buy after Thursday'.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
signal <- function()
    if (Time() == 3L)
        1 else 0

makeTable(btest(prices = prices, signal = signal,
                initial.position = 0, initial.cash = 100),
          prices)
#+END_SRC

#+RESULTS:
#+begin_example
     prices sp asset.1 wealth  cash
1    3182  0       0    100   100
2    3205  0       0    100   100
3    3272  0       0    100   100
4    3185  1       1    100 -3085
5    3201  0       0    116   116
6    3236  0       0    116   116
7    3272  0       0    116   116
8    3224  0       0    116   116
9    3194  0       0    116   116
10   3188  0       0    116   116
11   3213  0       0    116   116
#+end_example

But this is probably not what we wanted. If the rule is to buy and
then keep the long position, we should have written it like this.
#+BEGIN_SRC R -n :exports both
signal <- function()
    if (Time() == 3L)
        1 else Portfolio()
#+END_SRC

#+RESULTS:

The function =Portfolio= evaluates to last period's
portfolio. Like =Close=, its first argument sets the time
=lag=, which defaults to\nbsp{}1.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
makeTable(btest(prices = prices, signal = signal), prices)
#+END_SRC

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth  cash
1    3182  0       0      0     0
2    3205  0       0      0     0
3    3272  0       0      0     0
4    3185  1       1      0 -3185
5    3201  1       1     16 -3185
6    3236  1       1     51 -3185
7    3272  1       1     87 -3185
8    3224  1       1     39 -3185
9    3194  1       1      9 -3185
10   3188  1       1      3 -3185
11   3213  1       1     28 -3185
#+end_example

A common scenario is also a =signal= that evaluates to a
weight; for instance, after a portfolio optimisation. (Be sure to have
a meaningful initial wealth: 5 percent of nothing is nothing.)
#+BEGIN_SRC R -n :exports both :results output :colnames yes
signal <- function()
    if (Close() < 3200)
        0.05 else 0

solution <- btest(prices = prices,
                  signal = signal,
                  initial.cash = 100,
                  convert.weights = TRUE)
makeTable(solution, prices)
#+END_SRC

#+RESULTS:
#+begin_example
 
  prices      sp asset.1 wealth  cash
1    3182 0.00000 0.00000    100 100.0
2    3205 0.00157 0.00157    100  95.0
3    3272 0.00000 0.00000    100 100.1
4    3185 0.00000 0.00000    100 100.1
5    3201 0.00157 0.00157    100  95.1
6    3236 0.00000 0.00000    100 100.2
7    3272 0.00000 0.00000    100 100.2
8    3224 0.00000 0.00000    100 100.2
9    3194 0.00000 0.00000    100 100.2
10   3188 0.00157 0.00157    100  95.2
11   3213 0.00157 0.00157    100  95.2
#+end_example

Note that now we rebalance in every period. Suppose we did not want
that.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
do.rebalance <- function() {
    if (sum(abs(SuggestedPortfolio(0) - SuggestedPortfolio())) > 0.02)
        TRUE else FALSE
}

solution <- btest(prices = prices,
                  signal = signal,
                  initial.cash = 100,
                  do.rebalance = do.rebalance,
                  convert.weights = TRUE)

makeTable(solution, prices)
#+END_SRC

#+RESULTS:
#+begin_example
 
  prices      sp asset.1 wealth cash
1    3182 0.00000       0    100  100
2    3205 0.00157       0    100  100
3    3272 0.00000       0    100  100
4    3185 0.00000       0    100  100
5    3201 0.00157       0    100  100
6    3236 0.00000       0    100  100
7    3272 0.00000       0    100  100
8    3224 0.00000       0    100  100
9    3194 0.00000       0    100  100
10   3188 0.00157       0    100  100
11   3213 0.00157       0    100  100
#+end_example

See also the =tol= argument.  %% TODO: expand

**** Passing environments

To keep information persistent, we can use environments.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
external <- new.env()
external$vec <- numeric(length(prices))
signal <- function(threshold, external) {
    external$vec[Time()] <- Close()
    if (Close() < threshold)
        1 else 0
}

solution <- btest(prices = prices,
                     signal = signal,
                     threshold = 100,
                     external = external)

cbind(makeTable(solution, prices), external$vec)
#+END_SRC

#+RESULTS:
#+begin_example
   prices sp asset.1 wealth cash external$vec
1    3182  0       0      0    0         3182
2    3205  0       0      0    0         3205
3    3272  0       0      0    0         3272
4    3185  0       0      0    0         3185
5    3201  0       0      0    0         3201
6    3236  0       0      0    0         3236
7    3272  0       0      0    0         3272
8    3224  0       0      0    0         3224
9    3194  0       0      0    0         3194
10   3188  0       0      0    0         3188
11   3213  0       0      0    0            0
#+end_example

** Examples: Multiple assets


#+BEGIN_COMMENT
##%% \subsection{Again, a simple example}
##%% 
##%% <<>>=
##%% prices1 <- c(100,98, 98, 97, 96, 98,97,98,99,101)
##%% prices2 <- c(100,99,100,102,101,100,96,97,95,82)
##%% prices <- cbind(prices1, prices2)
##%% 
##%% signal <- function()
##%%     if (Close()[1L] > Close()[2L])
##%%         c(1, 0) else c(0, 1)
##%% 
##%% 
##%% (solution <- btest(prices = list(prices),
##%%                    signal = signal,
##%%                    b=2))
##%% #+END_SRC
##%% 
##%% We can also give more useful names to the assets.
##%% <<>>=
##%% prices <- cbind(AA = prices1, BB = prices2)
##%% solution <- btest(prices = list(prices),
##%%                                signal = signal, b=2)
##%% makeTable(solution, prices)
##%% 
##%% #+END_SRC
##%% 

#+END_COMMENT

** Common tasks

There is more than one ways to accomplish a certain task.  I describe
how I have handled some specific tasks.

*** Remembering an entry price
In signal: use the current price and assign in =Globals=.

*** Delaying signals

*** Losing signals

*** Various ways to specify when to do something

=btest= takes two functions, =do.signal= and =do.rebalance= that tell
the algorithm when to compute a new portfolio and when to
rebalance. There are a number of shortcuts for specifying these dates.

#+BEGIN_SRC R -n :exports both :results output :colnames yes
tmp <- structure(c(3490, 3458, 3434, 3358, 3287, 3321, 3419, 3535, 3589, 
                   3603, 3626, 3677, 3672, 3689, 3646, 3633, 3631, 3599, 3517, 3549, 
                   3572, 3578, 3598, 3634, 3618, 3680, 3669, 3640, 3675, 3604, 3492, 
                   3513, 3495, 3503, 3497, 3433, 3356, 3256, 3067, 3228, 3182, 3286, 
                   3279, 3269, 3182, 3205, 3272, 3185, 3201, 3236, 3272, 3224, 3194, 
                   3188, 3213, 3255, 3261), .Dim = c(57L, 1L), 
                 .Dimnames = list(
                     NULL, "fesx201509"), 
                 index = structure(c(16617L, 16618L, 
                                     16619L, 16622L, 16623L, 16624L, 16625L, 
                                     16626L, 16629L, 16630L, 
                                     16631L, 16632L, 16633L, 16636L, 16637L, 
                                     16638L, 16639L, 16640L, 
                                     16643L, 16644L, 16645L, 16646L, 16647L, 16650L, 
                                     16651L, 16652L, 
                                     16653L, 16654L, 16657L, 16658L, 16659L, 16660L, 
                                     16661L, 16664L, 
                                     16665L, 16666L, 16667L, 16668L, 16671L, 16672L, 
                                     16673L, 16674L, 
                                     16675L, 16678L, 16679L, 16680L, 16681L, 16682L, 
                                     16685L, 16686L, 
                                     16687L, 16688L, 16689L, 16692L, 16693L, 16694L, 
                                     16695L), class = "Date"), class = "zoo")

prices <- coredata(tmp)
timestamp <- index(tmp)
signal <- function()
    Time()
journal(btest(prices = prices, signal = signal))
#+END_SRC 

#+RESULTS:
#+begin_example
    instrument  timestamp  amount  price
1   fesx201509          2       1   3458
2   fesx201509          3       1   3434
3   fesx201509          4       1   3358
4   fesx201509          5       1   3287
5   fesx201509          6       1   3321
6   fesx201509          7       1   3419
7   fesx201509          8       1   3535
8   fesx201509          9       1   3589
9   fesx201509         10       1   3603
10  fesx201509         11       1   3626
11  fesx201509         12       1   3677
12  fesx201509         13       1   3672
13  fesx201509         14       1   3689
14  fesx201509         15       1   3646
15  fesx201509         16       1   3633
16  fesx201509         17       1   3631
17  fesx201509         18       1   3599
18  fesx201509         19       1   3517
19  fesx201509         20       1   3549
20  fesx201509         21       1   3572
21  fesx201509         22       1   3578
22  fesx201509         23       1   3598
23  fesx201509         24       1   3634
24  fesx201509         25       1   3618
25  fesx201509         26       1   3680
26  fesx201509         27       1   3669
27  fesx201509         28       1   3640
28  fesx201509         29       1   3675
29  fesx201509         30       1   3604
30  fesx201509         31       1   3492
31  fesx201509         32       1   3513
32  fesx201509         33       1   3495
33  fesx201509         34       1   3503
34  fesx201509         35       1   3497
35  fesx201509         36       1   3433
36  fesx201509         37       1   3356
37  fesx201509         38       1   3256
38  fesx201509         39       1   3067
39  fesx201509         40       1   3228
40  fesx201509         41       1   3182
41  fesx201509         42       1   3286
42  fesx201509         43       1   3279
43  fesx201509         44       1   3269
44  fesx201509         45       1   3182
45  fesx201509         46       1   3205
46  fesx201509         47       1   3272
47  fesx201509         48       1   3185
48  fesx201509         49       1   3201
49  fesx201509         50       1   3236
50  fesx201509         51       1   3272
51  fesx201509         52       1   3224
52  fesx201509         53       1   3194
53  fesx201509         54       1   3188
54  fesx201509         55       1   3213
55  fesx201509         56       1   3255
56  fesx201509         57       1   3261

56 transactions
#+end_example

#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, 
              do.signal = c(10, 20, 30)))
#+END_SRC 

#+RESULTS:
:     instrument  timestamp  amount  price
: 1  fesx201509         10       9   3603
: 2  fesx201509         20      10   3549
: 3  fesx201509         30      10   3604
: 
: 3 transactions

#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600))
#+END_SRC 

#+RESULTS:
#+begin_example
     instrument  timestamp  amount  price
1   fesx201509         10       9   3603
2   fesx201509         11       1   3626
3   fesx201509         12       1   3677
4   fesx201509         13       1   3672
5   fesx201509         14       1   3689
6   fesx201509         15       1   3646
7   fesx201509         16       1   3633
8   fesx201509         17       1   3631
9   fesx201509         24       7   3634
10  fesx201509         25       1   3618
11  fesx201509         26       1   3680
12  fesx201509         27       1   3669
13  fesx201509         28       1   3640
14  fesx201509         29       1   3675
15  fesx201509         30       1   3604

15 transactions
#+end_example

#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600,
              do.rebalance = FALSE))
#+END_SRC 

#+RESULTS:
:   no transactions
: Warning message:
: In btest(prices = prices, signal = signal, do.signal = prices >  :
:   'do.rebalance' is FALSE: strategy will never trade

#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600,
              do.rebalance = c(26, 30)))
#+END_SRC 

#+RESULTS:
:      instrument  timestamp  amount  price
: 1  fesx201509         26      25   3680
: 2  fesx201509         30       4   3604
: 
: 2 transactions

When =timestamp= is specified, certain calendar times are also
supported; =timestamp= must of a type that can be coerced to
=Date=.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
cat(try(journal(btest(prices = prices, signal = signal, 
                      do.signal = "firstofmonth"))))
#+END_SRC 

#+RESULTS:
:  Error in as.Date(timestamp) : 
:   argument "timestamp" is missing, with no default
: Error in as.Date(timestamp) : 
:   argument "timestamp" is missing, with no default

#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, 
              do.signal = "firstofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
:      instrument   timestamp  amount  price
: 1  fesx201509  2015-08-03      23   3634
: 2  fesx201509  2015-09-01      21   3182
: 
: 2 transactions

#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, 
              do.signal = "lastofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
:      instrument   timestamp  amount  price
: 1  fesx201509  2015-07-31      22   3598
: 2  fesx201509  2015-08-31      21   3269
: 3  fesx201509  2015-09-17      13   3261
: 
: 3 transactions

#+BEGIN_SRC R -n :exports both :results output :colnames yes
journal(btest(prices = prices, signal = signal, 
              do.signal = TRUE,
              do.rebalance = "lastofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
:       instrument   timestamp  amount  price
: 1  fesx201509  2015-07-31      22   3598
: 2  fesx201509  2015-08-31      21   3269
: 3  fesx201509  2015-09-17      13   3261
: 
: 3 transactions

There is also a function Timestamp.
#+BEGIN_SRC R -n :exports both :results output :colnames yes
signal <- function(timestamp) {
    if (Close() > 3500) {
        cat("Lagged price is > 3600 on", as.character(Timestamp()), "\n") 
        1
    } else 
        0
    
}
journal(btest(prices = prices, 
              signal = signal,
              ##signal = function() if (Close() > 3500) 1 else 0, 
              do.signal = TRUE,
              do.rebalance = "lastofmonth",
              timestamp = timestamp))
#+END_SRC 

#+RESULTS:
#+begin_example
Lagged price is > 3600 on 2015-07-10 
Lagged price is > 3600 on 2015-07-13 
Lagged price is > 3600 on 2015-07-14 
Lagged price is > 3600 on 2015-07-15 
Lagged price is > 3600 on 2015-07-16 
Lagged price is > 3600 on 2015-07-17 
Lagged price is > 3600 on 2015-07-20 
Lagged price is > 3600 on 2015-07-21 
Lagged price is > 3600 on 2015-07-22 
Lagged price is > 3600 on 2015-07-23 
Lagged price is > 3600 on 2015-07-24 
Lagged price is > 3600 on 2015-07-27 
Lagged price is > 3600 on 2015-07-28 
Lagged price is > 3600 on 2015-07-29 
Lagged price is > 3600 on 2015-07-30 
Lagged price is > 3600 on 2015-07-31 
Lagged price is > 3600 on 2015-08-03 
Lagged price is > 3600 on 2015-08-04 
Lagged price is > 3600 on 2015-08-05 
Lagged price is > 3600 on 2015-08-06 
Lagged price is > 3600 on 2015-08-07 
Lagged price is > 3600 on 2015-08-10 
Lagged price is > 3600 on 2015-08-11 
Lagged price is > 3600 on 2015-08-13 
Lagged price is > 3600 on 2015-08-17 
   instrument   timestamp  amount  price
1  fesx201509  2015-07-31       1   3598
2  fesx201509  2015-08-31      -1   3269

2 transactions
#+end_example

*** Testing rebalancing frequency

*** Writing a log
#+BEGIN_SRC R -n :exports both :results output :colnames yes
signal <- function()
    if (Close() < 3200)
        1 else 0

print.info <- function() {
    cat("period",
        sprintf("%2d", Time(0L)), "...",
        sprintf("%3d", Wealth(0)), "\n")
    flush.console()
}

solution <- btest(prices = prices,
                     print.info = print.info,
                     signal = signal)

makeTable(solution, prices)

#+END_SRC

#+RESULTS:
#+begin_example
period  2 ...   0 
period  3 ...   0 
period  4 ...   0 
period  5 ...   0 
period  6 ...   0 
period  7 ...   0 
period  8 ...   0 
period  9 ...   0 
period 10 ...   0 
period 11 ...   0 
period 12 ...   0 
period 13 ...   0 
period 14 ...   0 
period 15 ...   0 
period 16 ...   0 
period 17 ...   0 
period 18 ...   0 
period 19 ...   0 
period 20 ...   0 
period 21 ...   0 
period 22 ...   0 
period 23 ...   0 
period 24 ...   0 
period 25 ...   0 
period 26 ...   0 
period 27 ...   0 
period 28 ...   0 
period 29 ...   0 
period 30 ...   0 
period 31 ...   0 
period 32 ...   0 
period 33 ...   0 
period 34 ...   0 
period 35 ...   0 
period 36 ...   0 
period 37 ...   0 
period 38 ...   0 
period 39 ...   0 
period 40 ...   0 
period 41 ... -46 
period 42 ... -46 
period 43 ... -53 
period 44 ... -53 
period 45 ... -53 
period 46 ... -53 
period 47 ...  14 
period 48 ...  14 
period 49 ...  14 
period 50 ...  49 
period 51 ...  49 
period 52 ...  49 
period 53 ...  49 
period 54 ...  49 
period 55 ...  74 
period 56 ... 116 
period 57 ... 116
 
  fesx201509 fesx201509.1 fesx201509.2 wealth  cash
1        3490            0            0      0     0
2        3458            0            0      0     0
3        3434            0            0      0     0
4        3358            0            0      0     0
5        3287            0            0      0     0
6        3321            0            0      0     0
7        3419            0            0      0     0
8        3535            0            0      0     0
9        3589            0            0      0     0
10       3603            0            0      0     0
11       3626            0            0      0     0
12       3677            0            0      0     0
13       3672            0            0      0     0
14       3689            0            0      0     0
15       3646            0            0      0     0
16       3633            0            0      0     0
17       3631            0            0      0     0
18       3599            0            0      0     0
19       3517            0            0      0     0
20       3549            0            0      0     0
21       3572            0            0      0     0
22       3578            0            0      0     0
23       3598            0            0      0     0
24       3634            0            0      0     0
25       3618            0            0      0     0
26       3680            0            0      0     0
27       3669            0            0      0     0
28       3640            0            0      0     0
29       3675            0            0      0     0
30       3604            0            0      0     0
31       3492            0            0      0     0
32       3513            0            0      0     0
33       3495            0            0      0     0
34       3503            0            0      0     0
35       3497            0            0      0     0
36       3433            0            0      0     0
37       3356            0            0      0     0
38       3256            0            0      0     0
39       3067            0            0      0     0
40       3228            1            1      0 -3228
41       3182            0            0    -46   -46
42       3286            1            1    -46 -3332
43       3279            0            0    -53   -53
44       3269            0            0    -53   -53
45       3182            0            0    -53   -53
46       3205            1            1    -53 -3258
47       3272            0            0     14    14
48       3185            0            0     14    14
49       3201            1            1     14 -3187
50       3236            0            0     49    49
51       3272            0            0     49    49
52       3224            0            0     49    49
53       3194            0            0     49    49
54       3188            1            1     49 -3139
55       3213            1            1     74 -3139
56       3255            0            0    116   116
57       3261            0            0    116   116
#+end_example

And since =cat= has a =file= argument, we can also write
such information into a logfile.


*** Selecting parameters

Suppose you have a strategy that depends on a parameter
vector\nbsp{}$\theta$.  For a given $\theta$, the signal for the strategy
would look like this. 
#+BEGIN_SRC R :eval never
signal = function(theta) {
    compute signal(theta)
}
#+END_SRC
Now suppose we do not know theta.  We might want to test several
values, and then keep the best one.  For this, we need to call btest
recursively: at a point in time t, the strategy simulates the results
for various values for theta and chooses the best theta, according to
some criterion\nbsp{}$f$.

A useful idiom is this:
#+BEGIN_SRC R :eval never
signal = function(theta0) {
    if (not defined theta0) {
        ## run btest with theta_1, ... \theta_n, select best theta
        theta = argmin_theta f(btest(theta_i))
    } else
        theta = theta0

    compute indicator(theta)
    compute signal
}
#+END_SRC

Let us look at an actual example.


#+BEGIN_SRC R :eval never

require("tseries")
require("zoo")

tmp <- get.hist.quote("^GSPC", start = "2011-01-01", end = "2013-12-31", quote = "Close")

signal <- function(Data) {
    
    if (is.na(Data$N)) {
        
        price <- Close(Data$hist:1)
        Data0 <- list(N = 10, hist = 50)
        res1 <- btest(price, signal, Data = Data0, b = 100)
        Data0 <- list(N = 20, hist = 50)
        res2 <- btest(price, signal, Data = Data0, b = 100)
        if (tail(res1$wealth, 1) > tail(res2$wealth, 1))
            N <- 10 else N <- 20
        
    } else 
        N <- Data$N

    MA <- runStats("mean", Close(Data$hist:1), N = N)
    pos <- 0
    if (Close() > tail(MA, 1))
        pos <- 1
    pos
}
    
Data <- list(N = NA, hist = 200)
res <- btest(tmp$Close, signal, Data = Data, b = 202, initial.cash = 100, 
             convert.weights = TRUE)    
par(mfrow = c(2,1))
plot(index(tmp), res$wealth, type = "s")    
plot(tmp)

#+END_SRC 


* Valuation


  Computing the value of a position is, in principle,
  straightforward: multiply the prices of assets by the numbers
  of contracts you hold and sum the resulting values.

  That immediately leads to three questions:

1. What is price?

2. What is a contract?

3. Can we really sum?



** Prices




#+BEGIN_COMMENT

Valuing a position can mean two things: compute theoretical prices, or
market prices.

Theoretical valuation takes places via the generic function value:

#+BEGIN_SRC R :eval never
value(x, ..., dots2args = NULL)
#+END_SRC

The simplest case: =x= is character, then a call will be generated as

=do.call(x, list(...))=

=dots2args.default <- function(x, ...) list(...)=

Note that this will be the =default= method; notably, an
explicit =character= method is left unspecified (meant for the
user).


A more typical case: collect all market data in a list =Data=:
EvaluationDate, Prices, Vols, Irates.

dots2args will react on =x=, retrieve the required information,
and 


\begin{itemize}
\item evaluates to list ="value"=, ="delta"= etc
\item =Instrument[names(result)] <- result=
\end{itemize}


%% #+BEGIN_SRC R -n :exports both
%% Time   <- as.Date("2013-05-28")
%% Prices <- list(DAX = 8472)
%% Irates <- list(EUR = function(t) 0.1)
%% Vols   <- list(DAX = function(x,t) 0.2)

%% DATA <- list(Time = Time, 
%%              Prices = Prices, 
%%              IRates = Irates, 
%%              Vols = Vols)
%% DATA
%% DATA$Vols$DAX(8000, 0.2)
%% DATA$IRates$EUR(0.5)

%% #+END_SRC      


\section{Instruments and portfolios}



\subsubsection{Instrument}

classes: Fund Equity Account Currency Future Index


%% fields:

%% id
%% isin
%% description
%% underlier
%% expirydate
%% expirytime
%% strike
%% type c/p
%% exercise e/a
%% pricing premium/future
%% class

#+END_COMMENT


* Rebalancing a portfolio

#+INDEX: rebalance!a portfolio
@@latex:\index{rebalance@\texttt{rebalance} (function)}@@

The function =rebalance= computes the transactions necessary for
moving from one portfolio to another.

** Usage with unnamed vectors

The =current= portfolio is given in currency units; the =target=
portfolio is given in weights. To compute the required order
sizes, we also need the current prices of the assets. When
=current=, =target= and =price= are unnamed, the assets' positions in
the vectors need to match.

#+BEGIN_SRC R -n :exports both :results output
current <- c(0,0,100,100)
prices  <- c(1,1,1,1)
target  <- c(0.25, 0.25, 0.25, 0.25)
rebalance(current, target, prices, match.names = FALSE)
#+END_SRC 

#+RESULTS:
:  
:  price current value   %        new value   %        order
: 1     1       0     0  0.0        50    50 25.0          50
: 2     1       0     0  0.0        50    50 25.0          50
: 3     1     100   100 50.0        50    50 25.0         -50
: 4     1     100   100 50.0        50    50 25.0         -50
: 
: Notional: 200.  Amount invested: 200.  Total turnover: 200.

The current portfolio may also be empty, in which case =current=
can be set to 0. Then, of course, we need to specify a =notional=
for the target portfolio.
#+BEGIN_SRC R -n :exports both :results output
current <- 0
rebalance(current, target, prices, 
          match.names = FALSE, notional = 100)
#+END_SRC

#+RESULTS:
:  
:   price current value  %        new value   %        order
: 1     1       0     0 0.0        25    25 25.0          25
: 2     1       0     0 0.0        25    25 25.0          25
: 3     1       0     0 0.0        25    25 25.0          25
: 4     1       0     0 0.0        25    25 25.0          25
: 
: Notional: 100.  Amount invested: 100.  Total turnover: 100.

We may also specify the target portfolio as a single number.  
#+BEGIN_SRC R -n :exports both :results output
current <- c(5, 5, 100, 100)

target <- 0    ## liquidate the portfolio
rebalance(current, target, prices, match.names = FALSE)
#+END_SRC 

#+RESULTS:
:   price current value   %        new value  %        order
: 1     1       5     5  2.4         0     0 0.0          -5
: 2     1       5     5  2.4         0     0 0.0          -5
: 3     1     100   100 47.6         0     0 0.0        -100
: 4     1     100   100 47.6         0     0 0.0        -100
: 
: Notional: 210.  Amount invested: 0.  Total turnover: 210.

#+BEGIN_SRC R -n :exports both :results output
## every assets gets a weight of 20% 
target <- 0.2  
rebalance(current, target, prices, match.names = FALSE, notional = 100)
#+END_SRC 

#+RESULTS:
#+begin_example
  price current value    %        new value   %       
1     1       5     5   5.0        20    20 20.0      
2     1       5     5   5.0        20    20 20.0      
3     1     100   100 100.0        20    20 20.0      
4     1     100   100 100.0        20    20 20.0      
  order
1    15
2    15
3   -80
4   -80

Notional: 100.  Amount invested: 80.  Total turnover: 190.
#+end_example



** Usage with named vectors

More usefully, =rebalance= can also use the names of the vectors
current etc. The argument =match.names= must be set to =TRUE=
for this (which is the default, actually).
#+BEGIN_SRC R -n :exports both :results output
names(prices) <- letters[1:4]
current <- c(b = 10)
target  <- c(d = 0.5)

rebalance(current, target, prices)
#+END_SRC 

#+RESULTS:
:   price current value    %        new value   %       
: b     1      10    10 100.0         0     0  0.0      
: d     1       0     0   0.0         5     5 50.0      
:   order
: b   -10
: d     5
: 
: Notional: 10.  Amount invested: 5.  Total turnover: 15.

To also show all instruments, set the argument =drop.zero= to
=FALSE=.
#+BEGIN_SRC R -n :exports both :results output
print(rebalance(current, target, prices), drop.zero = FALSE)
#+END_SRC 

#+RESULTS:
#+begin_example
  price current value    %        new value   %       
a     1       0     0   0.0         0     0  0.0      
b     1      10    10 100.0         0     0  0.0      
c     1       0     0   0.0         0     0  0.0      
d     1       0     0   0.0         5     5 50.0      
  order
a     0
b   -10
c     0
d     5

Notional: 10.  Amount invested: 5.  Total turnover: 15.
#+end_example




* Analysing trades

** Exposure
#+INDEX: time-weighted exposure

We have the following trades and times.

#+BEGIN_SRC R -n :exports code :results none
  amount <- c(1,3,-3,1,-3,1)
  time <- c(0,1,3,4,7,12)
#+END_SRC

The holding period (duration) of these trades can be computed
so:
#+BEGIN_SRC R -n :exports both :colnames yes :results output
  data.frame(position = cumsum(amount)[-length(amount)], 
             from = time[-length(time)],
             to   = time[-1L],
             duration = diff(time))
#+END_SRC

#+RESULTS:
:      position from to duration
: 1        1    0  1        1
: 2        4    1  3        2
: 3        1    3  4        1
: 4        2    4  7        3
: 5       -1    7 12        5


We can plot the exposure.

#+BEGIN_SRC R -n :results graphics :file ~/Packages/PMwR/manual/exposure.pdf :width 4 :height 3 :exports both
par(bty = "n", mar = c(4, 4, 0, 0), tck = 0.005, 
    las = 1, ps = 12)
plot(c(time[1], time), cumsum(c(0, amount)), 
     type = "s", xlab = "time", ylab = "position")
#+END_SRC

#+RESULTS:
[[file:~/Packages/PMwR/manual/exposure.pdf]]

#+ATTR_HTML: :width 20% :height 20%
#+BEGIN_HTML
<object data="exposure.pdf" type="application/pdf">Your browser cannot display embedded pdfs. Please follow the link above.</object>
#+END_HTML


Thus, we have had a position from time zero to 12 (hours into the
trading day, say), but its size varied.  The function
=twExposure= (time-weighted exposure) computes the average
absolute exposure.
#+BEGIN_SRC R -n :exports both
twExposure(amount, time)
#+END_SRC

#+RESULTS:
: 1.75

To give a simple example: suppose we bought at the open of a trading
day and sold at noon.  The average exposure for the day is thus half a
contract.

#+BEGIN_SRC R -n :exports both
amount <- c(1, -1 , 0)
time   <- c(0,0.5,1)
twExposure(amount, time)
#+END_SRC

#+RESULTS:
: 0.5

 


** Splitting and rescaling

Suppose we have the following trades and impose a limit that the
maximum absolute exposure for the trader should only be 2.


#+BEGIN_SRC R -n :exports both :results output
t <- 1:6
n <- c(-1,-1,-1,1,1,1)
p <- c(100,99,98,98,99,100)
limit(n, p, t, lim = 2)
#+END_SRC

#+RESULTS:
: $amount
: [1] -1 -1  1  1
: 
: $price
: [1] 100  99  99 100
: 
: $timestamp
: [1] 1 2 5 6


Scaling the trades.

#+BEGIN_SRC R -n :exports both :results output
scaleToUnity(n)
#+END_SRC

#+RESULTS:
: [1] -0.333 -0.333 -0.333  0.333  0.333  0.333

Closing the trade at once.
#+BEGIN_SRC R -n :exports both :results output
closeOnFirst(n)
#+END_SRC

#+RESULTS:
: [1] -1 -1 -1  3  0  0



* Plotting irregularly-spaced series during trading hours

** An example

We have the following sample of prices of the Bund future contract,
traded at the [[http://www.eurexchange.com][Eurex]] in Germany. 

#+BEGIN_SRC R -n :exports results :colnames yes
  prices <- c(139.82, 139.82, 139.80, 139.81, 139.77, 139.85, 
              139.76, 139.76, 139.77, 139.80, 139.86, 140.46, 
              140.39, 140.14, 140.15)

  times <- structure(c(1350583209, 1350583271, 1350583319, 
                       1350583289, 1350584209, 1350586249, 
                       1350588199, 1350589299, 1350590399, 
                       1350630970, 1350632971, 1350673969, 
                       1350675751, 1350888315, 1350889533), 
                     class = c("POSIXct", "POSIXt"), tzone = "")
  data.frame(times, prices)
#+END_SRC

#+RESULTS:
| times               | prices |
|---------------------+--------|
| 2012-10-18 20:00:09 | 139.82 |
| 2012-10-18 20:01:11 | 139.82 |
| 2012-10-18 20:01:59 |  139.8 |
| 2012-10-18 20:01:29 | 139.81 |
| 2012-10-18 20:16:49 | 139.77 |
| 2012-10-18 20:50:49 | 139.85 |
| 2012-10-18 21:23:19 | 139.76 |
| 2012-10-18 21:41:39 | 139.76 |
| 2012-10-18 21:59:59 | 139.77 |
| 2012-10-19 09:16:10 |  139.8 |
| 2012-10-19 09:49:31 | 139.86 |
| 2012-10-19 21:12:49 | 140.46 |
| 2012-10-19 21:42:31 | 140.39 |
| 2012-10-22 08:45:15 | 140.14 |
| 2012-10-22 09:05:33 | 140.15 |



Note that I have left the time zone to the operating
system. Since my computer is typically located in the time zone
that the =tz database= ([[http://www.iana.org/time-zones]])
#+INDEX: tz database
#+INDEX: timezones
calls 'Europe/Berlin', the first time should be =2012-10-18
20:00:09=.  If, for instance, your computer is in
'America/Chicago' instead and you run the above code, the first
time would be =2012-10-18 13:00:09=. Which is right: it is the
correct time, only translated into Chicago local time.

A =plot= of price against time looks like this.

#+BEGIN_SRC R :results graphics :file ~/Packages/PMwR/manual/iplot1.pdf :width 6 :height 5 :exports both
plot(times, prices, type = "s")
#+END_SRC

#+RESULTS:
[[file:~/Packages/PMwR/manual/iplot1.pdf]]

#+ATTR_HTML: :width 50% :height 50%
#+BEGIN_HTML
<object data="iplot1.pdf" type="application/pdf"><i>Your browser cannot display embedded pdfs. Please follow the link above.</i></object>
#+END_HTML

Such a plot is fine for many purposes. But the contract for which
we have prices is only traded from Monday to Friday, not on
weekends, and it istraded only from 08:00 to 22:00 Europe/Berlin
time. So the plot should omit those times at which no trading
takes place. This is what the function =plotTradingHours= does.
#+INDEX: trading hours
#+INDEX: overnight gap
@@latex:\index{plotTradingHours@\texttt{plotTradingHours}}@@


#+BEGIN_SRC R :results graphics :file ~/Packages/PMwR/manual/iplot2.pdf :width 6 :height 5 :exports both
tmp <- plotTradingHours(x = prices, t = times, 
                        interval = "1 sec", labels = "day",
                        fromHHMMSS = "080000", toHHMMSS = "220000",
                        type = "s")
#+END_SRC

#+RESULTS:
[[file:~/Packages/PMwR/manual/iplot2.pdf]]

What we need for such a plot is a function that maps actual time
to a point on the /x/-scale, while the /y/-scale stays
unchanged. If we were talking only about days, not times, we
needed something like this:

| day      | /x/-position | mapped /x/-position |
| <l>      |          <r> |                 <r> |
|----------+--------------+---------------------|
| Thursday |            1 |                   1 |
| Friday   |            2 |                   2 |
| Saturday |            3 |         =<removed>= |
| Sunday   |            4 |         =<removed>= |
| Monday   |            5 |                   3 |

This mapping is what =plotTradingHours= provides. And not much
more: the design goal of the function is to make it as much as
possible an ordinary plot; or more specifically, to make it as
similar as possible to the =plot= function. Indeed,
=plotTradingHours= calls =plot= with a small number of default
settings:
#+BEGIN_SRC R :exports code :eval never
list(type = "l", xaxt = "n", xlab = "", ylab = "")
#+END_SRC 
These settings can all be overridden through the =...= argument,
which is passed to =plot=. Note that we already set =s= as the
plot's =type= in the last code chunk. The only required setting
is suppressing the /x/-axis with setting =xaxt= to 'n', because
=plotTradingHours= will create its own /x/-axis via a call to
=axis(1, ...)=. In case you wish to use your own axis
specification, either set =do.plotAxis= to =FALSE= or pass
settings to =axis= through the list =axis1.par=.

** More examples

*** Value of =plotTradingHours=

Like =plot=, =plotTradingHours= is typically called for its side
effect: creating a plot. But it also returns useful information
(invisibly, unless called with =do.plot = FALSE=).

#+BEGIN_SRC R -n :exports both :results output
str(tmp)
#+END_SRC 

#+RESULTS:
: List of 6
:  $ t          : int [1:15] 1 63 81 111 1001 3041 4991 6091 7191 11763 ...
:  $ x          : num [1:15] 140 140 140 140 140 ...
:  $ axis.pos   : num [1:2] 7193 57594
:  $ axis.labels: chr [1:2] "19.10." "22.10."
:  $ timegrid   : POSIXct[1:61527], format: "2012-10-18 20:00:09" ...
:  $ map        :function (t)

This information can be used to add elements to plots. An example follows.

*** Adding grid lines

We can add grid lines with =abline=. The /y/-axis poses no
special problem. The positions of the /x/-axis ticks are returned
from =plotTradingHours=.

#+BEGIN_SRC R :results graphics :file ~/Packages/PMwR/manual/iplot3.pdf :width 6 :height 5 :exports both
tmp <- plotTradingHours(x = prices, t = times, 
                        interval = "1 sec", 
                        labels = "day",
                        fromHHMMSS="080000", 
                        toHHMMSS = "220000",
                        type = "s")
abline(h = axTicks(2), v = tmp$axis.pos, 
       col = "lightgrey", lty = "dotted")
#+END_SRC 

#+RESULTS:
[[file:~/Packages/PMwR/manual/iplot3.pdf]]

If we wan to add to a specific time, say 19 October, 13:10:23, we
can use the function =map= that the call to =plotTradingHours=
returns.  We first create the specific time with, for example,
=ISOdatetime= or =strptime=.

#+BEGIN_SRC R -n :exports both :results output
## Again, I do not specify a time zone since time zones depend on the 
## operating system. To reproduce the example, you may also use this
## representation:
## mytime <- structure(1350645023, 
##                     class = c("POSIXct", "POSIXt"), tzone = "")
##

mytime <- ISOdatetime(2012, 10, 19, 13, 10, 23)
mytime
#+END_SRC 

#+RESULTS:
: [1] "2012-10-19 13:10:23 CEST"

Now we use =map= to translate this time into the appropriate
/x/-position.

#+BEGIN_SRC R :results graphics :file ~/Packages/PMwR/manual/iplot4.pdf :width 6 :height 5 :exports both
tmp <- plotTradingHours(x = prices, t = times, 
                        interval = "1 sec", labels = "day",
                        fromHHMMSS="080000", 
                        toHHMMSS = "220000",
                        type = "s")
abline(h = axTicks(2), v = tmp$axis.pos, 
       col = "lightgrey", lty = "dotted")
abline(v = tmp$map(mytime)$t, col = "red")
#+END_SRC 

#+RESULTS:
[[file:~/Packages/PMwR/manual/iplot4.pdf]]

The function =map= returns a list with two components, =t= and =ix=.
#+BEGIN_SRC R -n :exports both :results output
tmp$map(mytime)
#+END_SRC 

#+RESULTS:
: $t
: [1] 25816
: 
: $ix
: [1] 1

The first component is the appropriate position on the /x/-axis;
since it is a time it is called =t=. The second component gives
the subscripts to values that should actually be plotted. As an
example, suppose that we wish to plot points at several prices at
21:00:00 for several days.

#+BEGIN_SRC R -n :exports both :results output
## moretimes <- structure(c(1350586800, 1350673200, 1350759600), 
##                        class = c("POSIXct", "POSIXt"), tzone = "")
##

moretimes <- ISOdatetime(2012, 10, 18:20, 21, 00, 00)
values <- seq(140, 140.20, length.out = length(moretimes))
data.frame(times = moretimes, 
           weekday = format(moretimes, "%A"), 
           values)
#+END_SRC 

#+RESULTS:
:  
:                  times  weekday values
: 1 2012-10-18 21:00:00 Thursday    140
: 2 2012-10-19 21:00:00   Friday    140
: 3 2012-10-20 21:00:00 Saturday    140

But 20 October 2012 falls on a Saturday, and so it does not appear in the plot. 
#+BEGIN_SRC R -n :exports both :results output
tmp$map(moretimes)
#+END_SRC 

#+RESULTS:
: $t
: [1]  3592 53993
: 
: $ix
: [1] 1 2

The values that should be plotted can conveniently be found by using
=ix=.
#+BEGIN_SRC R -n :exports both :results output
values[tmp$map(moretimes)$ix]
#+END_SRC

#+RESULTS:
: [1] 140 140



# * A graphic

# #+BEGIN_SRC R :results graphics :file ~/Packages/PMwR/manual/test.pdf :width 7 :height 6 :exports results
#   plot(1:10)
# #+END_SRC

# #+ATTR_LATEX: :width 4cm :height 2.5cm
# #+RESULTS:
# [[file:test.pdf]]

# #+ATTR_HTML: :width 20% :height 20%
# #+BEGIN_HTML
# <object data="test.pdf" type="application/pdf">Your browser cannot display embedded pdfs. Please follow the link above.</object>
# #+END_HTML




* Scaling series

The function =scale1= rescales time-series.  It is a generic function;
currently there are methods for numeric vectors and for =zoo= objects.

** Numeric matrices

#+BEGIN_SRC R -n :exports both
x <- c(9400.04, 9435.15, 9428, 9506.2, 9497.84, 9421.61, 9473.24, 
       9510.17, 9540.51, 9733.81, 9717.71, 9742.96, 9715.9, 9730.12, 
       9720.11, 9631.04, 9392.02, 9349.22, 9406.91, 9336.73, 9373.48, 
       9306.48)
t <- structure(c(16072, 16073, 16076, 16077, 16078, 
                 16079, 16080, 16083, 16084, 16085, 
                 16086, 16087, 16090, 16091, 16092, 
                 16093, 16094, 16097, 16098, 16099, 
                 16100, 16101), 
               class = "Date")

scale1(x)
#+END_SRC 

#+RESULTS:
|                 1 |
|  1.00373509048898 |
|  1.00297445542785 |
|  1.01129356896354 |
|  1.01040421104591 |
|  1.00229467108651 |
|  1.00778720090553 |
|  1.01171590759188 |
|  1.01494355343169 |
|  1.03550729571364 |
|  1.03379453704452 |
|  1.03648069582683 |
|  1.03360198467241 |
|  1.03511474419258 |
|    1.034049855107 |
|  1.02457436351335 |
| 0.999146812141225 |
| 0.994593640027064 |
|  1.00073084795384 |
| 0.993264922276926 |
| 0.997174480108595 |
| 0.990046850864464 |

With =centre=, the daily mean \emph{return} is subtracted.
#+BEGIN_SRC R -n :exports both
scale1(x, centre = TRUE)
#+END_SRC 

#+RESULTS:
|                 1 |
|  1.00421331747428 |
|  1.00393041227059 |
|  1.01273974237873 |
|  1.01233120554868 |
|  1.00468465090715 |
|  1.01067158025088 |
|  1.01509494029324 |
|  1.01881854845208 |
|  1.03995605030523 |
|  1.03873059809138 |
|  1.04192576891034 |
|  1.03952697873954 |
|  1.04154441478418 |
|  1.04096864170791 |
|  1.03192117200964 |
|  1.00679074435658 |
|   1.0026802352837 |
|  1.00934801433163 |
|  1.00229511401331 |
|   1.0067196358352 |
| 0.999999999999999 |

With =scale=, the daily \emph{returns} are rescaled to to that
standard deviation.
#+BEGIN_SRC R -n :exports both
sd(returns(scale1(x, scale = 0.02)))
plot(x, type = "l")
plot(scale1(x, scale = 0.02))
#+END_SRC 

#+RESULTS:

## %% \section{Handling NAs}




* FAQ/@@latex:\,@@FRC (Frequently-required computations)       

** PnL for a given period

#+BEGIN_FAQ
I need to compute PnL for between two points in time, for
instance between yesterday's evening close and now (intraday).
#+END_FAQ

#+BEGIN_FAA
You need the position at $t_1$ and the journal of trades between
$t_1$ and $t_2$. Also, you will need the valuation prices for all
instruments at both points in time.
#+END_FAA


** Rebalancing weights

#+BEGIN_EXAMPLE
I want to compute =returns= when a portfolio (specified as weights) 
is rebalanced at specific times. However, I only have returns for the assets 
in the portfolio, not prices.
#+END_EXAMPLE

Answer: compute artificial prices.


** I need to value a financial instrument

** I have a list of trades (bought or sold what, when and at what price) and I need to compute the profit or loss.

\begin{mdframed}
  If all trades are closed (ie, the current positions are all zero),
  use =pl=.
\end{mdframed}

\begin{mdframed}
  \emph{I have a list of trades in an instrument and want to plot
    these trades against the price of the traded instrument.}
\end{mdframed}

\begin{mdframed}
  \emph{I have a signal series (=+1=, =0=, =0=,
    =+1=, \ldots{}) and need to transform it into a
    profit-and-loss series.}
\end{mdframed}

\begin{mdframed}
  \emph{I have a list of trades and need to determine the
    profit-and-loss between two timestamps.}
\end{mdframed}

Call the two timestamps =t0= and =t1=.  Unless the
position was zero at t0 and t1, we can compute the profit/loss only if
we have prices for the positions at these points in time.  In case the
position was indeed zero, you can use =pl=; the transactions
are stored in a journal =j=.

<<eval=false>>=
subset(j, timestamp >= t0 & timestamp <=t1)
@

But even the more general case is not so complicated, after all.

\begin{enumerate}
\item Compute the position at =t0= and make it a journal j0.

\item Take all transactions at $t > t_\mathrm{0}$ and $t \leq
   t_\mathrm{1}$ and put them into a journal $J$.

\item Compute the position at $t_\mathrm{1}$, and make it a journal
   $J_1$, but \emph{multiply all amounts by $-1$}.

\item Combine $J_0$, $J$, and $J_1$ and compute the PL.
\end{enumerate}

\begin{mdframed}
  \emph{I need to determine the month-to-date profit-and-loss.}
\end{mdframed}

1) compute position on last day of last month

2) make journal from position (add prices)

3) combine with journal since month start

4) use average (=avg=) on all instruments





* Appendix: Output of =sessionInfo()=

#+BEGIN_SRC R :results output :exports results
sessionInfo()
#+END_SRC

#+RESULTS:
#+begin_example
R version 3.2.2 (2015-08-14)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 15.10

locale:
 [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_GB.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_GB.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] datetimeutils_0.0-5  mailtools_0.1-3      textutils_0.0-6     
[4] PMwR_0.1-80          NMOF_0.36-4          portfolioTools_0.0-5
[7] esutils_0.1-3        zoo_1.7-12           database_0.1-39     

loaded via a namespace (and not attached):
 [1] lattice_0.20-33 digest_0.6.8    crayon_1.3.1    grid_3.2.2     
 [5] xts_0.9-7       fastmatch_1.0-4 RODBC_1.3-12    tools_3.2.2    
 [9] parallel_3.2.2  compiler_3.2.2  base64enc_0.1-3 IBrokers_0.9-12
[13] memoise_0.2.1
#+end_example


#+BEGIN_LATEX
\nocite{Gilli2011b}
\nocite{nmof2012}
\printbibliography
\printindex
#+END_LATEX


* Footnotes

[fn:1] This notation is inspired by the syntax of =ledger=
  files. See [[http://www.ledger-cli.org/]] .

[fn:2] We could even do it in [[https://www.perl.org/][Perl]]. =:-)= 



