% \VignetteIndexEntry{PMwR-Manual}
\documentclass[a4paper,11pt]{book}
\usepackage[left = 2.5cm, top = 2cm, bottom = 3cm, right = 4.7cm]{geometry}
\usepackage[noae,nogin]{Sweave}
\usepackage{mathpazo}
\usepackage{libertine}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\renewcommand*\familydefault{\sfdefault} 
\usepackage{amsmath,amstext}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{textcomp}
\usepackage{ragged2e}
\usepackage{framed}
\usepackage{makeidx}\makeindex

\usepackage{marginnote}
\renewcommand*{\marginfont}{\RaggedRight\sffamily\footnotesize}

\usepackage{graphics,xcolor}
\definecolor{grau2}{rgb}{0.2,0.2,0.2}
\definecolor{grau5}{rgb}{0.5,0.5,0.5}
\definecolor{grau7}{rgb}{0.7,0.7,0.7}

\SweaveOpts{keep.source = TRUE, eps = TRUE, pdf = FALSE}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{frame=single,xleftmargin=0em,%
  formatcom=\color{grau2},rulecolor=\color{grau7}}
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em}
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}

\newcommand{\pmwr}{\textsc{pm}w\textsc{r}}
\newcommand{\pl}{\textsc{pl}}
\newcommand{\R}{\textsf{R}}

\begin{document}
\pagestyle{empty}

\vglue 2cm

{\RaggedRight\Huge Portfolio Management with R (\pmwr)}\vskip 3cm

{\RaggedLeft{

    \noindent Enrico Schumann

    \noindent \texttt{es@enricoschumann.net}
  
    30 June 2014  }}

\bigskip

<<echo=false>>=
options(continue = " ", digits = 3, width = 60)
require("PMwR")
@

\chapter{Journals}

\chapter{Profit and (or) loss}

\chapter{Computing returns}

\chapter{Analysing trades}

\chapter{Backtesting strategies}

\chapter{Reporting}

\section{Text tools}

In many cases, reporting simply means constructing a message text that
is printed on a terminal or sent as an email.

\subsection{rmspace}

<<>>=
s <- c(" a a", " 19 EUR ")
rmspace(s)
@ 

\subsection{char2num}

<<>>=
char2num("12.000,23")
char2num("12,000.23", big.mark = ",")
char2num("12000.23",  big.mark = " ") ## but 'as.numeric' is simpler
char2num("12'000.23", big.mark = "'")
char2num("12 000|23", dec = "|", big.mark = " ")
@ 

\subsection{expstring}
Expand a string

<<>>=
s <- c("profits: 100 EUR", "fees:  20 EUR")
cat(s, sep = "\n")
s <- expstr(s, after = ": ", width = 20)
cat(s, sep = "\n")
nchar(s)  ## width
@ 

\section{qpTable}

quartile plot table

\section{slTable}

sparkline table

arguments:
\begin{itemize}
\item \ldots : zoo objects
\item include.returns
\item include.diffs
\item compute.with = "returns": or "diffs" or "levels"
\item columns = list(mean = mean, sd = sd): need to be computed on returns
\end{itemize}



\chapter{Technical indicators}

sum, abssum, sd, absmean, range, minmax, minmaxrange, mad




\appendix
\chapter{Tutorials}

\section{Single-entry accounting}

\section{Double-entry accounting}

\chapter{Design}

\section{Requirements}

\begin{itemize}
\item Store a 'portfolio' of assets and compute the value (or other
  quantities, like Greeks) for different data.  Data can refer to
  market prices, but also to theoretical prices.
\item Reevaluate a portfolio for scenario (= new market data or
  artificial data).
\item Read in transactions from various sources. $\to$ done via a
  journal class.
\item Show portfolio on certain day/time: create a position, evaluate
  this position $\to$ position class
\item testing portfolios of options --> show payoff, simulate *paths*
  of underlier and vol surface
\item run simulations for VaR
\item various ways to compute pnl: weighted average,
  first-in-first-out and last-in-last-out
\end{itemize}


\section{Classes}

The following classes are implicitly defined (ie, S3 classes):

\begin{itemize}
\item journal: keeps transactions
\item Position: only for printing. It comprises the numerical
  positions of different accounts/instruments, the timestamps and the
  description of the instruments.
\item Instrument: term sheet (description etc); it does know nothing
  about market data
\item Cashflow: internal
\item Timeseries: internal
\end{itemize}

\section{Valuation}

Valuing a position can mean two things: compute theoretical prices,
or market prices.

Theoretical valuation takes places via the generic function value:

\texttt{value(x, ..., dots2args = NULL) } 

The simplest case:
\texttt{x} is character, then a call will be generated as

\texttt{do.call(x, list(...))}

\texttt{dots2args.default <- function(x, ...) list(...)}

Note that this will be the \texttt{default} method; notably, an
explicit \texttt{character} method is left unspecified (meant for the
user).


A more typical case: collect all market data in a list \texttt{Data}:
EvaluationDate, Prices, Vols, Irates.

dots2args will react on \texttt{x}, retrieve the required information,
and 



\begin{itemize}
\item evaluates to list \texttt{"value"}, \texttt{"delta"} etc
\item \texttt{Instrument[names(result)] <- result}
\end{itemize}


%% <<>>=
%% Time   <- as.Date("2013-05-28")
%% Prices <- list(DAX = 8472)
%% Irates <- list(EUR = function(t) 0.1)
%% Vols   <- list(DAX = function(x,t) 0.2)

%% DATA <- list(Time = Time, 
%%              Prices = Prices, 
%%              IRates = Irates, 
%%              Vols = Vols)
%% DATA
%% DATA$Vols$DAX(8000, 0.2)
%% DATA$IRates$EUR(0.5)

%% @      


\section{Instruments and portfolios}



\subsubsection{Instrument}

classes: Fund Equity Account Currency Future Index


%% fields:

%% id
%% isin
%% description
%% underlier
%% expirydate
%% expirytime
%% strike
%% type c/p
%% exercise e/a
%% pricing premium/future
%% class

\section{Implementation}

\subsection{Vectorisation}

Functions should do vectorisation when they have to.  Example:
drawdown is interally computed through \texttt{cumsum}, so even for a
matrix of time series, it would need a loop.  This should be left to
the user. 

The exception is when computations can be accelerated.

\subsection{Named vectors}


\subsection{Functional programming}

Do not rely on global options/settings. Exception: \texttt{print}
methods

\chapter{Frequently-used functions}

\begin{framed}
  \emph{\noindent I need to value a financial instrument.}
\end{framed}

\begin{framed}
  \emph{I have a list of trades (bought or sold what, when and at what
    price) and I need to compute the profit or loss.}
\end{framed}

\begin{framed}
  If all trades are closed (ie, the current positions are all zero),
  use \texttt{pl}.
\end{framed}

\begin{framed}
  \emph{I have a list of trades in an instrument and want to plot
    these trades against the price of the traded instrument.}
\end{framed}

\begin{framed}
  \emph{I have a signal series (\texttt{+1}, \texttt{0}, \texttt{0},
    \texttt{+1}, \ldots{}) and need to transform it into a
    profit-and-loss series.}
\end{framed}

\begin{framed}
  \emph{I have a list of trades and need to determine the
    profit-and-loss between two timestamps.}
\end{framed}

Call the two timestamps \texttt{t0} and \texttt{t1}.  Unless the
position was zero at t0 and t1, we can compute the profit/loss only if
we have prices for the positions at these points in time.  In case the
position was indeed zero, you can use \texttt{pl}; the transactions
are stored in a journal \texttt{j}.

<<eval=false>>=
subset(j, timestamp >= t0 & timestamp <=t1)
@

But even the more general case is not so complicated, after all.

\begin{enumerate}
\item Compute the position at \texttt{t0} and make it a journal j0.

\item Take all transactions at $t > t_\mathrm{0}$ and $t \leq
   t_\mathrm{1}$ and put them into a journal $J$.

\item Compute the position at $t_\mathrm{1}$, and make it a journal
   $J_1$, but \emph{multiply all amounts by $-1$}.

\item Combine $J_0$, $J$, and $J_1$ and compute the PL.
\end{enumerate}

\begin{framed}
  \emph{I need to determine the month-to-date profit-and-loss.}
\end{framed}

1) compute position on last day of last month

2) make journal from position (add prices)

3) combine with journal since month start

4) use average (\texttt{avg}) on all instruments


\chapter{Computations}
\section{Positions}

We have three vectors: \texttt{when}, \texttt{timestamp} and
\texttt{amount}.  Vectors \texttt{when} and \texttt{timestamp} are of
the same type and are both sorted in increasing order;
\texttt{timestamp} and \texttt{amount} have the same length.  The
result of the computation is a vector \texttt{position} with the same
length as \texttt{when}.

\begin{verbatim}
i, j = 0  /* i loops over when; j loops over amount/timestamp */
for (i = 0; i < length(when); i++) {
  if (i == 0)
    pos[i] = 0;
  else
    pos[i] = pos[i - 1];
  while (timestamp[j] <= when[i] && j < length(j))
    position[i] += amount[j++];
}
\end{verbatim}


\printindex
\bibliographystyle{plainnat}
\bibliography{bibliothek}



\end{document}


%\#\# journal.cli(J, \ldots{})
%\#\#while (input != "exit") \{
%\#\#  input <- readline()
%\#\#  \#\# parse me
%\#\#\}
