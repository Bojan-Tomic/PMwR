% \VignetteIndexEntry{PMwR-Manual}
\documentclass[a4paper,11pt]{book}
\usepackage[left = 2.5cm, top = 2cm, bottom = 3cm, right = 4.7cm]{geometry}
\usepackage[noae,nogin]{Sweave}
\usepackage{mathpazo}
\usepackage{libertine}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\renewcommand*\familydefault{\sfdefault} 
\usepackage{amsmath,amstext}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{textcomp}
\usepackage{ragged2e}
\usepackage{framed}
\usepackage{makeidx}\makeindex

\usepackage{marginnote}
\renewcommand*{\marginfont}{\RaggedRight\sffamily\footnotesize}

\usepackage{graphics,xcolor}
\definecolor{grau2}{rgb}{0.2,0.2,0.2}
\definecolor{grau5}{rgb}{0.5,0.5,0.5}
\definecolor{grau7}{rgb}{0.7,0.7,0.7}

\SweaveOpts{keep.source = TRUE, eps = TRUE, pdf = FALSE}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{frame=single,xleftmargin=0em,%
  formatcom=\color{grau2},rulecolor=\color{grau7}}
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em}
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}

\newcommand{\pmwr}{\textsc{pm}w\textsc{r}}
\newcommand{\pl}{\textsc{pl}}
\newcommand{\R}{\textsf{R}}

\begin{document}
\pagestyle{empty}

\vglue 2cm

{\RaggedRight\Huge Portfolio Management with R (\pmwr)}\vskip 3cm

{\RaggedLeft{

    \noindent Enrico Schumann

    \noindent \texttt{es@enricoschumann.net}
  
    30 June 2014  }}

\bigskip

<<echo=false>>=
options(continue = " ", digits = 3, width = 60)
require("PMwR")
@

\chapter{Journals}

\chapter{Profit and (or) loss}

\chapter{Computing returns}

\chapter{Analysing trades}

\chapter{Backtesting strategies}

\chapter{Reporting}

\section{Text tools}

In many cases, reporting simply means constructing a message text that
is printed on a terminal or sent as an email.

\subsection{rmspace}

<<>>=
s <- c(" a a", " 19 EUR ")
rmspace(s)
@ 

\subsection{char2num}

<<>>=
char2num("12.000,23")
char2num("12,000.23", big.mark = ",")
char2num("12000.23",  big.mark = " ") ## but 'as.numeric' is simpler
char2num("12'000.23", big.mark = "'")
char2num("12 000|23", dec = "|", big.mark = " ")
@ 

\subsection{expstring}
Expand a string

<<>>=
s <- c("profits: 100 EUR", "fees:  20 EUR")
cat(s, sep = "\n")
s <- expstr(s, after = ": ", width = 20)
cat(s, sep = "\n")
nchar(s)  ## width
@ 

\section{qpTable}

quartile plot table

\section{slTable}

sparkline table

arguments:
\begin{itemize}
\item \ldots : zoo objects
\item include.returns
\item include.diffs
\item compute.with = "returns": or "diffs" or "levels"
\item columns = list(mean = mean, sd = sd): need to be computed on returns
\end{itemize}



\chapter{Technical indicators}

sum, abssum, sd, absmean, range, minmax, minmaxrange, mad




\appendix
\chapter{Tutorials}

\section{Single-entry accounting}

\section{Double-entry accounting}

\chapter{Design}

\section{Requirements}



\section{Classes}


\section{Valuation}

Valuing a position can mean two things: compute theoretical prices,
or market prices.

Theoretical valuation takes places via the generic function value:

\texttt{value(x, ..., dots2args = NULL) } 

The simplest case:
\texttt{x} is character, then a call will be generated as

\texttt{do.call(x, list(...))}

\texttt{dots2args.default <- function(x, ...) list(...)}

Note that this will be the \texttt{default} method; notably, an
explicit \texttt{character} method is left unspecified (meant for the
user).


A more typical case: collect all market data in a list \texttt{Data}:
EvaluationDate, Prices, Vols, Irates.

dots2args will react on \texttt{x}, retrieve the required information,
and 



\begin{itemize}
\item evaluates to list \texttt{"value"}, \texttt{"delta"} etc
\item \texttt{Instrument[names(result)] <- result}
\end{itemize}


%% <<>>=
%% Time   <- as.Date("2013-05-28")
%% Prices <- list(DAX = 8472)
%% Irates <- list(EUR = function(t) 0.1)
%% Vols   <- list(DAX = function(x,t) 0.2)

%% DATA <- list(Time = Time, 
%%              Prices = Prices, 
%%              IRates = Irates, 
%%              Vols = Vols)
%% DATA
%% DATA$Vols$DAX(8000, 0.2)
%% DATA$IRates$EUR(0.5)

%% @      


\chapter{Frequently-used functions}

\chapter{Computations}
\section{Positions}

We have three vectors: \texttt{when}, \texttt{timestamp} and
\texttt{amount}.  Vectors \texttt{when} and \texttt{timestamp} are of
the same type and are both sorted in increasing order;
\texttt{timestamp} and \texttt{amount} have the same length.  The
result of the computation is a vector \texttt{position} with the same
length as \texttt{when}.

\begin{verbatim}
i, j = 0  /* i loops over when; j loops over amount/timestamp */
for (i = 0; i < length(when); i++) {
  if (i == 0)
    pos[i] = 0;
  else
    pos[i] = pos[i - 1];
  while (timestamp[j] <= when[i] && j < length(j))
    position[i] += amount[j++];
}
\end{verbatim}


\printindex
\bibliographystyle{plainnat}
\bibliography{bibliothek}



\end{document}


%\#\# journal.cli(J, \ldots{})
%\#\#while (input != "exit") \{
%\#\#  input <- readline()
%\#\#  \#\# parse me
%\#\#\}
