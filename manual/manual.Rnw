% \VignetteIndexEntry{PMwR-Manual}
\documentclass[a4paper,11pt]{book}
\usepackage[left = 2.5cm, top = 2cm, bottom = 3cm, right = 4.5cm]{geometry}
\usepackage[noae,nogin]{Sweave}
\usepackage{mathptmx}
\usepackage{amsmath,amstext}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{textcomp}
\usepackage{ragged2e}
\usepackage{framed}
\usepackage{makeidx}
\SweaveOpts{keep.source = TRUE, eps = TRUE, pdf = FALSE}


\begin{document}
\pagestyle{empty}

\vglue 2cm

{\RaggedRight\Huge Portfolio Management with R (PMwR)}\vskip 3cm


{\RaggedLeft{
\noindent Enrico Schumann\\
\noindent \texttt{es@enricoschumann.net}\\}}
\bigskip

<<echo=false>>=
require("PMwR")
@

\chapter{Journals}
\pagestyle{plain}

\section{Transactions}

The basis for many computations that PMwR package provides are lists
of transactions.  Such list are nothing more than dataframes, but
\texttt{PMwR} provides an S3 class \texttt{journal} for handling such
transaction data.  A \texttt{journal} is created through the function
\texttt{journal}, but it is really just a list of atomic vectors with
a class attribute.  Methods should not rely on this list sorted in any
particular way; that is, components of a journal should always be
retrieved by name, never by position (which is different for a
dataframe, for which we can meaningfully speak of the \emph{n}th
column).  I will often refer to these components, such as
\texttt{amount} or \texttt{timestamp}, as fields.

The simplicity of the class is intended, as it is meant for
interactive analyses.  Thus, you may and are expected to dissect the
information in a journal at will (which includes removing the class
attribute).

What is actually stored in a \texttt{journal} is up to you, but a few
fields are offered by default (and required by some methods):
\begin{description}
\item[\texttt{timestamp}] anything that can be sorted and that fits into an
  atomic vector (\texttt{POSIXlt} is possible, too, but not
  recommended);

\item[\texttt{amount}] notional amount that is transferred;

\item[\texttt{price}] price;

\item[\texttt{instrument}] description of the financial instrument;

\item[\texttt{id}] (possibly unique) id;

\item[\texttt{account}] description of the account;

\item[\texttt{\ldots}] other fields. They must be named, for instance
  like in \texttt{fees = c(1,2,1)}\,.
\end{description}
All these can be missing, except \texttt{amount}.

Transactions in a journal can be organised in a hierachy
\begin{verbatim}
<account>:::<instrument>
\end{verbatim}
even though currently few functions use this hierarchy.  A simple
scheme is to use specific character or pattern such as `\texttt{:::}'
to introduce hierarchies into accounts, such as
\begin{verbatim}
pension:::equities
\end{verbatim}

\section{Handling journals}

\subsection{Creating journals}

The function \texttt{journal} creates journal objects.
<<>>=
J <- journal(timestamp  = as.Date("2012-01-01") + 0:3, 
             amount     = c(1, 2, -2, 5),
             instrument = c("EUR", "EUR", "CHF", "CHF"))
J
@ 
For details on the function and methods for journal objects, see
\texttt{?journal}\,.  A \texttt{print} method defines how to display a
journal.
<<>>=
print(J, max.print = 2, exclude = "instrument")
@ 
Journals can be combined with \texttt{c}.
<<>>=
JJ <- J
JJ$fees <- rep(1,4)
c(J, JJ)
@ 

\subsection{Subsetting journals}
For interactive use, there is a method for \texttt{subset}.
<<>>=
subset(J, amount > 1) 
@ 
To extract a field, use its name.
<<>>=
J$amount
@ 
<<>>=
J$amount <- c(1 ,2, -2, 8)
J
@ 
The \texttt{`[`} method works with integers or logicals, returning
the respective transactions.
<<>>=
J[2:3]
J[J$amount < 0]
@ 
You can also pass a string, which is then interpreted as a regular
expression that is matched against fields \texttt{instrument} and (if
available) \texttt{account}.
<<>>=
J["eur"]
@ 
By default, case is ignored, but you can set \texttt{ignore.case =
  FALSE}.  You can also specify the fields to match the string against.
<<>>=
J <- journal(timestamp  = as.Date("2012-01-01") + 0:5, 
             amount     = rep(1, 6),
             instrument = c("Equity A", "Equity A", 
                            "Equity B", 
                            "Bond exp 2019", "Bond exp 2017", 
                            "Bond exp 2021"),
             comment = c("pension plan", "pension plan", 
                          "", "", "", ""))
J["equ", ignore.case = FALSE]
J["equ", ignore.case = TRUE]
J["[Pp]ension"]
J["[Pp]ension", match.against = "comment"]
@ 


\section{First examples}

\subsection{Single-entry accounting}

For many purposes, single-entry accounting is sufficient.  Suppose you
kept track of a bank account.

<<>>=
jnl <- journal(timestamp = as.Date("2012-01-01") + 0:3, 
               amount    = c(1, 2, -2, 5))
jnl 
@
The \texttt{position} function gives the current balance of an account.
<<>>=
position(jnl)
@
To get the position at a specific date, use the \texttt{when} argument.
<<>>=
position(jnl, when = as.Date("2012-01-03"))
@
To get a time series of positions, you can use specific keywords for
\texttt{when}: \texttt{"all"} will print the position at all
timestamps that were passed.
<<>>=
position(jnl, when = "all")
@
We are not limited to the timestamps that exist in the journal.
<<>>=
position(jnl, when = seq(from = as.Date("2011-12-30"), 
                           to = as.Date("2012-01-06"),
                           by = "1 day"))
@
It's actually tedious to enter journals that way, in particular if we
want to update it over time.  So we write transactions into files,
like this:

\VerbatimInput{ex1.jnl}

\noindent In case you use Org-mode, such tables should look familiar. An aside:
if the original file happened to look such

\VerbatimInput{ex1.txt}

then there are many tools to transform it. 
<<>>=
system("perl -ne 'print $_ if /^\\s*\\| /;' < ex1.txt > ex1.jnl")
@ 
Here is a simple function to read such journal files.
<<>>=
readjnl <- function(file) {
    ans <- read.table(file, 
                      header = TRUE, sep = "|", as.is = TRUE)
    ans <- as.list(ans[ ,apply(ans, 2, function(x) !all(is.na(x)))])
    journal(timestamp = ans$timestamp,
            amount    = ans$amount,
            comment   = ans$comment)
}
(jnl <- readjnl("ex1.jnl"))
@ 
Some of these transactions may mean a gain or loss to us (such as a
dividend payment), while others are neutral (such as a transfer
between bank accounts).  How can we deal with that?  One way is to
switch to double-entry accounting (see the next section).  Another way
is to add description fields like \texttt{"expense"} and then subset
by these fields.

And yet another approach is this: use prices.  Whenever you evaluate
the balances of your account, say that the price per commodity unit is
one.  That is reasonable: if I my account has a balance of `120.2', it
actually means `120.2 euros'.  When evaluated in euro, the price is
one.

An expense should be a negative amount; income should go with positive
amounts.  When you add such an entry, make its price 0; when you
compute that value of a position, make its price 1.  An example:

<<>>=
jnl <- journal(timestamp = c("day 1", "day 2", "day 3"), 
               amount    = c(100,100,-200), 
               price     = c(  1,  0,   0),
               comment   = c("neutral", "income", "expense"),
               account   = "my account")
jnl
@
The current balance is 0.
<<>>=
position(jnl)
@ 
In terms of income and expenses we have made a loss of 100.
<<>>=
pl(jnl, t1 = "day 3", prices1 = 1)
@ 



Let us do some more finance-style transactions.  We buy five times one
unit of some unspecified asset.
<<>>=
j1 <- journal(timestamp = 1:5, 
               amount   = 1, 
               price    = c(2,2,2,3,4), 
               account  = "my account")
j1
@
Now we close the trade.
<<>>=
j2 <- journal(timestamp =  6, 
               amount   = -5, 
               price    =  3, 
               account  = "my account")
@
We can combine these journals with \texttt{c}.
<<>>=
c(j1, j2)
@
Since the position is now zero, it is easy to compute the
profit/loss.  We can use the function \texttt{pl}.  
<<>>=
pl(c(j1, j2))
@



\subsection{Double-entry accounting}

Expenses, Income

Assets, Liabs, Equity


\section{A more complicated example.}


\begin{center}
\begin{tabular}{llllrrr}
Symbol & ISIN         & Date/Time       & Buy/Sell & Quantity & Price  & Commission \\
\hline
BEId   & DE0005200000 & 20121205;031737 & BUY      & 49       & 60.45  & -4         \\
BEId   & DE0005200000 & 20130313;085611 & BUY      & 58       & 69.55  & -4.0339    \\
DB1d   & DE0005810055 & 20130611;033824 & BUY      & 100      & 49.115 & -4.9115    \\
DTEd   & DE0005557508 & 20121205;032202 & BUY      & 313      & 8.6    & -4         \\
DTEd   & DE0005557508 & 20130204;112639 & BUY      & 187      & 8.854  & -4         \\
DTEd   & DE0005557508 & 20130313;085439 & BUY      & 397      & 8.375  & -4         \\
DTEd   & DE0005557508 & 20130603;035843 & BUY      & 850      & 8.77   & -7.4545    \\
DTEd   & DE0005557508 & 20130516;062317 & SELL     & -27      & 9.92   & -4         \\
DTEd   & DE0005557508 & 20130516;062317 & SELL     & -870     & 9.92   & -4.89824   \\
FMEd   & DE0005785802 & 20130313;085049 & BUY      & 145      & 51.56  & -7.4762    \\
FREd   & DE0005785604 & 20121205;032954 & BUY      & 34       & 88     & -4         \\
FREd   & DE0005785604 & 20130313;085049 & BUY      & 37       & 95.22  & -4         \\
FREd   & DE0005785604 & 20130313;085049 & BUY      & 7        & 95.22  & -0.18968   \\
HEN3d  & DE0006048432 & 20121205;033430 & BUY      & 16       & 63.12  & -4         \\
HEN3d  & DE0006048432 & 20130313;085827 & BUY      & 97       & 72.68  & -7.04996   \\
LINd   & DE0006483001 & 20130131;040813 & BUY      & 22       & 134.5  & -4         \\
LINd   & DE0006483001 & 20130516;064910 & BUY      & 47       & 151.7  & -7.1299    \\
LINd   & DE0006483001 & 20130516;064910 & BUY      & 3        & 151.7  & -0.4551    \\
LINd   & DE0006483001 & 20130215;055430 & SELL     & -22      & 131.4  & -4         \\
MEOd   & DE0007257503 & 20130215;073839 & BUY      & 120      & 24.18  & -4         \\
MEOd   & DE0007257503 & 20130523;030909 & BUY      & 270      & 26.47  & -7.1469    \\
MEOd   & DE0007257503 & 20130313;050530 & SELL     & -120     & 21.13  & -4         \\
MRKd   & DE0006599905 & 20121205;035323 & BUY      & 20       & 102.6  & -4         \\
MRKd   & DE0006599905 & 20130313;085529 & BUY      & 45       & 113.85 & -5.12325   \\
SAPd   & DE0007164600 & 20121205;033158 & BUY      & 32       & 61.31  & -4         \\
SAPd   & DE0007164600 & 20130313;050537 & SELL     & -32      & 63.58  & -4         \\
SDFd   & DE000KSAG888 & 20130215;060200 & BUY      & 90       & 33.65  & -4         \\
SDFd   & DE000KSAG888 & 20130313;085047 & BUY      & 49       & 35.94  & -4         \\
SIEd   & DE0007236101 & 20121205;034614 & BUY      & 37       & 79.89  & -4         \\
SIEd   & DE0007236101 & 20130109;032510 & SELL     & -37      & 83.52  & -4         \\
\end{tabular}
\end{center}

<<>>=

@ 


We put this all into a journal \texttt{jnl}.



%% What is the current position?

%% <<>>=
%% position(jnl)
%% @


%% What was the positon in 15 January 2013, 11:00:00? 

%% <<>>=
%% position(J, when = as.POSIXct("2013-01-15 11:00:00"))
%% @


This suggests a mechanism to value a portfolio: decide \texttt{when}
to value the portfolio, then get prices for \texttt{when} and take the
inner product of the position at \texttt{when} with these prices.

We can also evaluate a portfolio between two points-in-time.


\section{Several accounts}



<<>>=
  trades <- read.table(textConnection(
      "account; ticker; timestamp; amount; price
  private ; A ; 1;   100; 60
  private ; A ; 2;   100; 70
  private ; A ; 3;  -200; 66
  longterm; A ; 1; 100; 60
  longterm; B ; 1; 100; 5"),
                       sep =";", header = TRUE,
                       strip.white = TRUE, 
                       stringsAsFactors = FALSE)
jnl <- journal(trades$timestamp, trades$amount,
             trades$price, NA, trades$ticker, trades$account)
jnl
@

But now we also have accounts.
<<>>=
table(jnl$account)
@ 

Per default, the function will compute the positions with regard of
account.  So here, we have asset \texttt{A} in account
\texttt{longterm} and in \texttt{private}.
<<>>=
position(jnl)
@

<<>>=
jnl2 <- jnl
jnl2$instrument <- paste0(jnl$account, ":", jnl$instrument)
jnl2
@ 

<<>>=
print(jnl2)
@ 

\section{Subsetting journals}





\chapter{Profit and (or) loss}

\section{The simple case}

Suppose we have an account denominated in euro.  We buy one asset at a
price of 100 euro and sell it again at 102 euro.  We have made a
profit of 2 euros.  This simple case happens often enough to make the
required computation simple as well.  Computing profit-or-loss can be
handled through the function \texttt{pl}.

<<>>=
pl(price  = c(100, 102), 
   amount = c(  1,  -1))
@
Suppose a trader bought 1 unit @ 50, 1 unit @ 90 and sold 2 units @
100.
<<>>=
pl(price  = c( 50, 90, 100), 
   amount = c(  1,  1,  -2))
@
But suppose that the actual order of the trades was\medskip

buy @ 90 \quad $\Rightarrow$ \quad buy @ 50 \quad $\Rightarrow$ \quad
sell @ 100\,.\medskip

\noindent Even if we know nothing about what was traded and when, some
information is provided by the order of the trades: the first position
of 1 unit had a realised drawdown of at least 40 before it recovered.
For situations like this, the argument \texttt{along.timestamp} can be
used. (Note that we do not provide an actual timestamp, in which case
the function will implictly use integers 1, 2, \ldots,
\texttt{length(amount)}\,.)

<<>>=
pl(price  = c( 90, 50, 100), 
   amount = c(  1,  1,  -2), along.timestamp = TRUE)
@ 

\noindent With no further arguments, the function will compute the
running position and evaluate it at every trade with the trade's
price.  This may not be accurate because of bid--ask spreads or other
transaction costs, but it provides more information than only
computing the profit/loss for the trades.


<<>>=
J <- journal(price     = c( 90, 50, 100), 
             amount    = c(  1,  1,  -2),
             timestamp = c(  2,  4,   7))
pl(J, along.timestamp = TRUE)
position(J, when = 1:10)
@ 


Suppose we also have a time series of the prices between time 1 and
time 10.  One of the most useful tools to look at what a trader did is
to evaluate the position at every time instant, and then plot
position, profit/loss and the traded instrument.



A more-useful example for pl with \texttt{along.timestamp} is a
trading history of a high-frequency strategy.  Suppose for example we
had traded EURUSD 200 times in single day and wished to plot the
result.  At such a frequency, the prices at which the trades were
executed can be useful to value any open position.



\section{More complicated cases}

Unfortunately, in real life computing profit/loss is often more
complicated:

\begin{itemize}

\item One asset-price unit may not translate into one currency unit:
  we have multipliers or contract factors.  That is easy to solve by
  computing effective position sizes, but it may take some thinking to
  come up with a reusable scheme (eg, looking up multipliers in a
  table).
    
\item Asset positions may map into cashflows in non-obvious ways.  The
  simple case is the delay in actual payment and delivery of an asset,
  which is often two or three days.  The more problematic cases are
  derivatives with daily adjustments of margins.

\item Assets may be denominated in various currencies.
  
\item Currencies themselves may be assets in the portfolio.  Depending
  on how they are traded (cash, forwards, \emph{\&c.}), computing
  profit/loss may not be straightforward.
\end{itemize}


TODO:

- example EUR investor buys INTC

- pure FX portfolio

\chapter{Analysing trades}

\section{Exposure}

We have the following trades and times.
<<>>=
amount <- c(1,3,-3,1,-3,1)
time <- c(0,1,3,4,7,12)
@ 
The holding period (\texttt{duration}) of these trades can be computed
so:
<<>>=
data.frame(position = cumsum(amount)[-length(amount)], 
           from = time[-length(time)],
           to   = time[-1L],
           duration = diff(time))
@ 

We can plot the exposure.
<<fig=true, height = 2, width = 5>>=
par(bty = "n", mar = c(4,4,0,0), tck = 0.005, las = 1, cex = 0.8)
plot(c(time[1L], time), cumsum(c(0, amount)), type = "s",
     xlab = "time", ylab = "position")
@ 
Thus, we have had a position from time zero to 12 (hours into the
trading day, say), but its size varied.  The function
\texttt{twExposure} (time-weighted exposure) computes the average
absolute exposure.
<<>>=
twExposure(amount, time)
@ 
To give a simple example: suppose we bought at the open of a trading
day and sold at noon.  The average exposure for the day is thus half a
contract.
<<>>=
amount <- c(1, -1 , 0)
time   <- c(0,0.5,1)
twExposure(amount, time)
@ 


\section{Splitting and rescaling}

Suppose we have the following trades and impose a limit that the
maximum absolute exposure for the trader should only be 2.

<<>>=
t <- 1:6
n <- c(-1,-1,-1,1,1,1)
p <- c(100,99,98,98,99,100)
limit(n, p, t, lim = 2)
@ 

Scaling the trades.
<<>>=
scaleToUnity(n)
@ 

Closing the trade at once.
<<>>=
closeOnFirst(n)
@



\section{Computing returns}

\subsection{Numeric data}
A vector.
<<>>=
x <- c(100,101,105)
returns(x)
@ 
A matrix.
<<>>=
X <- cbind(x,x,x)
returns(X)
@ 

\subsection{Time series}

<<>>=
x
t <- 1:3
returns(x, t)
@ 

\chapter{Backtesting}

\section{Introduction}

This chapter explains how to test trading strategies with the
\texttt{backtest} function.

\section{Decisions}

The current instant is time~$t$; in actual life, it's simply
`now'. We need to answer the following questions:
\begin{enumerate}
\item Do we want to compute a new target portfolio, yes or no? If yes,
  compute the new target portfolio.
\item Given the target portfolio and the actual portfolio, do we
  want to rebalance (ie, close the gap between the actual
  portfolio and the target portfolio)? If yes, rebalance.
\end{enumerate}

If such a decision is not just hypothetical, then the answer to
the second question may lead to a number of orders sent to a
broker. Note that many traders do not think in terms of
\emph{stock} (ie, balances) as we did here; rather, they think in
terms of \emph{flow} (ie, orders). Both approaches are
equivalent, but the described one makes it easier to handle
missed trades and synchronise accounts.

During a backtest, we will simulate the decisions of the trader.
How precisely we simulate depends on the trading strategy. The
\texttt{backtest} function is meant as a helper function to
simulate these decisions. The logic for the decisions described
above is coded in the functions \texttt{signalYN},
\texttt{signal} and \texttt{rebalanceYN}.

When we implement and use \texttt{backtest}, we need to make a
number of decisions: (i)~what to model (ie, how to simulate the
trader), and (ii)~how to code it. Example for (i): how precisely
do we want to model the order process (eg, use limit orders?
allow partial fills?) Example for~(ii): the backbone of
\texttt{backtest} is a loop that runs through the data. Loops are
slow in \textsf{R} when compared with compiled languages, so why
not vectorise? Vectorisation is indeed often possible, namely if
trading is not path-dependent. For instance, if we have a list of
trades, we can efficiently transform them into a profit-and-loss
in \textsf{R} without relying on an explicit loop. Yet, one
advantage of looping is that the trade logic is more similar to
actual trading; we may even be able to reuse some code in live
trading.

Altogether, the aim is to stick to the functional paradigm as
much as possible. Functions receive arguments and evaluate to
results; but they do not change their arguments, nor do they
assign or change other variables `outside' their environment, nor
do the results depend on some variable outside the function. This
creates a problem, of course: how to keep track of state? If we
know what variables need to be persistent, we could pass them
into the function and always return them. But we would like to be
more flexible, so we can pass an environment; examples are
below. But functional programming should not be seen as a
yes-or-no decision, but it is a matter of degree. And a bit more
of the functional approach can help already.

\section{Data}

We have one or several price series of length \texttt{T}. The
\texttt{backtest} function runs from \texttt{b + 1} to
\texttt{T}. The variable~\texttt{b} is the burnin,%
\marginpar{\texttt{b}\qquad burnin} %
and it needs to be a positive integer (in rare cases it may be
zero). In the simplest case (`no decision'), we could run a loop
without any action from \texttt{1:T} (with \texttt{b} equal to
zero). When we actually take decisions we will always lose at
least one data point.


At time \texttt{t}, we can make decision based on information up
to time \texttt{t - 1}. Suppose that \texttt{t} was 4. We may use
all information up to time 3, and trade at the \texttt{open} in
period 4.

%TODO create nice display

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS    X                        <- trade here
5    HH:MM:SS
\end{verbatim}

We could also trade at the \texttt{close}.

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS                       X     <-- trade here
5    HH:MM:SS
\end{verbatim}


(No, we cannot trade at the high or low. But perhaps we could add
this later as a robustness check -- always buy at the high, sell
at the low.)

\section{Functions}\label{functions}

\texttt{backtest} expects a number of functions. The default is to not
specify arguments to these functions, because they can all access the
following objects. These objects are themselves functions that can
access certain data; there are no replacement functions.

\begin{description}
\item[Open] access open prices
\item[High] access high prices
\item[Low] access low prices
\item[Close] access close prices
\item[Wealth] the total wealth (cash plus positions) at a given
  point in time
\item[Cash] cash (in accounting currency)
\item[Time] current time (an integer)
\item[Portfolio] the current portfolio
\item[SuggestedPortfolio] the currenly-suggested portfolio
\item[Globals] an environment
\end{description}

All the functions have the argument \texttt{lag} which defaults
to \texttt{1}.

\subsection{signal}

The \texttt{signal} function uses information until \texttt{t -
  1} and returns the suggested portfolio (a vector) to be held at
\texttt{t}.

\subsection{signalYN}

\texttt{signalYN} uses information until \texttt{t - 1} and must
return \texttt{TRUE} or \texttt{FALSE}. If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{rebalanceYN}

\texttt{rebalanceYN} uses information until \texttt{t - 1} and
returns \texttt{TRUE} or \texttt{FALSE}. If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{printInfo}

The function is called at the end of an iteration. It should not
return anything but is called for its side effect: print
information to the screen, into a file or into some other
connection.


\section{Single assets}

It is best to describe the \texttt{backtest} function through a number
of simple examples.


\subsection{A useless first example}

I really like simple examples. Suppose we have a single
instrument, and we use only close prices. The trading rule is to
buy, and then to hold forever. All we need is the time series of
the prices and the signal function. To keep this example (and
also those that follow) simple, we use an artificial series.
<<>>=
prices <- c(100,98,98,97,101,102,101,98,99,101)
@
The \texttt{signal} function is very simple indeed.
<<>>=
signal <- function()
    1
@

\texttt{signal} must be written so that it returns the suggested
portfolio (or position) in units of the asset. In this first
example, the suggested position always is one unit. (It is only a
\texttt{suggested} portfolio because we can specify rules whether
or not to trade. Examples follow below.)

So \texttt{signal} always recommends to hold one unit of the
asset. To test this strategy, we call \texttt{backtest}. The
initial cash is 100 (per default). We can change it through the
argument \texttt{c0}.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal)
@

The function returns a list with a number of components. We
display the results in a \texttt{data.frame}. \texttt{Xs} is the
suggested portfolio; \texttt{X} is the actual portfolio.

<<>>=
makeTable <- function(solution, prices)
    data.frame(prices = prices,
               p     = solution$portfolio,
               sp      = solution$suggested.portfolio,
               wealth = solution$wealth,
               cash   = solution$cash)

makeTable(solution, prices)
@

We bought in the second period because the default setting for
the burnin \texttt{b} is 1; thus, we lose one observation.

Since we do not rely in any way on the past in this trading rule,
we set \texttt{b} zo zero. With this setting, we buy at the first
price and hold until the end of the data.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b  = 0)
makeTable(solution, prices)
solution$trades
@


\subsection{A more useful first example}

Now we make our strategy slightly more selective. The trading
rule is to buy whenever the last observed price is below 100, and
sell when it is above. The signal function could look like this.
<<>>=
signal <- function()
    if (Close() < 100)
        1 else 0
@

We call \texttt{backtest}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

The argument \texttt{x0} specifies the initial position. (Default
is no position.) Suppose we had already held one unit of the
asset.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 1,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

Internally, \texttt{backtest} stores \textsc{ohlc} prices in matrices.
So even for a single instrument we have four matrices, and each matrix has
one column. If we were dealing with two assets, we would again have
four matrices, each with two columns. And so on.

%% TODO: add picture of matrices

We do not access these data directly. \texttt{Close} is a
function that is defined in \texttt{backtest}, and which is
passed as an argument to \texttt{signal}. Note that we do not add
it as a formal argument to \texttt{signal} since this is done
automatically (in fact, doing it manually would trigger an error
message):
<<>>=
##signal <- function(Close = NULL)
##    1
1
##cat(try(backtest(prices = prices, signal = signal)))
@

Similarly, we have functions \texttt{Open}, \texttt{High} and
\texttt{Low} (see Section~\ref{functions} above for a available
functions).

Suppose we wanted to add a variable, like a \texttt{threshold}
that tells us when to buy. This would need to be an argument to
\texttt{signal}; but it would also need to be passed with the
\texttt{\dots} argument of \texttt{backtest}.
<<>>=
signal <- function(threshold)
    if (Close() < threshold)
        1 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     threshold = 98,  ## buy if price < threshold
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

So far we have treated \texttt{Close} as a function without arguments,
but actually it has an argument \texttt{lag} that defaults to
\texttt{1}. Suppose the rule were to buy if the last close is below the
second-to-last close. \texttt{signal} could look like this.
<<>>=
signal <- function()
    if (Close(1L) < Close(2L))
        1 else 0
@

We could also have written \texttt{(Close() < Close(2L))}. We need to
increase \texttt{b}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b = 2,           ## increase burnin
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash
makeTable(solution, prices)
@

If we wanted to trade any other size, we would change our signal as
follows.
<<>>=
signal <- function()
    if (Close() < 100)
        2 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

A typical way to specify a trading strategy is to map past prices into
\texttt{+1}, \texttt{0} or \texttt{-1} for long, flat or short. A
signal is often only given at a specified point (like in `buy one unit
now'). Example: suppose the third day is a Monday, and our rule says
`buy after Monday'.
<<>>=
signal <- function()
    if (Time() == 3)
        1 else 0
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

But this is probably not what we wanted. If the rule is to
buy and stay long, we should have written it like this.
<<>>=
signal <- function()
    if (Time() == 3L)
        1 else Portfolio()
@

The function \texttt{Portfolio} returns last period's
portfolio. Like \texttt{Close}, it takes an argument \texttt{lag}
that defaults to one.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ### initial position
                     c0 = 100)        ### initial cash

makeTable(solution, prices)
@




\subsubsection{Signals (\texttt{+1}, \texttt{0}, \texttt{-1}) to
  fixed number of units}

Suppose we prefer to write rules in terms of \texttt{+1}, \texttt{0},
\texttt{-1}. Then there are a number of settings that help to
translate such signals into holdings. \texttt{backtest} takes an
argument \texttt{adjustSignal} which controls this behaviour. Its
default is \texttt{NULL} (do nothing).

If we use \texttt{fixedPosition} and specify the argument
\texttt{positionSize}, the algorithm will translate any signal
into \texttt{positionSize} \texttimes{} \texttt{signal}.

<<>>=
signal <- function()
    if (Close() < 100)
        1 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,
                     c0 = 100,
                     adjustSignal = "fixedPosition",
                     positionSize = 5)

makeTable(solution, prices)
@

This can be useful when we have an original series of zeros and
ones (eg, following some technical indicator).

<<>>=
givenPositions <- c(0, -1, -1, 0, 1, 1, -1, 0, -1, -1)

signal <- function(givenPositions)
    givenPositions[Time()]

## fixed position size in units
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)

cbind(makeTable(solution, prices), givenPositions)
@

Note again the timelag: we can never trade at the same time instant in
which we compute a signal.

But if you really think there should be no timelag, you could write
<<>>=
signal <- function(givenPositions)
    givenPositions[Time(0L)]

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)
cbind(makeTable(solution, prices), givenPositions)
@

What if we had had a signal in the first period?
<<>>=
givenPositions <- c(1, 0, -1, 0, 1, 1, -1, 0, -1, -1)
@


<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b = 0,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)
cbind(makeTable(solution, prices), givenPositions)
@

\subsubsection{Signals (\texttt{+1}, \texttt{0}, \texttt{-1}) to fixed weight}

%% TODO: check -- anything pos becomes pos weight, anything neg
%% becomes nec weight?

Suppose we want to hold a constant weight in an asset. (Note that
that to keep the weight constant we will -- under the current
settings -- rebalance in every period.)

<<>>=
## fixed position size in %
signal <- function()
    if (Close() < 100)
        3 else 0
solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 0.2)
makeTable(solution, prices)

signal <- function()
    if (Close() < 100)
        -1.2 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 0.2)

makeTable(solution, prices)

@

To be fully invested, set \texttt{positionSize} to \texttt{1}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 1)

makeTable(solution, prices)

@


A more common scenario is probably that \texttt{signal} gives a
weight; for instance, after a portfolio optimisation.
<<>>=
signal <- function()
    if (Close() < 100)
        0.05 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight")
makeTable(solution, prices)
@

Again, we get a weight and now rebalance in every period. Suppose
we do not want that.
<<>>=
signal <- function()
    if (Close() < 100)
        0.05 else 0

rebalanceYN <- function() {
    if (sum(abs(SuggestedPortfolio(0) - SuggestedPortfolio())) > 0.02)
        TRUE else FALSE
}

solution <- backtest(prices = prices,
                     signal = signal,
                     rebalanceYN = rebalanceYN,
                     adjustSignal = "weight")

makeTable(solution, prices)
@

A numerical analyst would rather put a tolerance that is more
closely related to the machine precision. I prefer using meaningful
tolerance: having invested less than one cent means we are not
invested.

Note also that with weights, we cannot exactly specify the number of
assets we buy or sell because we do not know the price at which we
trade. Practically, this does not matter.

\subsubsection{Passing environments}
To keep information persistent, we can use environments
<<>>=
external <- new.env()
external$vec <- numeric(length(prices))
signal <- function(threshold, external) {
    external$vec[Time()] <- Close()
    if (Close() < threshold)
        1 else 0
}

solution <- backtest(prices = prices,
                     signal = signal,
                     threshold = 100,
                     external = external)

cbind(makeTable(solution, prices), external$vec)
@

\section{Multiple assets}


\subsection{Again, a simple example}

<<>>=
prices1 <- c(100,98, 98, 97, 96, 98,97,98,99,101)
prices2 <- c(100,99,100,102,101,100,96,97,95,82)
prices <- cbind(prices1, prices2)

signal <- function()
    if (Close()[1L] > Close()[2L])
        c(1, 0) else c(0, 1)


(solution <- backtest(prices = list(prices),
                     signal = signal,
                      b=2))
@

We can also give more useful names to the assets.
<<>>=
prices <- cbind(AA = prices1, BB = prices2)
solution <- backtest(prices = list(prices),
                               signal = signal, b=2)
makeTable(solution, prices)

@



\section{Common tasks}
There are many ways to do the same thing. I describe how I have
handled some specific tasks.

\subsection{Remembering an entry price}
In signal: use the current price and assign in \texttt{Globals}.

\subsection{Delaying signals}

\subsection{Losing signals}

\subsection{Writing a log}
<<>>=
prices <- c(100,98,98,97,101,102,101,98,99,101)

signal <- function()
    if (Close() < 100)
        1 else 0

printInfo <- function() {
    cat("period",
        sprintf("%2d", Time(0L)), "...",
        sprintf("%3d", Wealth(0)), "\n")
    flush.console()
}

solution <- backtest(prices = prices,
                     printInfo = printInfo,
                     signal = signal)

makeTable(solution, prices)

@
And since \texttt{cat} has a \texttt{file} argument, we can also write
such information into a logfile.





\chapter{Reporting}

\section{Text tools}

In many cases, reporting simply means constructing a message text that
is printed on a terminal or sent as an email.

\subsection{rmspace}

<<>>=
s <- c(" a a", " 19 EUR ")
rmspace(s)
@ 

\subsection{char2num}

<<>>=
char2num("12.000,23")
char2num("12,000.23", big.mark = ",")
char2num("12000.23",  big.mark = " ") ## but 'as.numeric' is simpler
char2num("12'000.23", big.mark = "'")
char2num("12 000|23", dec = "|", big.mark = " ")
@ 

\subsection{expstring}
Expand a string

<<>>=
s <- c("profits: 100 EUR", "fees:  20 EUR")
cat(s, sep = "\n")
s <- expstr(s, after = ": ", width = 20)
cat(s, sep = "\n")
nchar(s)  ## width
@ 

\section{qpTable}

quartile plot table

\section{slTable}

sparkline table

arguments:
\begin{itemize}
\item \ldots : zoo objects
\item include.returns
\item include.diffs
\item compute.with = "returns": or "diffs" or "levels"
\item columns = list(mean = mean, sd = sd): need to be computed on returns
\end{itemize}



\chapter{Technical indicators}

sum, abssum, sd, absmean, range, minmax, minmaxrange, mad





\appendix
\chapter{Design}

\section{Requirements}

\begin{itemize}
\item Store a 'portfolio' of assets and compute the value (or other
  quantities, like Greeks) for different data.  Data can refer to
  market prices, but also to theoretical prices.
\item Reevaluate a portfolio for scenario (= new market data or
  artificial data).
\item Read in transactions from various sources. $\to$ done via a
  journal class.
\item Show portfolio on certain day/time: create a position, evaluate
  this position $\to$ position class
\item testing portfolios of options --> show payoff, simulate *paths*
  of underlier and vol surface
\item run simulations for VaR
\item various ways to compute pnl: weighted average,
  first-in-first-out and last-in-last-out
\end{itemize}


\section{Classes}

The following classes are implicitly defined (ie, S3 classes):

\begin{itemize}
\item journal: keeps transactions
\item Position: only for printing. It comprises the numerical
  positions of different accounts/instruments, the timestamps and the
  description of the instruments.
\item Instrument: term sheet (description etc); it does know nothing
  about market data
\item Cashflow: internal
\item Timeseries: internal
\end{itemize}

\section{Valuation}

Valueing a position can mean two things: compute theoretical prices,
or market prices.

Theoretical valuation takes places via the generic function value:

\texttt{value(x, ..., dots2args = NULL) } 

The simplest case:
\texttt{x} is character, then a call will be generated as

\texttt{do.call(x, list(...))}

\texttt{dots2args.default <- function(x, ...) list(...)}

Note that this will be the default method; notably, a method when
\texttt{x} is character will be left unspecified (meant for the user).


A more typical case: collect all market data in a list \texttt{Data}:
EvaluationDate, Prices, Vols, Irates.

dots2args will react on \texttt{x}, retrieve the required information,
and 



\begin{itemize}
\item evaluates to list \texttt{"value"}, \texttt{"delta"} etc
\item \texttt{Instrument[names(result)] <- result}
\end{itemize}


%% <<>>=
%% Time   <- as.Date("2013-05-28")
%% Prices <- list(DAX = 8472)
%% Irates <- list(EUR = function(t) 0.1)
%% Vols   <- list(DAX = function(x,t) 0.2)

%% DATA <- list(Time = Time, 
%%              Prices = Prices, 
%%              IRates = Irates, 
%%              Vols = Vols)
%% DATA
%% DATA$Vols$DAX(8000, 0.2)
%% DATA$IRates$EUR(0.5)

%% @      


\section{Instruments and portfolios}



\subsubsection{Instrument}

classes: Fund Equity Account Currency Future Index


%% fields:

%% id
%% isin
%% description
%% underlier
%% expirydate
%% expirytime
%% strike
%% type c/p
%% exercise e/a
%% pricing premium/future
%% class

\section{Vectorisation}

Functions should do vectorisation when they have to.  Example:
drawdown is interally computed through \texttt{cumsum}, so even for a
matrix of time series, it would need a loop.  This should be left to
the user. 

The exception is when computations can be accelerated.

\chapter{Frequently-used functions}

\begin{framed}
  \emph{\noindent I need to value a financial instrument.}
\end{framed}

\begin{framed}
  \emph{I have a list of trades (bought or sold what, when and at what
    price) and I need to compute the profit or loss.}
\end{framed}

\begin{framed}
  If all trades are closed (ie, the current positions are all zero),
  use \texttt{pl}.
\end{framed}

\begin{framed}
  \emph{I have a list of trades in an instrument and want to plot
    these trades against the price of the traded instrument.}
\end{framed}

\begin{framed}
  \emph{I have a signal series (\texttt{+1}, \texttt{0}, \texttt{0},
    \texttt{+1}, \ldots{}) and need to transform it into a
    profit-and-loss series.}
\end{framed}

\begin{framed}
  \emph{I have a list of trades and need to determine the
    profit-and-loss between two timestamps.}
\end{framed}

Call the two timestamps \texttt{t0} and \texttt{t1}.  Unless the
position was zero at t0 and t1, we can compute the profit/loss only if
we have prices for the positions at these points in time.  In case the
position was indeed zero, you can use \texttt{pl}; the transactions
are stored in a journal \texttt{j}.

<<eval=false>>=
subset(j, timestamp >= t0 & timestamp <=t1)
@

But even the more general case is not so complicated, after all.

\begin{enumerate}
\item Compute the position at \texttt{t0} and make it a journal j0.

\item Take all transactions at $t > t_\mathrm{0}$ and $t \leq
   t_\mathrm{1}$ and put them into a journal $J$.

\item Compute the position at $t_\mathrm{1}$, and make it a journal
   $J_1$, but \emph{multiply all amounts by $-1$}.

\item Combine $J_0$, $J$, and $J_1$ and compute the PL.
\end{enumerate}

\begin{framed}
  \emph{I need to determine the month-to-date profit-and-loss.}
\end{framed}

1) compute position on last day of last month

2) make journal from position (add prices)

3) combine with journal since month start

4) use average (\texttt{avg}) on all instruments


\printindex
\bibliographystyle{plainnat}
\bibliography{bibliothek}

\end{document}


%\#\# journal.cli(J, \ldots{})
%\#\#while (input != "exit") \{
%\#\#  input <- readline()
%\#\#  \#\# parse me
%\#\#\}
