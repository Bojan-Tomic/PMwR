% \VignetteIndexEntry{Backtesting}
\documentclass[a4paper,11pt]{book}
\usepackage[left = 2.5cm, top = 2cm, bottom = 3cm, right = 3.5cm]{geometry}
\usepackage[noae,nogin]{Sweave}
\usepackage{mathptmx}
\usepackage{amsmath,amstext}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{textcomp}
\SweaveOpts{keep.source = TRUE, eps = TRUE, pdf = FALSE}


\begin{document}
{\raggedright{\Large The \texttt{backtest} function}}\medskip

\noindent Enrico Schumann\\
\noindent \texttt{es@enricoschumann.net}\\
\bigskip



\chapter{Journals}

\section{Transactions}

The basis for many computations in the PMwR package are lists of
transactions which, conceptually, are nothing more than dataframes.
\texttt{PMwR} provides an S3 class \texttt{journal} for handling such
transaction data.  A \texttt{journal} is created through the function
\texttt{journal}, but it is really just a list of atomic vectors with
a class attribute.  Methods should not rely on the names of these
vectors being sorted in any particular way; that is, components of a
journal should always be retrieved by name, never by position.

The simplicity of the class is intended, as it is mostly used in
interactive analyses.  Thus, the user is supposed to dissect the
information at will (which includes removing the class attribute).

What is actually stored in a \texttt{journal} is up to the user, but a
few fields are typical (and required for several methods):

\begin{description}

\item[{timestamp}] anything that can be sorted (and that fits into an
  atomic vector: POSIXlt is possible, but not recommended);

\item[{amount}] notional amount that is transferred;

\item[{price}] price;

\item[{id}] (possibly unique) id;

\item[{instrument}] description of the financial instrument;

\item[{account}] description of the account;

\item[{\ldots{}}] other fields. They must be named, for instance like
  in \texttt{fees = c(1,2,1)}
\end{description}

Transactions are considered to be in a hierachy
\begin{verbatim}
<account>::<instrument>
\end{verbatim}
but currently there is little to use the hierarchy.  A simple scheme
is to use specific character or pattern to separate more accounts,
such as
\begin{verbatim}
pension::equities
\end{verbatim}




\section{A first example}

Suppose you kept track of a bank account.

<<>>=
require("PMwR")
when   <- as.Date("2012-01-01") + 0:3
amount <- c(1,2,-2,5) 
J <- journal(timestamp = when, amount = amount)
J 
@

The \texttt{position} function gives the current balance of an account.

<<>>=
position(J)
@

Let us do some more finance-style transactions.  We buy five times one
unit of some unspecified asset.

<<>>=
j1 <- journal(timestamp = 1:5, 
               amount = 1, 
               price = c(2,2,2,3,4), 
               account = "my account")
j1
@



Now we close the trade.

<<>>=
j2 <- journal(timestamp  =  6, 
               amount    = -5, 
               price     =  3, 
               account   = "my account")
@

To compute the profit or loss, we first concatenate the two lists.

<<>>=
j <- c(j1, j2)
j
@

Since the position is now zero, it is easy to compute the
profit/loss.  We can use the function \texttt{pl}.  

<<>>=
pl(j)
@



\section{A more complicated example.}

<<>>=
tr <- readLines("~/Desktop/trades.org")
tr <- strsplit(tr, "\\|")

@ 

\begin{center}
\begin{tabular}{llllrrr}
Symbol & ISIN         & Date/Time       & Buy/Sell & Quantity & Price  & Commission \\
\hline
BEId   & DE0005200000 & 20121205;031737 & BUY      & 49       & 60.45  & -4         \\
BEId   & DE0005200000 & 20130313;085611 & BUY      & 58       & 69.55  & -4.0339    \\
DB1d   & DE0005810055 & 20130611;033824 & BUY      & 100      & 49.115 & -4.9115    \\
DTEd   & DE0005557508 & 20121205;032202 & BUY      & 313      & 8.6    & -4         \\
DTEd   & DE0005557508 & 20130204;112639 & BUY      & 187      & 8.854  & -4         \\
DTEd   & DE0005557508 & 20130313;085439 & BUY      & 397      & 8.375  & -4         \\
DTEd   & DE0005557508 & 20130603;035843 & BUY      & 850      & 8.77   & -7.4545    \\
DTEd   & DE0005557508 & 20130516;062317 & SELL     & -27      & 9.92   & -4         \\
DTEd   & DE0005557508 & 20130516;062317 & SELL     & -870     & 9.92   & -4.89824   \\
FMEd   & DE0005785802 & 20130313;085049 & BUY      & 145      & 51.56  & -7.4762    \\
FREd   & DE0005785604 & 20121205;032954 & BUY      & 34       & 88     & -4         \\
FREd   & DE0005785604 & 20130313;085049 & BUY      & 37       & 95.22  & -4         \\
FREd   & DE0005785604 & 20130313;085049 & BUY      & 7        & 95.22  & -0.18968   \\
HEN3d  & DE0006048432 & 20121205;033430 & BUY      & 16       & 63.12  & -4         \\
HEN3d  & DE0006048432 & 20130313;085827 & BUY      & 97       & 72.68  & -7.04996   \\
LINd   & DE0006483001 & 20130131;040813 & BUY      & 22       & 134.5  & -4         \\
LINd   & DE0006483001 & 20130516;064910 & BUY      & 47       & 151.7  & -7.1299    \\
LINd   & DE0006483001 & 20130516;064910 & BUY      & 3        & 151.7  & -0.4551    \\
LINd   & DE0006483001 & 20130215;055430 & SELL     & -22      & 131.4  & -4         \\
MEOd   & DE0007257503 & 20130215;073839 & BUY      & 120      & 24.18  & -4         \\
MEOd   & DE0007257503 & 20130523;030909 & BUY      & 270      & 26.47  & -7.1469    \\
MEOd   & DE0007257503 & 20130313;050530 & SELL     & -120     & 21.13  & -4         \\
MRKd   & DE0006599905 & 20121205;035323 & BUY      & 20       & 102.6  & -4         \\
MRKd   & DE0006599905 & 20130313;085529 & BUY      & 45       & 113.85 & -5.12325   \\
SAPd   & DE0007164600 & 20121205;033158 & BUY      & 32       & 61.31  & -4         \\
SAPd   & DE0007164600 & 20130313;050537 & SELL     & -32      & 63.58  & -4         \\
SDFd   & DE000KSAG888 & 20130215;060200 & BUY      & 90       & 33.65  & -4         \\
SDFd   & DE000KSAG888 & 20130313;085047 & BUY      & 49       & 35.94  & -4         \\
SIEd   & DE0007236101 & 20121205;034614 & BUY      & 37       & 79.89  & -4         \\
SIEd   & DE0007236101 & 20130109;032510 & SELL     & -37      & 83.52  & -4         \\
\end{tabular}
\end{center}

<<>>=

@ 


We put this all into a journal \texttt{J}.


<<eval=false>>=
J <- journal(timestamp = c(as.POSIXct(trades$Date.Time,
                                      format = "%Y%m%d;%H%M%S",
                                      tz = "America/New_York")),
                 amount = trades$Quantity,
                  price = trades$Price,
             instrument = tolower(trades$ISIN),
                    fee = trades$Commission,
                 ticker = trades$Symbol)

J
@




What is the current position?

\begin{verbatim}
position(J)
@


What was the positon in 15 January 2013, 11:00:00? 

\begin{verbatim}
position(J, when = as.POSIXct("2013-01-15 11:00:00"))
@


This suggests a mechanism to value a portfolio: decide \texttt{when} to value
the portfolio, then get prices for \texttt{when} and take the inner product
of the position at \texttt{when} with these prices.

We can also evaluate a portfolio between two points-in-time.

\begin{verbatim}
t0 <- as.POSIXct("2013-05-31 17:30:00")
t1 <- as.POSIXct("2013-06-10 17:30:00")

##insts <- sort(unique(J$instrument))
##prices0 <- closePrice(insts, "daily", date = t0)
##prices1 <- closePrice(insts, "daily", date = t1)

prices0 <- structure(c(69.53, 8.838, 91.48, 52.4, 49.79, 74.6, 148.05,
                       122.25, 58.03, 81.61, 26.33, 32.51),
                     .Names =
                     c("de0005200000", "de0005557508", "de0005785604",
                       "de0005785802", "de0005810055", "de0006048432",
                       "de0006483001", "de0006599905", "de0007164600",
                       "de0007236101", "de0007257503", "de000ksag888"))


prices1 <- structure(c(68.58, 8.975, 93.15, 53.15, 49.415, 74.99,
                       146.2, 124.05, 58.39, 81.09, 26.225, 30.445),
                     .Names =
                     c("de0005200000", "de0005557508", "de0005785604",
                       "de0005785802", "de0005810055", "de0006048432",
                       "de0006483001", "de0006599905", "de0007164600",
                       "de0007236101", "de0007257503", "de000ksag888"))

PMwR:::plPeriod(J, t0,t1, prices0, prices1)
@

\section{Several accounts}
\label{sec-2-5}


\begin{verbatim}
  trades <- read.table(textConnection(
      "account; ticker; timestamp; amount; price
  private ; A ; 1;   100; 60
  private ; A ; 2;   100; 70
  private ; A ; 3;  -200; 66
  longterm; A ; 1; 100; 60
  longterm; B ; 1; 100; 5"),
                       sep =";", header = TRUE,
                       strip.white = TRUE, 
                       stringsAsFactors = FALSE)
J <- journal(trades$timestamp, trades$amount,
             trades$price, NA, trades$ticker, trades$account)
J
@


But now we also have accounts.

\begin{verbatim}
J$account
@

Per default, the function will compute the positions per account
(which is equivalent to setting \texttt{aggr.accounts} to FALSE).  So here,
we have asset \texttt{A} in account \texttt{longterm} and in \texttt{private}.

\begin{verbatim}
position(J)
@


\begin{verbatim}
position(J, aggr.accounts = FALSE)
@


\begin{verbatim}
position(J, aggr.accounts = TRUE)
@



\#\# journal.cli(J, \ldots{})
\#\#while (input != "exit") \{
\#\#  input <- readline()
\#\#  \#\# parse me
\#\#\}


\chapter{Profit and (or) loss}

\section{The simple case}

Suppose we have an account denominated in euro.  We buy one asset at a
price of 100 euro and sell it again at 102 euro.  We have made a
profit of 2 euros.

This simple cape happens often enough to make the required computation
simple as well.  Computing profit-or-loss can be handled through the
function \texttt{pl}.

<<>>=
pl(price  = c(100, 102), 
   amount = c(  1,  -1))
@

Suppose a trader bought 1 unit @ 50, 1 unit @ 90 and sold 2 units @
\begin{enumerate}
\item It is easy enough to compute the profit for these trades.
\end{enumerate}

<<>>=
pl(price  = c( 50, 90, 100), 
   amount = c(  1,  1,  -2))
@

\noindent But suppose that the actual order of the trades was

buy @ 90 \quad $\Rightarrow$ \quad buy @ 50 \quad $\Rightarrow$ \quad
sell @ 100$\backslash$,.

\noindent Even if we know nothing about what was traded and when, some
information is provided by the order of the trades: the first position
of 1 unit had a realised drawdown of at least 40 before it recovered.
For situations like this, the argument \texttt{along.timestamp} can be
used. (Note that we do not provide an actual timestamp, in which case
the function will implictly use integers 1, 2, \ldots,
\texttt{length(amount)}$\backslash$,.)

<<>>=
pl(price  = c( 90, 50, 100), 
   amount = c(  1,  1,  -2), along.timestamp = TRUE)
@ 

\noindent With no further arguments, the function will compute the
running position and evaluate it at every trade with the trade's
price.  This may not be accurate because of bid--ask spreads or other
transaction costs, but it provides more information than only
computing the profit/loss for the trades. 


<<>>=
J <- journal(price     = c( 90, 50, 100), 
             amount    = c(  1,  1,  -2),
             timestamp = c(  2,  4,   7))
pl(J, along.timestamp = TRUE)
position(J, when = 1:10)
@ 


Suppose we also have a time series of the prices between time 1 and
\begin{enumerate}
\item That is useful to figure what has happened.  So now we have to
\end{enumerate}
evaluate the position at every time instant.


<<>>=
P <- c(100,90,40,50,60,84,100,120,100,90)
T <- seq_along(P)
## PLsorted(J$amount, J$price, timestamp = J$timestamp,
##          allprices = P, alltimes = T,
##          initcash = 500)

p <- position(J, when = 1:11)
pl(J, initcash = 500, along.timestamp = TRUE)

##mvalue.position(J, when, series)

@

A more-useful example for pl with \texttt{along.timestamp} is a
trading history of a high-frequency strategy.  Suppose for example we
had traded EURUSD 200 times in single day and wished to plot the
result.  At such a frequency, the prices at which the trades were
executed can be useful to value any open position. 



\section{More complicated cases}

Unfortunately, in real life computing PL is often more complicated:

\begin{itemize}
\item One asset-price unit may not translate into one currency unit:
  we multipliers or contract factors.

\item Asset positions may map into non-trivial cashflows.  The simple
  case would be the delay in actual payment and delivery of an asset;
  but the more problematic cases are derivatives with daily
  adjustments of margins.

\item Assets may be denominated in various currencies.
  
\item Currencies may be assets in the portfolio.  Depending on how
  they are traded (cash, forwards, \texttt{\&c.}), computing PL may
  not be simple.
\end{itemize}

\chapter{Analysing trades}

\section{Exposure}

We have the following trades and times.

<<>>=
amount <- c(1,3,-3,1,-3,1)
time <- c(0,1,3,4,7,12)
@ 

The holding period (\texttt{duration}) of these trades can be computed
so:
<<>>=
data.frame(position = cumsum(amount)[-length(amount)], 
           from = time[-length(time)],
           to   = time[-1L],
           duration = diff(time))
@ 

We can plot the exposure.
\label{fig-true-height-2-width-5}=
par(bty = "n", mar = c(4,4,0,0), tck = 0.005, las = 1, cex = 0.8)
plot(c(time[1L], time), cumsum(c(0, amount)), type = "s",
     xlab = "time", ylab = "position")
@ 

\noindent Thus, we have had a position from time zero to 12 (hours, say), but
its size varied.  The function \texttt{twExposure} (time-weighted
exposure) computes the average absolute exposure.

<<>>=
twExposure(amount, time)
@ 

\noindent To give a simple example: suppose we bought at the open of a
trading day and sold at noon.  The average exposure for the day is
thus half a contract.

<<>>=
amount <- c(1, -1 , 0)
time   <- c(0,0.5,1)
twExposure(amount, time)
@ 


\section{Splitting and rescaling}

Suppose we have the following trades and impose a limit that the
maximum absolute exposure for the trader should only be 2.

<<>>=
t <- 1:6
n <- c(-1,-1,-1,1,1,1)
p <- c(100,99,98,98,99,100)
limit(n, p, t, lim = 2)
@ 

Scaling the trades.
<<>>=
scaleToUnity(n)
@ 

Closing the trade at once.
<<>>=
closeOnFirst(n)
@






\chapter{Backtesting}

\section{Introduction}

This vignette explains how to backtest trading strategies with
the \texttt{backtest} function.

\section{Decisions}

The current instant is time~$t$; in actual life, it's simply
`now'. We need to answer the following questions:
\begin{enumerate}
\item Do we want to compute a new target portfolio, yes or no? If yes,
  compute the new target portfolio.
\item Given the target portfolio and the actual portfolio, do we
  want to rebalance (ie, close the gap between the actual
  portfolio and the target portfolio)? If yes, rebalance.
\end{enumerate}

If such a decision is not just hypothetical, then the answer to
the second question may lead to a number of orders sent to a
broker. Note that many traders do not think in terms of
\emph{stock} (ie, balances) as we did here; rather, they think in
terms of \emph{flow} (ie, orders). Both approaches are
equivalent, but the described one makes it easier to handle
missed trades and synchronise accounts.

During a backtest, we will simulate the decisions of the trader.
How precisely we simulate depends on the trading strategy. The
\texttt{backtest} function is meant as a helper function to
simulate these decisions. The logic for the decisions described
above is coded in the functions \texttt{signalYN},
\texttt{signal} and \texttt{rebalanceYN}.

When we implement and use \texttt{backtest}, we need to make a
number of decisions: (i)~what to model (ie, how to simulate the
trader), and (ii)~how to code it. Example for (i): how precisely
do we want to model the order process (eg, use limit orders?
allow partial fills?) Example for~(ii): the backbone of
\texttt{backtest} is a loop that runs through the data. Loops are
slow in \textsf{R} when compared with compiled languages, so why
not vectorise? Vectorisation is indeed often possible, namely if
trading is not path-dependent. For instance, if we have a list of
trades, we can efficiently transform them into a profit-and-loss
in \textsf{R} without relying on an explicit loop. Yet, one
advantage of looping is that the trade logic is more similar to
actual trading; we may even be able to reuse some code in live
trading.

Altogether, the aim is to stick to the functional paradigm as
much as possible. Functions receive arguments and evaluate to
results; but they do not change their arguments, nor do they
assign or change other variables `outside' their environment, nor
do the results depend on some variable outside the function. This
creates a problem, of course: how to keep track of state? If we
know what variables need to be persistent, we could pass them
into the function and always return them. But we would like to be
more flexible, so we can pass an environment; examples are
below. But functional programming should not be seen as a
yes-or-no decision, but it is a matter of degree. And a bit more
of the functional approach can help already.

\section{Data}

We have one or several price series of length \texttt{T}. The
\texttt{backtest} function runs from \texttt{b + 1} to
\texttt{T}. The variable~\texttt{b} is the burnin,%
\marginpar{\texttt{b} burnin} %
and it needs to be a positive integer (in rare cases it may be
zero). In the simplest case (`no decision'), we could run a loop
without any action from \texttt{1:T} (with \texttt{b} equal to
zero). When we actually take decisions we will always lose at
least one data point.


At time \texttt{t}, we can make decision based on information up
to time \texttt{t - 1}. Suppose that \texttt{t} was 4. We may use
all information up to time 3, and trade at the \texttt{open} in
period 4.

%TODO create nice display

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS    X                        <- trade here
5    HH:MM:SS
@

We could also trade at the \texttt{close}.

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS                       X     <-- trade here
5    HH:MM:SS
@

(No, we cannot trade at the high or low. But perhaps we could add
this later as a robustness check -- always buy at the high, sell
at the low.)

\section{Functions}\label{functions}

\texttt{backtest} expects a number of functions. The default is to not
specify arguments to these functions, because they can all access the
following objects. These objects are themselves functions that can
access certain data; there are no replacement functions.

\begin{description}
\item[Open] access open prices
\item[High] access high prices
\item[Low] access low prices
\item[Close] access close prices
\item[Wealth] the total wealth (cash plus positions) at a given
  point in time
\item[Cash] cash (in accounting currency)
\item[Time] current time (an integer)
\item[Portfolio] the current portfolio
\item[SuggestedPortfolio] the currenly-suggested portfolio
\item[Globals] an environment
\end{description}

All the functions have the argument \texttt{lag} which defaults
to \texttt{1}.

\subsection{signal}

The \texttt{signal} function uses information until \texttt{t -
  1} and returns the suggested portfolio (a vector) to be held at
\texttt{t}.

\subsection{signalYN}

\texttt{signalYN} uses information until \texttt{t - 1} and must
return \texttt{TRUE} or \texttt{FALSE}. If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{rebalanceYN}

\texttt{rebalanceYN} uses information until \texttt{t - 1} and
returns \texttt{TRUE} or \texttt{FALSE}. If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{printInfo}

The function is called at the end of an iteration. It should not
return anything but is called for its side effect: print
information to the screen, into a file or into some other
connection.


\section{Single assets}

It is best to describe the \texttt{backtest} function through a
number of simple examples.

\noindent We attach the package.
<<>>=
require("PMwR")
@

\subsection{A useless first example}

I really like simple examples. Suppose we have a single
instrument, and we use only close prices. The trading rule is to
buy, and then to hold forever. All we need is the time series of
the prices and the signal function. To keep this example (and
also those that follow) simple, we use an artificial series.
<<>>=
prices <- c(100,98,98,97,101,102,101,98,99,101)
@


The \texttt{signal} function is very simple indeed.
<<>>=
signal <- function()
    1
@

\texttt{signal} must be written so that it returns the suggested
portfolio (or position) in units of the asset. In this first
example, the suggested position always is one unit. (It is only a
\texttt{suggested} portfolio because we can specify rules whether
or not to trade. Examples follow below.)

So \texttt{signal} always recommends to hold one unit of the
asset. To test this strategy, we call \texttt{backtest}. The
initial cash is 100 (per default). We can change it through the
argument \texttt{c0}.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal)
@

The function returns a list with a number of components. We
display the results in a \texttt{data.frame}. \texttt{Xs} is the
suggested portfolio; \texttt{X} is the actual portfolio.

<<>>=
makeTable <- function(solution, prices)
    data.frame(prices = prices,
               p     = solution$portfolio,
               sp      = solution$suggested.portfolio,
               wealth = solution$wealth,
               cash   = solution$cash)

makeTable(solution, prices)
@

We bought in the second period because the default setting for
the burnin \texttt{b} is 1; thus, we lose one observation.

Since we do not rely in any way on the past in this trading rule,
we set \texttt{b} zo zero. With this setting, we buy at the first
price and hold until the end of the data.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b  = 0)
makeTable(solution, prices)
solution$trades
@


\subsection{A more useful first example}

Now we make our strategy slightly more selective. The trading
rule is to buy whenever the last observed price is below 100, and
sell when it is above. The signal function could look like this.
<<>>=
signal <- function()
    if (Close() < 100)
        1 else 0
@

We call \texttt{backtest}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

The argument \texttt{x0} specifies the initial position. (Default
is no position.) Suppose we had already held one unit of the
asset.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 1,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

Internally, \texttt{backtest} stores \textsc{ohlc} prices in matrices.
So even for a single instrument we have four matrices, and each matrix has
one column. If we were dealing with two assets, we would again have
four matrices, each with two columns. And so on.

%% TODO: add picture of matrices

We do not access these data directly. \texttt{Close} is a
function that is defined in \texttt{backtest}, and which is
passed as an argument to \texttt{signal}. Note that we do not add
it as a formal argument to \texttt{signal} since this is done
automatically (in fact, doing it manually would trigger an error
message):
<<>>=
##signal <- function(Close = NULL)
##    1
1
##cat(try(backtest(prices = prices, signal = signal)))
@

Similarly, we have functions \texttt{Open}, \texttt{High} and
\texttt{Low} (see Section~\ref{functions} above for a available
functions).

Suppose we wanted to add a variable, like a \texttt{threshold}
that tells us when to buy. This would need to be an argument to
\texttt{signal}; but it would also need to be passed with the
\texttt{\dots} argument of \texttt{backtest}.
<<>>=
signal <- function(threshold)
    if (Close() < threshold)
        1 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     threshold = 98,  ## buy if price < threshold
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

So far we have treated \texttt{Close} as a function without arguments,
but actually it has an argument \texttt{lag} that defaults to
\texttt{1}. Suppose the rule were to buy if the last close is below the
second-to-last close. \texttt{signal} could look like this.
<<>>=
signal <- function()
    if (Close(1L) < Close(2L))
        1 else 0
@

We could also have written \texttt{(Close() < Close(2L))}. We need to
increase \texttt{b}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b = 2,           ## increase burnin
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash
makeTable(solution, prices)
@

If we wanted to trade any other size, we would change our signal as
follows.
<<>>=
signal <- function()
    if (Close() < 100)
        2 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

A typical way to specify a trading strategy is to map past prices into
\texttt{+1}, \texttt{0} or \texttt{-1} for long, flat or short. A
signal is often only given at a specified point (like in `buy one unit
now'). Example: suppose the third day is a Monday, and our rule says
`buy after Monday'.
<<>>=
signal <- function()
    if (Time() == 3)
        1 else 0
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

But this is probably not what we wanted. If the rule is to
buy and stay long, we should have written it like this.
<<>>=
signal <- function()
    if (Time() == 3L)
        1 else Portfolio()
@

The function \texttt{Portfolio} returns last period's
portfolio. Like \texttt{Close}, it takes an argument \texttt{lag}
that defaults to one.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ### initial position
                     c0 = 100)        ### initial cash

makeTable(solution, prices)
@




\subsubsection{Signals (\texttt{+1}, \texttt{0}, \texttt{-1}) to
  fixed number of units}

Suppose we prefer to write rules in terms of \texttt{+1}, \texttt{0},
\texttt{-1}. Then there are a number of settings that help to
translate such signals into holdings. \texttt{backtest} takes an
argument \texttt{adjustSignal} which controls this behaviour. Its
default is \texttt{NULL} (do nothing).

If we use \texttt{fixedPosition} and specify the argument
\texttt{positionSize}, the algorithm will translate any signal
into \texttt{positionSize} \texttimes{} \texttt{signal}.

<<>>=
signal <- function()
    if (Close() < 100)
        1 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,
                     c0 = 100,
                     adjustSignal = "fixedPosition",
                     positionSize = 5)

makeTable(solution, prices)
@

This can be useful when we have an original series of zeros and
ones (eg, following some technical indicator).

<<>>=
givenPositions <- c(0, -1, -1, 0, 1, 1, -1, 0, -1, -1)

signal <- function(givenPositions)
    givenPositions[Time()]

## fixed position size in units
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)

cbind(makeTable(solution, prices), givenPositions)
@

Note again the timelag: we can never trade at the same time instant in
which we compute a signal.

But if you really think there should be no timelag, you could write
<<>>=
signal <- function(givenPositions)
    givenPositions[Time(0L)]

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)
cbind(makeTable(solution, prices), givenPositions)
@

What if we had had a signal in the first period?
<<>>=
givenPositions <- c(1, 0, -1, 0, 1, 1, -1, 0, -1, -1)
@


<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b = 0,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)
cbind(makeTable(solution, prices), givenPositions)
@

\subsubsection{Signals (\texttt{+1}, \texttt{0}, \texttt{-1}) to fixed weight}

%% TODO: check -- anything pos becomes pos weight, anything neg
%% becomes nec weight?

Suppose we want to hold a constant weight in an asset. (Note that
that to keep the weight constant we will -- under the current
settings -- rebalance in every period.)

<<>>=
## fixed position size in %
signal <- function()
    if (Close() < 100)
        3 else 0
solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 0.2)
makeTable(solution, prices)

signal <- function()
    if (Close() < 100)
        -1.2 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 0.2)

makeTable(solution, prices)

@

To be fully invested, set \texttt{positionSize} to \texttt{1}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 1)

makeTable(solution, prices)

@


A more common scenario is probably that \texttt{signal} gives a
weight; for instance, after a portfolio optimisation.
<<>>=
signal <- function()
    if (Close() < 100)
        0.05 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight")
makeTable(solution, prices)
@

Again, we get a weight and now rebalance in every period. Suppose
we do not want that.
<<>>=
signal <- function()
    if (Close() < 100)
        0.05 else 0

rebalanceYN <- function() {
    if (sum(abs(SuggestedPortfolio(0) - SuggestedPortfolio())) > 0.02)
        TRUE else FALSE
}

solution <- backtest(prices = prices,
                     signal = signal,
                     rebalanceYN = rebalanceYN,
                     adjustSignal = "weight")

makeTable(solution, prices)
@

A numerical analyst would rather put a tolerance that is more
closely related to the machine precision. I prefer using meaningful
tolerance: having invested less than one cent means we are not
invested.

Note also that with weights, we cannot exactly specify the number of
assets we buy or sell because we do not know the price at which we
trade. Practically, this does not matter.

\subsubsection{Passing environments}
To keep information persistent, we can use environments
<<>>=
external <- new.env()
external$vec <- numeric(length(prices))
signal <- function(threshold, external) {
    external$vec[Time()] <- Close()
    if (Close() < threshold)
        1 else 0
}

solution <- backtest(prices = prices,
                     signal = signal,
                     threshold = 100,
                     external = external)

cbind(makeTable(solution, prices), external$vec)
@

\section{Multiple assets}


\subsection{Again, a simple example}

<<>>=
prices1 <- c(100,98, 98, 97, 96, 98,97,98,99,101)
prices2 <- c(100,99,100,102,101,100,96,97,95,82)
prices <- cbind(prices1, prices2)

signal <- function()
    if (Close()[1L] > Close()[2L])
        c(1, 0) else c(0, 1)


(solution <- backtest(prices = list(prices),
                     signal = signal,
                      b=2))
@

We can also give more useful names to the assets.
<<>>=
prices <- cbind(AA = prices1, BB = prices2)
solution <- backtest(prices = list(prices),
                               signal = signal, b=2)
makeTable(solution, prices)

@



\section{Common tasks}
There are many ways to do the same thing. I describe how I have
handled some specific tasks.

\subsection{Remembering an entry price}
In signal: use the current price and assign in \texttt{Globals}.

\subsection{Delaying signals}

\subsection{Losing signals}

\subsection{Writing a log}
<<>>=
prices <- c(100,98,98,97,101,102,101,98,99,101)

signal <- function()
    if (Close() < 100)
        1 else 0

printInfo <- function() {
    cat("period",
        sprintf("%2d", Time(0L)), "...",
        sprintf("%3d", Wealth(0)), "\n")
    flush.console()
}

solution <- backtest(prices = prices,
                     printInfo = printInfo,
                     signal = signal)

makeTable(solution, prices)

@
And since \texttt{cat} has a \texttt{file} argument, we can also write
such information into a logfile.




\chapter{Reporting}

\section{qpTable}

quartile plot table

\section{slTable}

arguments:
\begin{itemize}
\item \ldots : zoo objects
\item include.returns
\item include.diffs
\item compute.with = "returns": or "diffs" or "levels"
\item columns = list(mean = mean, sd = sd): need to be computed on returns
\end{itemize}



\chapter{Technical indicators}

sum, abssum, sd, absmean, range, minmax, minmaxrange, mad




\appendix
\chapter{Design}

\section{Requirements}

\begin{itemize}
\item Store a 'portfolio' of assets and compute the value (or other
  quantities, like Greeks) for different data.  Data can refer to
  market prices, but also to theoretical prices.
\item Reevaluate a portfolio for scenario (= new market data or
  artificial data).
\item Read in transactions from various sources. $\to$ done via a
  journal class.
\item Show portfolio on certain day/time: create a position, evaluate
  this position $\to$ position class
\item testing portfolios of options --> show payoff, simulate *paths*
  of underlier and vol surface
\item run simulations for VaR
\item various ways to compute pnl: weighted average,
  first-in-first-out and last-in-last-out
\end{itemize}


\section{Classes}

The following classes are implicitly defined (ie, S3 classes):

\begin{itemize}
\item journal: keeps transactions
\item Position: only for printing. It comprises the numerical
  positions of different accounts/instruments, the timestamps and the
  description of the instruments.
\item Instrument: term sheet (description etc); it does know nothing
  about market data
\item Cashflow: internal
\item Timeseries: internal
\end{itemize}

\section{Valuation}

Valueing a position can mean two things: compute theoretical prices,
or market prices.

Theoretical valuation takes places via the generic function value:

\texttt{value(x, ..., dots2args = NULL) } 

The simplest case:
\texttt{x} is character, then a call will be generated as

\texttt{do.call(x, list(...))}

\texttt{dots2args.default <- function(x, ...) list(...)}

Note that this will be the default method; notably, a method when
\texttt{x} is character will be left unspecified (meant for the user).


A more typical case: collect all market data in a list \texttt{Data}:
EvaluationDate, Prices, Vols, Irates.

dots2args will react on \texttt{x}, retrieve the required information,
and 



\begin{itemize}
\item evaluates to list "value", "delta" etc
\item Instrument[names(result)] <- result
\end{itemize}


<<>>=
Time   <- as.Date("2013-05-28")
Prices <- list(DAX = 8472)
Irates <- list(EUR = function(t) 0.1)
Vols   <- list(DAX = function(x,t) 0.2)

DATA <- list(Time = Time, 
             Prices = Prices, 
             IRates = Irates, 
             Vols = Vols)
DATA
DATA$Vols$DAX(8000, 0.2)
DATA$IRates$EUR(0.5)

@      


\section{Instruments and portfolios}



\subsubsection{Instrument}
classes: Fund Equity Account Currency Future Index


fields:

id
isin
description
underlier
expirydate
expirytime
strike
type c/p
exercise e/a
pricing premium/future
class



\chapter{Frequently-used functions}

\emph{I need to value a financial instrument.}


\emph{I have a list of trades (bought or sold what, when and at what price)
and I need to compute the profit or loss.}

If all trades are closed (ie, the current positions are all zero), use
\texttt{pl}.


\emph{I have a list of trades in an instrument and want to plot these
  trades against the price of the traded instrument.}


\emph{I have a signal series (\texttt{+1}, \texttt{0}, \texttt{0}, \texttt{+1}, \ldots{}) and need to
  transform it into a profit-and-loss series.}


\emph{We have a list of trades and need to determine the
  profit-and-loss between two timestamps.}


Call the two timestamps \texttt{t0} and \texttt{t1}.  Unless the position was zero
at t0 and t1, we can compute the profit/loss only if we have prices
for the positions at these points in time.  In case the position was
indeed zero, you can use \texttt{pl}; the transactions are stored in a
journal \texttt{j}.

<<eval=false>>=
subset(j, timestamp >= t0 & timestamp <=t1)
@

But even the more general case is not so complicated, after all.

\begin{enumerate}
\item Compute the position at \texttt{t0} and make it a journal j0.

\item Take all transactions at $t > t_\mathrm{0}$ and $t \leq
   t_\mathrm{1}$ and put them into a journal $J$.

\item Compute the position at $t_\mathrm{1}$, and make it a journal
   $J_1$, but \emph{multiply all amounts by $-1$}.

\item Combine $J_0$, $J$, and $J_1$ and compute the PL.
\end{enumerate}

%\printindex
\bibliographystyle{plainnat}
\bibliography{bibliothek}

\end{document}
