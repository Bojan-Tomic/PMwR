% \VignetteIndexEntry{PMwR-Manual}
\documentclass[a4paper,11pt]{book}
\usepackage[left = 2.5cm, top = 2cm, bottom = 3cm, right = 4.5cm]{geometry}
\usepackage[noae,nogin]{Sweave}
\usepackage{libertine}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\renewcommand*\familydefault{\sfdefault} 
\usepackage{amsmath,amstext}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{textcomp}
\usepackage{ragged2e}
\usepackage{framed}
\usepackage{makeidx}\makeindex

\usepackage{marginnote}
\renewcommand*{\marginfont}{\sffamily\footnotesize}

\SweaveOpts{keep.source = TRUE, eps = TRUE, pdf = FALSE}

\newcommand{\pmwr}{\textsc{pm}w\textsc{R}}
\newcommand{\pl}{\textsc{pl}}
\newcommand{\R}{\textsf{R}}


\begin{document}
\pagestyle{empty}

\vglue 2cm

{\RaggedRight\Huge Portfolio Management with R (PMwR)}\vskip 3cm


{\RaggedLeft{
\noindent Enrico Schumann\\
\noindent \texttt{es@enricoschumann.net}\\}}
\bigskip

<<echo=false>>=
options(continue = " ", digits = 3, width = 60)
require("PMwR")
@

\chapter{Journals}
\pagestyle{plain}

\section{Transactions}

Many computations that the \pmwr\ package provides are based on lists
of transactions.  Conceptually, such lists are nothing more than
dataframes, but \pmwr\ provides an \texttt{S3} class \texttt{journal}
for handling such transaction data.

A~\texttt{journal} is a list of atomic vectors with a class attribute;
it is created through the function \texttt{journal}.%
\index{journal!compared with data.frame} %
Methods should not rely on this list being sorted in any particular
way: components of a journal should always be retrieved by name, never
by position. (In this respect a journal differs from a dataframe, for
which we can meaningfully speak of the \emph{n}th column.)  I will
refer to these journal components, such as \texttt{amount} or
\texttt{timestamp}, as fields.\index{journal!fields}

The simplicity of the class is intended, since it is meant for
interactive analyses.  Thus, the user may -- and is expected to --
dissect the information in a \texttt{journal} at will; such
dissections include removing the class attribute.

What is actually stored in a \texttt{journal} is up to the user, but a
number of fields are required for certain operations and should thus
always be present:
\begin{description}
\item[\texttt{timestamp}] anything that can be sorted and that fits
  into an atomic vector (\texttt{POSIXlt} is possible, too, but not
  recommended);

\item[\texttt{amount}] the notional amount that is traded;

\item[\texttt{price}] price;

\item[\texttt{instrument}] description of the financial instrument;

\item[\texttt{id}] (possibly unique) id;

\item[\texttt{account}] description of the account;

\item[\texttt{\ldots}] other fields. They must be named, for instance
  `\texttt{fees = c(1,2,1)}'\,.
\end{description}
All fields can be missing, except \texttt{amount}.  Missing values
will be handled as \texttt{NA} with the exception of \texttt{id} and
\texttt{account}, which will be \texttt{NULL}.

Transactions in a journal can be organised in a hierachy %
\marginpar{This notation is inspired by the syntax of \texttt{ledger}
  files. See \url{http://www.ledger-cli.org/}\,.} %
\begin{verbatim}
<account> => <instrument>
\end{verbatim}
even though currently few functions use this hierarchy.  A simple
scheme is to use specific character or pattern such as `\texttt{::}'
to introduce hierarchies into accounts, such as
\begin{verbatim}
pension::equities
\end{verbatim}

\section{Handling journals}

\subsection{Creating journals}

The function \texttt{journal} creates journal objects.
<<>>=
J <- journal(timestamp  = as.Date("2012-01-01") + 0:3, 
              amount     = c(1, 2, -2, 5),
              instrument = c("EUR", "EUR", "CHF", "CHF"))
J
@ 
For details about the function and methods for \texttt{journal}
objects, see \texttt{?journal}\,.  A \texttt{print} method defines how
to display a journal.\index{journal!print@\texttt{print}}
<<>>=
print(J, max.print = 2, exclude = "instrument")
@ 
Journals can be combined with \texttt{c}.\index{journal!c@\texttt{c}}
<<>>=
J2 <- J
J2$fees <- rep(1,4)
c(J, J2)
@ 

\subsection{Subsetting journals}

In interactive sessions, we can use \texttt{subset} to select specific
transactions. %
\index{journal!subset@\texttt{subset}}
<<>>=
subset(J, amount > 1) 
@
With subset, you need not quote the expression that selects trades and
you can directly access a journal's fields.

More generally, to extract or change a field, use its name, either
through the \texttt{\$} operator or double brackets \texttt{[[...]]}.
<<>>=
J$amount
@ 
<<>>=
J[["amount"]] <- c(1 ,2, -2, 8)
J
@ 
The \texttt{`[`} method works with integers or logicals, returning
the respective transactions.
<<>>=
J[2:3]
J[J$amount < 0]
@ 
You can also pass a string, which is then interpreted as a regular
expression that is matched against fields \texttt{instrument} and (if
available) \texttt{account}.
<<>>=
J["eur"]
@ 
By default, case is ignored, but you can set \texttt{ignore.case} to
\texttt{FALSE}.  You can also specify the fields to match the string
against.
<<>>=
J <- journal(timestamp  = as.Date("2012-01-01") + 0:5, 
             amount     = rep(1, 6),
             instrument = c("Equity A", "Equity A", 
                            "Equity B", 
                            "Bond exp 2019", "Bond exp 2017", 
                            "Bond exp 2021"),
             comment = c("pension plan", "pension plan", 
                          "", "", "", ""))
J
J["equ", ignore.case = FALSE]
J["equ", ignore.case = TRUE]
J["[Pp]ension"]
J["[Pp]ension", match.against = "comment"]
@ 


\section{Examples: positions, profits and losses}

\subsection{Single-entry accounting}

For many purposes, single-entry accounting is sufficient.  Suppose you
keep track of a bank account.
<<>>=
J <- journal(timestamp = as.Date("2012-01-01") + 0:3, 
               amount    = c(1, 2, -2, 5))
J 
@
The \texttt{position} function gives the current balance of all
instruments.
<<>>=
position(J)
@
To get the position at a specific date, use the \texttt{when} argument.
<<>>=
position(J, when = as.Date("2012-01-03"))
@
To get a time series of positions, you can use specific keywords for
\texttt{when}: \texttt{"all"} will print the position at all
timestamps in the journal.
<<>>=
position(J, when = "all")
@
We are not limited to the timestamps that exist in the journal.
<<>>=
position(J, when = seq(from = as.Date("2011-12-30"), 
                          to = as.Date("2012-01-06"),
                          by = "1 day"))
@ 
It's actually tedious to enter journals that way, in particular if
we want to update it over time.  So, for practical use, we may write
transactions into files, like this:

\VerbatimInput{ex1.txt}

\noindent (In case you use Org-mode, such tables should look familiar.) % 
\marginpar{\url{http://orgmode.org/}} %
<<echo=false>>=
system("perl -ne 'print $_ if /^\\s*\\| /;' < ex1.txt > ex1.jnl")
@ 
We can then write functions to read in such journal files.
<<echo=false>>=
readjnl <- function(file) {
    ans <- read.table(file,
                      header = TRUE, sep = "|", as.is = TRUE)
    ans <- as.list(ans[ ,apply(ans, 2, function(x) !all(is.na(x)))])
    journal(timestamp = ans$timestamp,
            amount    = ans$amount,
            comment   = ans$comment)
}
(J <- readjnl("ex1.jnl"))
@ 
Some of these transactions may mean a gain or loss to us, such as a
dividend payment).  Others are neutral, for example a transfer between
bank accounts.  One way to deal with that is to switch to double-entry
accounting (see the next section).  A second way is to add
descriptions like \texttt{"expense"} and then subset by these
descriptions.

And yet another approach is to use prices.  Whenever you evaluate the
balances of your cash account, say that the price per unit is one.
That is reasonable: if my account has a balance of `120.2', it
actually means `120.2 euros'.  The price of one euro is one euro.

An expense should be a negative amount; income should go with positive
amounts.  When you add such an entry, make its price 0; when you
compute that value of a position, make its price 1.  An example:

<<>>=
J <- journal(timestamp = c("day 1", "day 2", "day 3"), 
               amount    = c(100,100,-200), 
               price     = c(  1,  0,   0),
               comment   = c("neutral", "income", "expense"),
               account   = "my account")
J
@
The current balance is 0.
<<>>=
position(J)
@ 
In terms of income and expenses we have made a loss of~100, which is
exactly what the function \texttt{pl} reports.  (There will be more
examples for computing profit and loss in the next chapter.)
<<>>=
pl(J, current.price = 1)
@ 
Let us do some more typical financial transactions.  We buy five
times 1~unit of some unspecified asset.
<<>>=
J1 <- journal(timestamp = 1:5, 
               amount   = 1, 
               price    = c(2,2,2,3,4), 
               account  = "my account")
J1
@
We close the trade by selling 5~units.
<<>>=
J2 <- journal(timestamp =  6L, 
               amount   = -5, 
               price    =  3, 
               account  = "my account")
@
We can combine these journals with \texttt{c}.
<<>>=
c(J1, J2)
@ 
(Note that I have written \texttt{6L} for the timestamp in
\texttt{J2}.  If I had not, a warning would have been issued saying
that the timestamps in the journals have different classes.
\texttt{1:5} is integer whereas \texttt{6} is numeric.  In the case
here, the warning would have been harmless and could have been
ignored.)

Since the position is now zero, it is easy to compute the \pl.  We can
use the function \texttt{pl}, again.
<<>>=
pl(c(J1, J2))
@
There is little difference when we have several accounts. An example:
<<echo=false>>=
trades <- read.table(textConnection(
    "account; ticker; timestamp; amount; price
    private ; A ; 1;   100; 60
    private ; A ; 2;   100; 70
    private ; A ; 3;  -100; 66
    longterm; A ; 1; 100; 60
    longterm; B ; 1; 100; 5"),
                     sep =";", header = TRUE,
                     strip.white = TRUE, 
                     stringsAsFactors = FALSE)

(J <- journal(timestamp = trades$timestamp, 
                amount    = trades$amount,
                price     = trades$price, 
                instrument = trades$ticker, account = 
                trades$account))
@
There are two accounts.
<<>>=
table(J$account)
@ 
Per default, \texttt{position} does not care about accounts.  
We have asset \texttt{A} in account \texttt{longterm} and in
\texttt{private}, but we get the sum over all accounts.
<<>>=
position(J)
@
There are at least two ways to deal with this.  One is to concatenate
\texttt{account} and \texttt{instrument}.
<<>>=
J2 <- J
J2$instrument <- paste0(J$account, ":", J$instrument)
position(J2)
@ 
The other is to use \texttt{split} on the journal. %
\index{journal!split@\texttt{split}}
<<>>=
lapply(split(J, J$account), position)
@ 

\subsection{Double-entry accounting}

\emph{to be added}




\chapter{Profit and (or) loss}

\section{The simple case}

We have an account, currency is euro.  We buy one asset at a price of
100~euro and sell it again at 102~euro.  We have made a profit of
2~euros.  This simple case happens often enough to make the required
computation simple as well.  Computing profit-or-loss (\pl) can be handled
through the function \texttt{pl}.
<<>>=
pl(price  = c(100, 102), 
   amount = c(  1,  -1))
@ 
A trader bought one~unit at 50, one~unit at 90 and sold two~units at
100, resulting in a profit of 60.  But suppose that the actual order
of the trades was\medskip

buy at 90 \quad $\Rightarrow$ \quad buy at 50 \quad $\Rightarrow$ \quad
sell at 100\,.\medskip

\noindent Even if we know nothing about what was traded and when, some
information is provided by the order of the trades: the position had a
drawdown of at least~40 before it recovered.  For situations like
this, the argument \texttt{along.timestamp} can be used. (Note that we
do not provide an actual timestamp, in which case the function will
implicitly use integers 1, 2, \ldots, \texttt{length(amount)}\,.)
<<>>=
pl(price  = c( 90, 50, 100), 
   amount = c(  1,  1,  -2), along.timestamp = TRUE)
@ 
With no further arguments, the function will compute the
running position and evaluate it at every trade with the trade's
price.  This may not be accurate because of bid--ask spreads or other
transaction costs, but it provides more information than only
computing the \pl\ for the trades.
<<>>=
J <- journal(price     = c( 90, 50, 100), 
             amount    = c(  1,  1,  -2),
             timestamp = c(  2,  4,   7))
pl(J, along.timestamp = TRUE)
@ 
Suppose we also have a time series of the prices between time 1 and
time 10.  We can evaluate the position at every time
instant, and then plot position, \pl\ and the price of the traded
instrument.

<<>>=
## [TODO]
price <- c(100,90,70,50,60,80,100,90,110,105)
position(J, when = 1:10)
@ 

A more-useful example for \texttt{pl} with \texttt{along.timestamp} is
a trading history of a high-frequency strategy.  Suppose for example
we had traded EURUSD 200~times in single day and wished to plot the
result.  At such a frequency, the prices at which the trades were
executed is useful to value any open position.

<<>>=
## [TODO]
@ 
We may also want to compute the \pl\ between two points in
time.  If our only data source is a journal, this may be impossible
since we need to evaluate the position at both points in time.  A simple
example follows; the data first.
<<echo=false>>=
timestamp <- 1:20
amount <- c(-5, 5, 5, -5, -5, 5, 5, 5, 5, 
            -5, 5, 5, -5, 5, 5, -5, -5, -5, 
            -5, -5)
price <- c(106, 101, 110, 110, 105, 105, 105, 104, 110, 104, 
           103, 108, 106, 102, 108, 107, 103, 104, 109, 104)
(J <- journal(timestamp = timestamp, amount = amount, price = price))
@ 

Suppose we want the pl between times 5 and~8. Conceptually, it is
simple: we first compute the position at~5 and treat it as a trade.
Clearly, for this we need the price of the instruments in the position
at timestamp~5.  Then we extract all the trades that occured later
than 5, up to 8.  The final position, again, would be treated as a
trade, but with signs reversed. That, we close the position, if any
exists.  Here, again, we need the prices of the instruments.

The function \texttt{pl} does (most of) these tasks for us.
<<>>=
from <- 5
to   <- 8
price.from <- 106
price.to   <- 105
position.from <- position(J, when = from)
trades <- J[J$timestamp > from & J$timestamp <= to]

pl(trades, 
   initial.position = position.from, 
   initial.price = price.from,
   current.price = price.to)   
@ 


You can also use this mechanism if you wish to compute the \pl\
of a complete journal, but with some positions not closed yet.  The
simplest example: a journal of just one trade.
<<>>=
(J <- J[1])
@ 

There is no way to tell the pl of this trades\ldots 
<<>>=
pl(J)
@ 

\ldots unless the current price is supplied.
<<>>=
pl(J, current.price = 105)
@ 

\section{More  complicated cases}


%% TODO:

%% - example EUR investor buys INTC

%% - pure FX portfolio

Unfortunately, in real life computing \pl\ is often more complicated:

\begin{itemize}

\item One asset-price unit may not translate into one currency unit:
  we have multipliers or contract factors.  That is easy to solve by
  computing effective position sizes, but it may take some thinking to
  come up with a reusable scheme (eg, looking up multipliers in a
  table).
    
\item Asset positions may map into cashflows in non-obvious ways.  The
  simple case is the delay in actual payment and delivery of an asset,
  which is often two or three days.  The more problematic cases are
  derivatives with daily adjustments of margins.

\item Assets may be denominated in various currencies.
  
\item Currencies themselves may be assets in the portfolio.  Depending
  on how they are traded (cash, forwards, \emph{\&c.}), computing \pl\ 
  may not be straightforward.
\end{itemize}

How (or rather: to what degree) these troubles are handled is, as
always, up to the user.  For a single instrument, computing
profit/loss in units of the instrument is always meaningful (though,
perhaps, not always intuitive).  But \emph{adding up} the profits and
losses of several assets often does not work because of multipliers or
different currencies.  The simplest and most transparent way is then
to manipulate the journal before \pl\ is computed (eg, multiply
notionals by their multipliers).




We look at two examples: (i)~computing the \pl\ of several assets in
currency units; and (ii)~computing time-weighted returns of a
portfolio of assets.

\subsection{Several assets}

In this example we compute the \pl\ in currency units of a portfolio
over time.  We start with the following journal.

<<echo=false>>=
## dput(ISOdatetime(2013,c(11,11,12,12,11,12), c(28,28,2,3,27,2), 
##                     c(9,12,13,9,9,13),c(35,50,21,57,52,54),0))
timestamp <- structure(c(1385627700, 1385639400, 1385986860, 1386061020, 1385542320, 
                         1385988840), class = c("POSIXct", "POSIXt"), tzone = "")

(J <- journal(amount    = c(100,100,-50,-150, 100,-50),
             timestamp = timestamp,
             price = c(11.6, 11.62, 11.67, 11.47, 25.1,26.29),
             instrument = c(rep("DTE", 4), rep("DPW", 2))))
@ 
We shall compute end-of-day \pl\ of these trades.  In case you
wondered: \textsc{dte} stands for Deutsche Telekom and \textsc{dpw} is
Deutsche Post, both traded on \textsc{xetra}.  Thus, end-of-day is
17:30 in Frankfurt am Main, Germany.

(There is nothing special about end-of-day.  We could just as well
have decided to have hourly numbers, say.  But I would like to keep
this example small.)  The prices at these timestamps are stored
in a matrix \texttt{price.table}.
<<echo=false>>=
price.table <- structure(c(25.71, 25.965, 26.03, 26.32, 25.305,
                           11.65, 11.655, 11.685, 11.62, 11.375), 
                         .Dim = c(5L, 2L), 
                         .Dimnames = list(NULL, c("DPW", "DTE")))

## times <- as.POSIXct(c("2013-11-27 17:30:00", "2013-11-28 17:30:00", "2013-11-29 17:30:00", 
##                       "2013-12-02 17:30:00", "2013-12-03 17:30:00"))
when <- times <- structure(c(1385569800, 1385656200, 1385742600, 
                     1386001800, 1386088200), 
                   class = c("POSIXct", "POSIXt"), 
                   tzone = "")
rownames(price.table) <- as.character(times)
@ 
<<>>=
price.table
@ 

\subsubsection*{Step 1: compute value of portfolio}

We first need the position sizes at the timestamps at which we want to
compute \pl.  We store them in a vector \texttt{when}.
<<>>=
when
@ 
The position at \texttt{when} is quickly computed.
<<>>=
(pos <- position(J, when = when))
@ 

Note that each element in the position matrix corresponds to an
element in the matrix price.table.  That is, the rows refer to the
timestamps:
<<>>=
pos$timestamp
@ 
The columns must be ordered like the instruments:
<<>>= 
pos$instrument
@ 
Thus, we need to multiply both matrices element-by-element, which is
exactly what the function \texttt{valuation} does.  A warning: the
function does currently not at all check \texttt{price.table}.
<<>>=
valuation(pos, price.table = price.table)
@ 
We care about the row sums of the results.
<<>>= 
(v <- valuation(pos, price.table = price.table, do.sum = TRUE))
@
If the assets have specific multipliers, we can pass them as a named
vector.  (That is the preferred way, at least.  An unnamed vector will
do as well, as will a single number, which is recycled.)
<<>>=
valuation(pos, price.table = price.table, 
          multiplier = c(DTE = 5, DPW = 0.5))
@

\subsubsection*{Step 2: compute cashflows that led to portfolio}

We create a vector \texttt{cf} that will store the cashflows.
<<>>=
cf <- numeric(length(pos$timestamp))
names(cf) <- as.character(pos$timestamp)
@ 


<<>>=
tmp <- valuation(J)
tmp$timestamp <- pos$timestamp[PMwR:::matchOrNext(tmp$timestamp, pos$timestamp)]
cash <- aggregate(tmp$amount, list(tmp$timestamp), sum)
cf[match(cash[[1]], pos$timestamp)] <- cash[[2]]
(v.net <- v + cumsum(cf))
@ 

TODO: check -- create interface journal/when/price.table?

\subsubsection*{Summary}

\begin{enumerate}
\item Fix \texttt{when}; compute position at \texttt{when}.
\item Prepare a matrix price.table of \texttt{length(when)} rows,
  whose columns correspond to the assets in the portfolio.
\item Call \texttt{valuation(position)} and store the result as
  \texttt{v}.
\item Call \texttt{valuation(journal)}; map the timestamps of the new
  journal to \texttt{when}; sum the cashflows by timestamp; subtract
  the resulting cashflows from \texttt{v}.
\end{enumerate}

To compute returns, choose a suitable total portfolio value and divide
by it.








\chapter{Analysing trades}

\section{Exposure}

We have the following trades and times.
<<>>=
amount <- c(1,3,-3,1,-3,1)
time <- c(0,1,3,4,7,12)
@ 
The holding period (\texttt{duration}) of these trades can be computed
so:
<<>>=
data.frame(position = cumsum(amount)[-length(amount)], 
           from = time[-length(time)],
           to   = time[-1L],
           duration = diff(time))
@ 

We can plot the exposure.
<<fig=true, height = 2, width = 5>>=
par(bty = "n", mar = c(4,4,0,0), tck = 0.005, las = 1, cex = 0.8)
plot(c(time[1L], time), cumsum(c(0, amount)), type = "s",
     xlab = "time", ylab = "position")
@ 
Thus, we have had a position from time zero to 12 (hours into the
trading day, say), but its size varied.  The function
\texttt{twExposure} (time-weighted exposure) computes the average
absolute exposure.
<<>>=
twExposure(amount, time)
@ 
To give a simple example: suppose we bought at the open of a trading
day and sold at noon.  The average exposure for the day is thus half a
contract.
<<>>=
amount <- c(1, -1 , 0)
time   <- c(0,0.5,1)
twExposure(amount, time)
@ 


\section{Splitting and rescaling}

Suppose we have the following trades and impose a limit that the
maximum absolute exposure for the trader should only be 2.

<<>>=
t <- 1:6
n <- c(-1,-1,-1,1,1,1)
p <- c(100,99,98,98,99,100)
limit(n, p, t, lim = 2)
@ 

Scaling the trades.
<<>>=
scaleToUnity(n)
@ 

Closing the trade at once.
<<>>=
closeOnFirst(n)
@



\section{Computing returns}

\subsection{Numeric data}
A vector.
<<>>=
x <- c(100,101,105)
returns(x)
@ 
A matrix.
<<>>=
X <- cbind(x,x,x)
returns(X)
@ 

\subsection{Time series}

<<>>=
x
t <- 1:3
returns(x, t)
@ 

\chapter{Backtesting}

\section{Introduction}

This chapter explains how to test trading strategies with the
\texttt{btest}\index{btest@\texttt{btest}} function.

\section{Decisions}

At any instant of time (in actual life, `now'), a trader need to
answer the following questions:
\begin{enumerate}
\item Do I want to compute a new target portfolio, yes or no? If yes,
  go ahead and compute the new target portfolio.
\item Given the target portfolio and the actual portfolio, do I~want
  to rebalance (ie, close the gap between the actual portfolio and the
  target portfolio)? If yes, rebalance.
\end{enumerate}
If such a decision is not just hypothetical, then the answer to the
second question may lead to a number of orders sent to a broker.  Note
that many traders do not think in terms of \emph{stock} (ie, balances)
as we did here; rather, they think in terms of \emph{flow} (ie,
orders).  Both approaches are equivalent, but the described one makes
it easier to handle missed trades and synchronise accounts.

During a backtest, we will simulate the decisions of the trader.  How
precisely we simulate depends on the trading strategy.  The
\texttt{btest} function is meant as a helper function to simulate
these decisions.  The logic for the decisions described above is coded
in the functions \texttt{do.signal}, \texttt{signal} and
\texttt{do.rebalance}.

Implementing \texttt{btest} required a number of decision, too:
(i)~what to model (ie, how to simulate the trader), and (ii)~how to
code it.  As an example for point~(i): how precisely do we want to
model the order process (eg, use limit orders?  Allow partial fills?)
Example for~(ii): the backbone of \texttt{btest} is a loop that runs
through the data.  Loops are slow in \R\ when compared with compiled
languages, so should we vectorise instead?  Vectorisation is indeed
often possible, namely if trading is not path-dependent.  If we have
already a list of trades, we can efficiently transform them into a
profit-and-loss in \R\ without relying on an explicit loop.  Yet, one
advantage of looping is that the trade logic is more similar to actual
trading; we may even be able to reuse some code in live trading.

Altogether, the aim is to stick to the functional paradigm as much as
possible.  Functions receive arguments and evaluate to results; but
they do not change their arguments, nor do they assign or change other
variables `outside' their environment, nor do the results depend on
some variable outside the function.  This creates a problem, namely
how to keep track of state.  If we know what variables need to be
persistent, we could pass them into the function and always return
them.  But we would like to be more flexible, so we can pass an
environment; examples are below.  To make that clear: functional
programming should not be seen as a yes-or-no decision, but it is a
matter of degree.  And more of the functional approach can help
already.

\section{Data}

We have one or several price series of length~\texttt{T}. The
\texttt{btest} function runs from \texttt{b + 1} to \texttt{T}. The
variable~\texttt{b} is the burn-in\index{burn-in},%
\marginpar{\texttt{b}\qquad burn-in} %
and it needs to be a positive integer; in rare cases it may be zero.
When we take decisions that are based on past data, we will lose at
least one data point.

Here is an important default: at time~\texttt{t}, we can use
information up to time \texttt{t - 1}.  Suppose that \texttt{t}
were~4.  We may use all information up to time~3, and trade at the
\texttt{open} in period~4.

%TODO create nice display

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS    X                        <- trade here
5    HH:MM:SS
\end{verbatim}

We could also trade at the \texttt{close}.

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS                       X     <-- trade here
5    HH:MM:SS
\end{verbatim}


(No, we cannot trade at the high or low.  But perhaps we could add
this later as a robustness check -- always buy at the high, sell at
the low.)

\section{Functions}\label{functions}

\texttt{backtest} expects a number of functions. The default is to not
specify arguments to these functions, because they can all access the
following objects. These objects are themselves functions that can
access certain data; there are no replacement functions.

\begin{description}
\item[Open] access open prices
\item[High] access high prices
\item[Low] access low prices
\item[Close] access close prices
\item[Wealth] the total wealth (cash plus positions) at a given
  point in time
\item[Cash] cash (in accounting currency)
\item[Time] current time (an integer)
\item[Portfolio] the current portfolio
\item[SuggestedPortfolio] the currenly-suggested portfolio
\item[Globals] an environment
\end{description}

All the functions have the argument \texttt{lag} which defaults
to \texttt{1}.

\subsection{signal}

The \texttt{signal} function uses information until \texttt{t -
  1} and returns the suggested portfolio (a vector) to be held at
\texttt{t}.

\subsection{signalYN}

\texttt{signalYN} uses information until \texttt{t - 1} and must
return \texttt{TRUE} or \texttt{FALSE}. If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{rebalanceYN}

\texttt{rebalanceYN} uses information until \texttt{t - 1} and
returns \texttt{TRUE} or \texttt{FALSE}. If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{printInfo}

The function is called at the end of an iteration. It should not
return anything but is called for its side effect: print
information to the screen, into a file or into some other
connection.


\section{Single assets}

It is best to describe the \texttt{backtest} function through a number
of simple examples.


\subsection{A useless first example}

I really like simple examples. Suppose we have a single
instrument, and we use only close prices. The trading rule is to
buy, and then to hold forever. All we need is the time series of
the prices and the signal function. To keep this example (and
also those that follow) simple, we use an artificial series.
<<>>=
prices <- c(100,98,98,97,101,102,101,98,99,101)
@
The \texttt{signal} function is very simple indeed.
<<>>=
signal <- function()
    1
@

\texttt{signal} must be written so that it returns the suggested
portfolio (or position) in units of the asset. In this first
example, the suggested position always is one unit. (It is only a
\texttt{suggested} portfolio because we can specify rules whether
or not to trade. Examples follow below.)

So \texttt{signal} always recommends to hold one unit of the
asset. To test this strategy, we call \texttt{backtest}. The
initial cash is 100 (per default). We can change it through the
argument \texttt{c0}.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal)
@

The function returns a list with a number of components. We
display the results in a \texttt{data.frame}. \texttt{Xs} is the
suggested portfolio; \texttt{X} is the actual portfolio.

<<>>=
makeTable <- function(solution, prices)
    data.frame(prices = prices,
               p     = solution$portfolio,
               sp      = solution$suggested.portfolio,
               wealth = solution$wealth,
               cash   = solution$cash)

makeTable(solution, prices)
@

We bought in the second period because the default setting for
the burnin \texttt{b} is 1; thus, we lose one observation.

Since we do not rely in any way on the past in this trading rule,
we set \texttt{b} zo zero. With this setting, we buy at the first
price and hold until the end of the data.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b  = 0)
makeTable(solution, prices)
solution$trades
@


\subsection{A more useful first example}

Now we make our strategy slightly more selective. The trading
rule is to buy whenever the last observed price is below 100, and
sell when it is above. The signal function could look like this.
<<>>=
signal <- function()
    if (Close() < 100)
        1 else 0
@

We call \texttt{backtest}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

The argument \texttt{x0} specifies the initial position. (Default
is no position.) Suppose we had already held one unit of the
asset.

<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 1,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

Internally, \texttt{backtest} stores \textsc{ohlc} prices in matrices.
So even for a single instrument we have four matrices, and each matrix has
one column. If we were dealing with two assets, we would again have
four matrices, each with two columns. And so on.

%% TODO: add picture of matrices

We do not access these data directly. \texttt{Close} is a
function that is defined in \texttt{backtest}, and which is
passed as an argument to \texttt{signal}. Note that we do not add
it as a formal argument to \texttt{signal} since this is done
automatically (in fact, doing it manually would trigger an error
message):
<<>>=
##signal <- function(Close = NULL)
##    1
1
##cat(try(backtest(prices = prices, signal = signal)))
@

Similarly, we have functions \texttt{Open}, \texttt{High} and
\texttt{Low} (see Section~\ref{functions} above for a available
functions).

Suppose we wanted to add a variable, like a \texttt{threshold}
that tells us when to buy. This would need to be an argument to
\texttt{signal}; but it would also need to be passed with the
\texttt{\dots} argument of \texttt{backtest}.
<<>>=
signal <- function(threshold)
    if (Close() < threshold)
        1 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     threshold = 98,  ## buy if price < threshold
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

So far we have treated \texttt{Close} as a function without arguments,
but actually it has an argument \texttt{lag} that defaults to
\texttt{1}. Suppose the rule were to buy if the last close is below the
second-to-last close. \texttt{signal} could look like this.
<<>>=
signal <- function()
    if (Close(1L) < Close(2L))
        1 else 0
@

We could also have written \texttt{(Close() < Close(2L))}. We need to
increase \texttt{b}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b = 2,           ## increase burnin
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash
makeTable(solution, prices)
@

If we wanted to trade any other size, we would change our signal as
follows.
<<>>=
signal <- function()
    if (Close() < 100)
        2 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

A typical way to specify a trading strategy is to map past prices into
\texttt{+1}, \texttt{0} or \texttt{-1} for long, flat or short. A
signal is often only given at a specified point (like in `buy one unit
now'). Example: suppose the third day is a Monday, and our rule says
`buy after Monday'.
<<>>=
signal <- function()
    if (Time() == 3)
        1 else 0
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100)        ## initial cash

makeTable(solution, prices)
@

But this is probably not what we wanted. If the rule is to
buy and stay long, we should have written it like this.
<<>>=
signal <- function()
    if (Time() == 3L)
        1 else Portfolio()
@

The function \texttt{Portfolio} returns last period's
portfolio. Like \texttt{Close}, it takes an argument \texttt{lag}
that defaults to one.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ### initial position
                     c0 = 100)        ### initial cash

makeTable(solution, prices)
@




\subsubsection{Signals (\texttt{+1}, \texttt{0}, \texttt{-1}) to
  fixed number of units}

Suppose we prefer to write rules in terms of \texttt{+1}, \texttt{0},
\texttt{-1}. Then there are a number of settings that help to
translate such signals into holdings. \texttt{backtest} takes an
argument \texttt{adjustSignal} which controls this behaviour. Its
default is \texttt{NULL} (do nothing).

If we use \texttt{fixedPosition} and specify the argument
\texttt{positionSize}, the algorithm will translate any signal
into \texttt{positionSize} \texttimes{} \texttt{signal}.

<<>>=
signal <- function()
    if (Close() < 100)
        1 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,
                     c0 = 100,
                     adjustSignal = "fixedPosition",
                     positionSize = 5)

makeTable(solution, prices)
@

This can be useful when we have an original series of zeros and
ones (eg, following some technical indicator).

<<>>=
givenPositions <- c(0, -1, -1, 0, 1, 1, -1, 0, -1, -1)

signal <- function(givenPositions)
    givenPositions[Time()]

## fixed position size in units
solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)

cbind(makeTable(solution, prices), givenPositions)
@

Note again the timelag: we can never trade at the same time instant in
which we compute a signal.

But if you really think there should be no timelag, you could write
<<>>=
signal <- function(givenPositions)
    givenPositions[Time(0L)]

solution <- backtest(prices = prices,
                     signal = signal,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)
cbind(makeTable(solution, prices), givenPositions)
@

What if we had had a signal in the first period?
<<>>=
givenPositions <- c(1, 0, -1, 0, 1, 1, -1, 0, -1, -1)
@


<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     b = 0,
                     x0 = 0,          ## initial position
                     c0 = 100,        ## initial cash
                     givenPositions = givenPositions,
                     adjustSignal   = "fixedPosition",
                     positionSize   = 5)
cbind(makeTable(solution, prices), givenPositions)
@

\subsubsection{Signals (\texttt{+1}, \texttt{0}, \texttt{-1}) to fixed weight}

%% TODO: check -- anything pos becomes pos weight, anything neg
%% becomes nec weight?

Suppose we want to hold a constant weight in an asset. (Note that
that to keep the weight constant we will -- under the current
settings -- rebalance in every period.)

<<>>=
## fixed position size in %
signal <- function()
    if (Close() < 100)
        3 else 0
solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 0.2)
makeTable(solution, prices)

signal <- function()
    if (Close() < 100)
        -1.2 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 0.2)

makeTable(solution, prices)

@

To be fully invested, set \texttt{positionSize} to \texttt{1}.
<<>>=
solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight",
                     positionSize = 1)

makeTable(solution, prices)

@


A more common scenario is probably that \texttt{signal} gives a
weight; for instance, after a portfolio optimisation.
<<>>=
signal <- function()
    if (Close() < 100)
        0.05 else 0

solution <- backtest(prices = prices,
                     signal = signal,
                     adjustSignal = "weight")
makeTable(solution, prices)
@

Again, we get a weight and now rebalance in every period. Suppose
we do not want that.
<<>>=
signal <- function()
    if (Close() < 100)
        0.05 else 0

rebalanceYN <- function() {
    if (sum(abs(SuggestedPortfolio(0) - SuggestedPortfolio())) > 0.02)
        TRUE else FALSE
}

solution <- backtest(prices = prices,
                     signal = signal,
                     rebalanceYN = rebalanceYN,
                     adjustSignal = "weight")

makeTable(solution, prices)
@

A numerical analyst would rather put a tolerance that is more
closely related to the machine precision. I prefer using meaningful
tolerance: having invested less than one cent means we are not
invested.

Note also that with weights, we cannot exactly specify the number of
assets we buy or sell because we do not know the price at which we
trade. Practically, this does not matter.

\subsubsection{Passing environments}
To keep information persistent, we can use environments
<<>>=
external <- new.env()
external$vec <- numeric(length(prices))
signal <- function(threshold, external) {
    external$vec[Time()] <- Close()
    if (Close() < threshold)
        1 else 0
}

solution <- backtest(prices = prices,
                     signal = signal,
                     threshold = 100,
                     external = external)

cbind(makeTable(solution, prices), external$vec)
@

\section{Multiple assets}


\subsection{Again, a simple example}

<<>>=
prices1 <- c(100,98, 98, 97, 96, 98,97,98,99,101)
prices2 <- c(100,99,100,102,101,100,96,97,95,82)
prices <- cbind(prices1, prices2)

signal <- function()
    if (Close()[1L] > Close()[2L])
        c(1, 0) else c(0, 1)


(solution <- backtest(prices = list(prices),
                     signal = signal,
                      b=2))
@

We can also give more useful names to the assets.
<<>>=
prices <- cbind(AA = prices1, BB = prices2)
solution <- backtest(prices = list(prices),
                               signal = signal, b=2)
makeTable(solution, prices)

@



\section{Common tasks}
There are many ways to do the same thing. I describe how I have
handled some specific tasks.

\subsection{Remembering an entry price}
In signal: use the current price and assign in \texttt{Globals}.

\subsection{Delaying signals}

\subsection{Losing signals}

\subsection{Writing a log}
<<>>=
prices <- c(100,98,98,97,101,102,101,98,99,101)

signal <- function()
    if (Close() < 100)
        1 else 0

printInfo <- function() {
    cat("period",
        sprintf("%2d", Time(0L)), "...",
        sprintf("%3d", Wealth(0)), "\n")
    flush.console()
}

solution <- backtest(prices = prices,
                     printInfo = printInfo,
                     signal = signal)

makeTable(solution, prices)

@
And since \texttt{cat} has a \texttt{file} argument, we can also write
such information into a logfile.





\chapter{Reporting}

\section{Text tools}

In many cases, reporting simply means constructing a message text that
is printed on a terminal or sent as an email.

\subsection{rmspace}

<<>>=
s <- c(" a a", " 19 EUR ")
rmspace(s)
@ 

\subsection{char2num}

<<>>=
char2num("12.000,23")
char2num("12,000.23", big.mark = ",")
char2num("12000.23",  big.mark = " ") ## but 'as.numeric' is simpler
char2num("12'000.23", big.mark = "'")
char2num("12 000|23", dec = "|", big.mark = " ")
@ 

\subsection{expstring}
Expand a string

<<>>=
s <- c("profits: 100 EUR", "fees:  20 EUR")
cat(s, sep = "\n")
s <- expstr(s, after = ": ", width = 20)
cat(s, sep = "\n")
nchar(s)  ## width
@ 

\section{qpTable}

quartile plot table

\section{slTable}

sparkline table

arguments:
\begin{itemize}
\item \ldots : zoo objects
\item include.returns
\item include.diffs
\item compute.with = "returns": or "diffs" or "levels"
\item columns = list(mean = mean, sd = sd): need to be computed on returns
\end{itemize}



\chapter{Technical indicators}

sum, abssum, sd, absmean, range, minmax, minmaxrange, mad




\appendix
\chapter{Tutorials}

\section{Single-entry accounting}

\section{Double-entry accounting}

\chapter{Design}

\section{Requirements}

\begin{itemize}
\item Store a 'portfolio' of assets and compute the value (or other
  quantities, like Greeks) for different data.  Data can refer to
  market prices, but also to theoretical prices.
\item Reevaluate a portfolio for scenario (= new market data or
  artificial data).
\item Read in transactions from various sources. $\to$ done via a
  journal class.
\item Show portfolio on certain day/time: create a position, evaluate
  this position $\to$ position class
\item testing portfolios of options --> show payoff, simulate *paths*
  of underlier and vol surface
\item run simulations for VaR
\item various ways to compute pnl: weighted average,
  first-in-first-out and last-in-last-out
\end{itemize}


\section{Classes}

The following classes are implicitly defined (ie, S3 classes):

\begin{itemize}
\item journal: keeps transactions
\item Position: only for printing. It comprises the numerical
  positions of different accounts/instruments, the timestamps and the
  description of the instruments.
\item Instrument: term sheet (description etc); it does know nothing
  about market data
\item Cashflow: internal
\item Timeseries: internal
\end{itemize}

\section{Valuation}

Valueing a position can mean two things: compute theoretical prices,
or market prices.

Theoretical valuation takes places via the generic function value:

\texttt{value(x, ..., dots2args = NULL) } 

The simplest case:
\texttt{x} is character, then a call will be generated as

\texttt{do.call(x, list(...))}

\texttt{dots2args.default <- function(x, ...) list(...)}

Note that this will be the \texttt{default} method; notably, an
explicit \texttt{character} method is left unspecified (meant for the
user).


A more typical case: collect all market data in a list \texttt{Data}:
EvaluationDate, Prices, Vols, Irates.

dots2args will react on \texttt{x}, retrieve the required information,
and 



\begin{itemize}
\item evaluates to list \texttt{"value"}, \texttt{"delta"} etc
\item \texttt{Instrument[names(result)] <- result}
\end{itemize}


%% <<>>=
%% Time   <- as.Date("2013-05-28")
%% Prices <- list(DAX = 8472)
%% Irates <- list(EUR = function(t) 0.1)
%% Vols   <- list(DAX = function(x,t) 0.2)

%% DATA <- list(Time = Time, 
%%              Prices = Prices, 
%%              IRates = Irates, 
%%              Vols = Vols)
%% DATA
%% DATA$Vols$DAX(8000, 0.2)
%% DATA$IRates$EUR(0.5)

%% @      


\section{Instruments and portfolios}



\subsubsection{Instrument}

classes: Fund Equity Account Currency Future Index


%% fields:

%% id
%% isin
%% description
%% underlier
%% expirydate
%% expirytime
%% strike
%% type c/p
%% exercise e/a
%% pricing premium/future
%% class

\section{Vectorisation}

Functions should do vectorisation when they have to.  Example:
drawdown is interally computed through \texttt{cumsum}, so even for a
matrix of time series, it would need a loop.  This should be left to
the user. 

The exception is when computations can be accelerated.

\chapter{Frequently-used functions}

\begin{framed}
  \emph{\noindent I need to value a financial instrument.}
\end{framed}

\begin{framed}
  \emph{I have a list of trades (bought or sold what, when and at what
    price) and I need to compute the profit or loss.}
\end{framed}

\begin{framed}
  If all trades are closed (ie, the current positions are all zero),
  use \texttt{pl}.
\end{framed}

\begin{framed}
  \emph{I have a list of trades in an instrument and want to plot
    these trades against the price of the traded instrument.}
\end{framed}

\begin{framed}
  \emph{I have a signal series (\texttt{+1}, \texttt{0}, \texttt{0},
    \texttt{+1}, \ldots{}) and need to transform it into a
    profit-and-loss series.}
\end{framed}

\begin{framed}
  \emph{I have a list of trades and need to determine the
    profit-and-loss between two timestamps.}
\end{framed}

Call the two timestamps \texttt{t0} and \texttt{t1}.  Unless the
position was zero at t0 and t1, we can compute the profit/loss only if
we have prices for the positions at these points in time.  In case the
position was indeed zero, you can use \texttt{pl}; the transactions
are stored in a journal \texttt{j}.

<<eval=false>>=
subset(j, timestamp >= t0 & timestamp <=t1)
@

But even the more general case is not so complicated, after all.

\begin{enumerate}
\item Compute the position at \texttt{t0} and make it a journal j0.

\item Take all transactions at $t > t_\mathrm{0}$ and $t \leq
   t_\mathrm{1}$ and put them into a journal $J$.

\item Compute the position at $t_\mathrm{1}$, and make it a journal
   $J_1$, but \emph{multiply all amounts by $-1$}.

\item Combine $J_0$, $J$, and $J_1$ and compute the PL.
\end{enumerate}

\begin{framed}
  \emph{I need to determine the month-to-date profit-and-loss.}
\end{framed}

1) compute position on last day of last month

2) make journal from position (add prices)

3) combine with journal since month start

4) use average (\texttt{avg}) on all instruments


\chapter{Computations}
\section{Positions}

We have three vectors: \texttt{when}, \texttt{timestamp} and
\texttt{amount}.  Vectors \texttt{when} and \texttt{timestamp} are of
the same type and are both sorted in increasing order;
\texttt{timestamp} and \texttt{amount} have the same length.  The
result of the computation is a vector \texttt{position} with the same
length as \texttt{when}.

\begin{verbatim}
i, j = 0  /* i loops over when; j loops over amount/timestamp */
for (i = 0; i < length(when); i++) {
  if (i == 0)
    pos[i] = 0;
  else
    pos[i] = pos[i - 1];
  while (timestamp[j] <= when[i] && j < length(j))
    position[i] += amount[j++];
}
\end{verbatim}


\printindex
\bibliographystyle{plainnat}
\bibliography{bibliothek}



\end{document}


%\#\# journal.cli(J, \ldots{})
%\#\#while (input != "exit") \{
%\#\#  input <- readline()
%\#\#  \#\# parse me
%\#\#\}
