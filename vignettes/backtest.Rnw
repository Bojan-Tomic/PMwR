%% \VignetteIndexEntry{Backtesting}
\documentclass[a4paper,11pt]{article}
\usepackage[left = 3cm, top = 2cm, bottom = 2cm, right = 4cm]{geometry}
\usepackage[noae,nogin]{Sweave}
\usepackage{libertine}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage[T1]{fontenc}
\renewcommand*\familydefault{\sfdefault} 
\usepackage{amsmath,amstext}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{xcolor}
\definecolor{grau2}{rgb}{.2,.2,.2}
\definecolor{grau7}{rgb}{.7,.7,.7}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{frame=single,xleftmargin=0em,%
  formatcom=\color{grau2},rulecolor=\color{grau7}}
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em}
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}
\SweaveOpts{keep.source = TRUE, eps = TRUE}

\newcommand{\pmwr}{\textsc{pm}w\textsc{r}}
\newcommand{\pl}{\textsc{pl}}
\newcommand{\R}{\textsf{R}}

<<echo=false>>=
options(continue = "  ", digits = 3, width = 60, useFancyQuotes = FALSE)
@

\begin{document}
\title{Backtesting}
\author{Enrico Schumann\\\url{es@enricoschumann.net}}

{\raggedright{\LARGE Backtesting}}\medskip

\noindent Enrico Schumann\\
\noindent \url{es@enricoschumann.net}\\
\bigskip

<<echo=false>>=
require("PMwR")
require("zoo")
@

\section{Introduction}

This chapter explains how to test trading strategies with the
\texttt{btest}\index{btest@\texttt{btest}} function.

\section{Decisions}

At any instant of time (in actual life, `now'), a trader need to
answer the following questions:
\begin{enumerate}
\item Do I want to compute a new target portfolio, yes or no? If yes,
  go ahead and compute the new target portfolio.
\item Given the target portfolio and the actual portfolio, do I~want
  to rebalance (ie, close the gap between the actual portfolio and the
  target portfolio)? If yes, rebalance.
\end{enumerate}
If such a decision is not just hypothetical, then the answer to the
second question may lead to a number of orders sent to a broker.  Note
that many traders do not think in terms of \emph{stock} (ie, balances)
as we did here; rather, they think in terms of \emph{flow} (ie,
orders).  Both approaches are equivalent, but the described one makes
it easier to handle missed trades and synchronise accounts.

During a backtest, we will simulate the decisions of the trader.  How
precisely we simulate depends on the trading strategy.  The
\texttt{btest} function is meant as a helper function to simulate
these decisions.  The logic for the decisions described above is coded
in the functions \texttt{do.signal}, \texttt{signal} and
\texttt{do.rebalance}.

Implementing \texttt{btest} required a number of decision, too:
(i)~what to model (ie, how to simulate the trader), and (ii)~how to
code it.  As an example for point~(i): how precisely do we want to
model the order process (eg, use limit orders?  Allow partial fills?)
Example for~(ii): the backbone of \texttt{btest} is a loop that runs
through the data.  Loops are slow in \R\ when compared with compiled
languages, so should we vectorise instead?  Vectorisation is indeed
often possible, namely if trading is not path-dependent.  If we have
already a list of trades, we can efficiently transform them into a
profit-and-loss in \R\ without relying on an explicit loop.  Yet, one
advantage of looping is that the trade logic is more similar to actual
trading; we may even be able to reuse some code in live trading.

Altogether, the aim is to stick to the functional paradigm as much as
possible.  Functions receive arguments and evaluate to results; but
they do not change their arguments, nor do they assign or change other
variables `outside' their environment, nor do the results depend on
some variable outside the function.  This creates a problem, namely
how to keep track of state.  If we know what variables need to be
persistent, we could pass them into the function and always return
them.  But we would like to be more flexible, so we can pass an
environment; examples are below.  To make that clear: functional
programming should not be seen as a yes-or-no decision, but it is a
matter of degree.  And more of the functional approach can help
already.

\section{Data}

We have one or several price series of length~\texttt{T}. The
\texttt{btest} function runs from \texttt{b + 1} to \texttt{T}. The
variable~\texttt{b} is the burn-in\index{burn-in},%
\marginpar{\texttt{b}\qquad burn-in} %
and it needs to be a positive integer; in rare cases it may be zero.
When we take decisions that are based on past data, we will lose at
least one data point.

Here is an important default: at time~\texttt{t}, we can use
information up to time \texttt{t - 1}.  Suppose that \texttt{t}
were~4.  We may use all information up to time~3, and trade at the
\texttt{open} in period~4.

%TODO create nice display

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS    X                        <- trade here
5    HH:MM:SS
\end{verbatim}

We could also trade at the \texttt{close}.

\begin{verbatim}
t    time      open  high  low   close
1    HH:MM:SS                             <-- \
2    HH:MM:SS                             <-- - use information
3    HH:MM:SS  _________________________  <-- /
4    HH:MM:SS                       X     <-- trade here
5    HH:MM:SS
\end{verbatim}


(No, we cannot trade at the high or low.%
\footnote{Some people like the idea, as a robustness check -- always
  buy at the high, sell at the low.  Robustness checks -- forcing a
  bit of bad luck into the simulation -- are a good idea, notably bad
  executions.  High/low ranges can inform such checks, but using these
  ranges does not go far enough, and is more of a good story than a
  meaningful test.}%
)

\section{Functions}\label{functions}

\texttt{btest} expects a number of functions. The default is to not
specify arguments to these functions, because they can all access the
following objects. These objects are themselves functions that can
access certain data; there are no replacement functions.

\begin{description}
\item[Open] access open prices
\item[High] access high prices
\item[Low] access low prices
\item[Close] access close prices
\item[Wealth] the total wealth (cash plus positions) at a given
  point in time
\item[Cash] cash (in accounting currency)
\item[Time] current time (an integer)
\item[Portfolio] the current portfolio
\item[SuggestedPortfolio] the currenly-suggested portfolio
\item[Globals] an environment
\end{description}

All the functions have the argument \texttt{lag}, which defaults
to \texttt{1}.  That can be a vector, too: the expression
<<eval=false>>=
Close(Time():1)
@ 
for instance will return all available close prices. Alternatively, we
can use the argument \texttt{n} to retrieve a number of past data
points. So the above example is equivalent to
<<eval=false>>=
Close(n = Time())
@ 
and
<<eval=false>>=
Close(n = 5)
@ 
returns the last five closing prices.

\subsection{signal}

The \texttt{signal} function uses information until \texttt{t -
  1} and returns the suggested portfolio (a vector) to be held at
\texttt{t}.

\subsection{do.signal}

\texttt{do.signal} uses information until \texttt{t - 1} and must
return \texttt{TRUE} or \texttt{FALSE}.  If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{do.rebalance}

\texttt{do.rebalance} uses information until \texttt{t - 1} and
returns \texttt{TRUE} or \texttt{FALSE}. If the function is not
specified, it defaults to \texttt{function() TRUE}.

\subsection{print.info}

The function is called at the end of an iteration. It should not
return anything but is called for its side effect: print
information to the screen, into a file or into some other
connection.

\section{Single assets}

It is best to describe the \texttt{btest} function through a number of
simple examples.

\subsection{A useless first example}

I really like simple examples. Suppose we have a single
instrument, and we use only close prices. The trading rule is to
buy, and then to hold forever. All we need is the time series of
the prices and the signal function. As an instrument we use the EURO
STOXX 50 future with expiry September 2015.
<<>>=
timestamp <- structure(c(16679L, 16680L, 16681L, 16682L, 
                         16685L, 16686L, 16687L, 16688L, 
                         16689L, 16692L, 16693L), 
                       class = "Date")
prices <- c(3182, 3205, 3272, 3185, 3201, 
            3236, 3272, 3224, 3194, 3188, 3213)
@

\begin{center}  
<<fig=true, width = 5, height = 1.8>>=
par(mar=c(3,3,1,1), las = 1, mgp = c(2.5,0.5,0), tck = 0.005, bty = "n",
    ps = 11)
plot(timestamp, prices, type = "l", xlab = "", ylab = "")
@ 
\end{center}
The \texttt{signal} function is very simple indeed.
<<>>=
signal <- function()
    1
@
\texttt{signal} must be written so that it returns the suggested
position in units of the asset. In this first example, the suggested
position always is one unit. It is only a \texttt{suggested} portfolio
because we can specify rules whether or not to trade. Examples follow
below.

To test this strategy, we call \texttt{btest}.  The initial cash is
zero per default, so initial wealth is also zero in this case. We can
change it through the argument \texttt{initial.cash}.

<<>>=
(solution <- btest(prices = prices, signal = signal))
@ 
The function returns a list with a number of components, but they
are not printed. Instead, a simple print method displays some
information about the results.

We arrange more details into a \texttt{data.frame}. \texttt{sp} is the
suggested position; \texttt{p} is the actual position.
<<>>=
makeTable <- function(solution, prices)
    data.frame(prices = prices,
               sp     = solution$suggested.position,
               p      = solution$position,
               wealth = solution$wealth,
               cash   = solution$cash)

makeTable(unclass(solution), prices)
@ 
We bought in the second period because the default setting for the
burnin \texttt{b} is 1. Thus, we lose one observation. In the case
here we do not rely in any way on the past; hence, we set \texttt{b}
to zero. With this setting, we buy at the first price and hold until
the end of the data.
<<>>=
solution <- btest(prices = prices, signal = signal, b  = 0)
makeTable(solution, prices)
@ 
If you prefer the trades only, the solution also contains a
\texttt{journal}.
<<>>=
journal(solution)
@
To make the journal more informative, we can pass timestamp and
instrument information.
<<>>=
journal(btest(prices = prices, signal = signal, b  = 0,
              timestamp = timestamp, instrument = "FESX SEP 2015"))
@ 


\subsection{More useful examples}

Now we make our strategy slightly more selective. The trading rule is
to have a position of 1 unit of the asset whenever the last observed
price is below 3200 and to have no position when it the price is above
3200. The \texttt{signal} function could look like this.
<<>>=
signal <- function()
    if (Close() < 3200)
        1 else 0
@

We call \texttt{btest}.
<<>>=
solution <- btest(prices = prices, signal = signal)
@
<<echo=false>>=
makeTable(solution, prices)
@ 
The argument \texttt{initial.position} specifies the initial position;
default is no position. Suppose we had already held one unit of the
asset.
<<>>=
solution <- btest(prices = prices, signal = signal,
                  initial.position = 1)
@
<<echo=false>>=
makeTable(solution, prices)
@ 
%% TODO: is this right? should be suggested position not be 1 in t==2?

Internally, \texttt{btest} stores \textsc{ohlc} prices in matrices.
So even for a single instrument we have four matrices: one for open
prices, one for high prices, and so on. In the single asset case, each
matrix has one column. If we were dealing with two assets, we would
again have four matrices, each with two columns. And so on.

%% TODO: add picture of matrices

We do not access these data directly. A function \texttt{Close} is
defined by \texttt{btest} and passed as an argument to
\texttt{signal}. Note that we do not add it as a formal argument to
\texttt{signal} since this is done automatically. In fact, doing it
manually would trigger an error message:
<<eval = false>>=
signal <- function(Close = NULL)
    1
cat(try(btest(prices = prices, signal = signal)))
@

Similarly, we have functions \texttt{Open}, \texttt{High} and
\texttt{Low} (see Section~\ref{functions} above for a available
functions).

Suppose we wanted to add a variable, like a \texttt{threshold}
that tells us when to buy. This would need to be an argument to
\texttt{signal}; but it would also need to be passed with the
\texttt{\dots} argument of \texttt{btest}.
<<>>=
signal <- function(threshold)
    if (Close() < threshold)
        1 else 0

solution <- btest(prices = prices, signal = signal,
                  threshold = 3200)      

makeTable(solution, prices)
@

So far we have treated \texttt{Close} as a function without arguments,
but actually it has an argument \texttt{lag} that defaults to
\texttt{1}. Suppose the rule were to buy if the last close is below the
second-to-last close. \texttt{signal} could look like this.
<<>>=
signal <- function()
    if (Close(1L) < Close(2L))
        1 else 0
@ 
We could also have written \texttt{(Close() < Close(2L))}. This rule
rule needs the close price of yesterday and of the day before
yesterday, so we need to increase \texttt{b}.
<<>>=
makeTable(btest(prices = prices, signal = signal, b = 2), prices)
@
If we wanted to trade any other size, we would change our signal as
follows.
<<>>=
signal <- function()
    if (Close() < 3200)
        2 else 0

makeTable(btest(prices = prices, signal = signal), prices)
@
A typical way to specify a trading strategy is to map past prices into
\texttt{+1}, \texttt{0} or \texttt{-1} for long, flat or short. A
signal is often only given at a specified point (like in `buy one unit
now'). Example: suppose the third day is a Thursday, and our rule says
`buy after Thursday'.
<<>>=
signal <- function()
    if (Time() == 3L)
        1 else 0

makeTable(btest(prices = prices, signal = signal,
                initial.position = 0, initial.cash = 100),
          prices)
@
But this is probably not what we wanted. If the rule is to buy and
then keep the long position, we should have written it like this.
<<>>=
signal <- function()
    if (Time() == 3L)
        1 else Portfolio()
@
The function \texttt{Portfolio} evaluates to last period's
portfolio. Like \texttt{Close}, its first argument sets the time
\texttt{lag}, which defaults to~1.
<<>>=
makeTable(btest(prices = prices, signal = signal), prices)
@
A common scenario is also a \texttt{signal} that evaluates to a
weight; for instance, after a portfolio optimisation. (Be sure to have
a meaningful initial wealth: 5 percent of nothing is nothing.)
<<>>=
signal <- function()
    if (Close() < 3200)
        0.05 else 0

solution <- btest(prices = prices,
                  signal = signal,
                  initial.cash = 100,
                  convert.weights = TRUE)
makeTable(solution, prices)
@
Note that now we rebalance in every period. Suppose we did not want
that.
<<>>=
do.rebalance <- function() {
    if (sum(abs(SuggestedPortfolio(0) - SuggestedPortfolio())) > 0.02)
        TRUE else FALSE
}

solution <- btest(prices = prices,
                  signal = signal,
                  initial.cash = 100,
                  do.rebalance = do.rebalance,
                  convert.weights = TRUE)

makeTable(solution, prices)
@
See also the \texttt{tol} argument.  %% TODO: expand

\subsubsection{Passing environments}

To keep information persistent, we can use environments.
<<>>=
external <- new.env()
external$vec <- numeric(length(prices))
signal <- function(threshold, external) {
    external$vec[Time()] <- Close()
    if (Close() < threshold)
        1 else 0
}

solution <- btest(prices = prices,
                     signal = signal,
                     threshold = 100,
                     external = external)

cbind(makeTable(solution, prices), external$vec)
@

\section{Multiple assets}


%% \subsection{Again, a simple example}
%% 
%% <<>>=
%% prices1 <- c(100,98, 98, 97, 96, 98,97,98,99,101)
%% prices2 <- c(100,99,100,102,101,100,96,97,95,82)
%% prices <- cbind(prices1, prices2)
%% 
%% signal <- function()
%%     if (Close()[1L] > Close()[2L])
%%         c(1, 0) else c(0, 1)
%% 
%% 
%% (solution <- btest(prices = list(prices),
%%                    signal = signal,
%%                    b=2))
%% @
%% 
%% We can also give more useful names to the assets.
%% <<>>=
%% prices <- cbind(AA = prices1, BB = prices2)
%% solution <- btest(prices = list(prices),
%%                                signal = signal, b=2)
%% makeTable(solution, prices)
%% 
%% @
%% 

\section{Common tasks}

There is more than one ways to accomplish a certain task.  I describe
how I have handled some specific tasks.

\subsection{Remembering an entry price}
In signal: use the current price and assign in \texttt{Globals}.

\subsection{Delaying signals}

\subsection{Losing signals}

\subsection{Various ways to specify when to do something}

btest takes two functions, do.signal and do.rebalance, that tell the
algorithm when to compute a new portfolio and when to rebalance. There
are a number of shortcuts.

<<>>=
tmp <- structure(c(3490, 3458, 3434, 3358, 3287, 3321, 3419, 3535, 3589, 
                   3603, 3626, 3677, 3672, 3689, 3646, 3633, 3631, 3599, 3517, 3549, 
                   3572, 3578, 3598, 3634, 3618, 3680, 3669, 3640, 3675, 3604, 3492, 
                   3513, 3495, 3503, 3497, 3433, 3356, 3256, 3067, 3228, 3182, 3286, 
                   3279, 3269, 3182, 3205, 3272, 3185, 3201, 3236, 3272, 3224, 3194, 
                   3188, 3213, 3255, 3261), .Dim = c(57L, 1L), 
                 .Dimnames = list(
                     NULL, "fesx201509"), 
                 index = structure(c(16617L, 16618L, 
                                     16619L, 16622L, 16623L, 16624L, 16625L, 
                                     16626L, 16629L, 16630L, 
                                     16631L, 16632L, 16633L, 16636L, 16637L, 
                                     16638L, 16639L, 16640L, 
                                     16643L, 16644L, 16645L, 16646L, 16647L, 16650L, 
                                     16651L, 16652L, 
                                     16653L, 16654L, 16657L, 16658L, 16659L, 16660L, 
                                     16661L, 16664L, 
                                     16665L, 16666L, 16667L, 16668L, 16671L, 16672L, 
                                     16673L, 16674L, 
                                     16675L, 16678L, 16679L, 16680L, 16681L, 16682L, 
                                     16685L, 16686L, 
                                     16687L, 16688L, 16689L, 16692L, 16693L, 16694L, 
                                     16695L), class = "Date"), class = "zoo")

prices <- coredata(tmp)
timestamp <- index(tmp)
signal <- function()
    Time()
journal(btest(prices = prices, signal = signal))
@ 

<<>>=
journal(btest(prices = prices, signal = signal, 
              do.signal = c(10, 20, 30)))
@ 

<<>>=
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600))
@ 

<<>>=
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600,
              do.rebalance = FALSE))
@ 

<<>>=
journal(btest(prices = prices, signal = signal, 
              do.signal = prices > 3600,
              do.rebalance = c(26, 30)))
@ 
When \texttt{timestamp} is specified, certain calendar times are also
supported; \texttt{timestamp} must of a type that can be coerced to
\texttt{Date}.
<<>>=
cat(try(journal(btest(prices = prices, signal = signal, 
                      do.signal = "firstofmonth"))))
@ 
<<>>=
journal(btest(prices = prices, signal = signal, 
              do.signal = "firstofmonth",
              timestamp = timestamp))
@ 

<<>>=
journal(btest(prices = prices, signal = signal, 
              do.signal = "lastofmonth",
              timestamp = timestamp))
@ 

<<>>=
journal(btest(prices = prices, signal = signal, 
              do.signal = TRUE,
              do.rebalance = "lastofmonth",
              timestamp = timestamp))
@ 
There is also a function Timestamp.
<<>>=
signal <- function(timestamp) {
    if (Close() > 3500) {
        cat("Lagged price is > 3600 on", as.character(Timestamp()), "\n") 
        1
    } else 
        0
    
}
journal(btest(prices = prices, 
              signal = signal,
              ##signal = function() if (Close() > 3500) 1 else 0, 
              do.signal = TRUE,
              do.rebalance = "lastofmonth",
              timestamp = timestamp))
@ 

\subsection{Testing rebalancing frequency}

\subsection{Writing a log}
<<>>=
signal <- function()
    if (Close() < 3200)
        1 else 0

print.info <- function() {
    cat("period",
        sprintf("%2d", Time(0L)), "...",
        sprintf("%3d", Wealth(0)), "\n")
    flush.console()
}

solution <- btest(prices = prices,
                     print.info = print.info,
                     signal = signal)

makeTable(solution, prices)

@
And since \texttt{cat} has a \texttt{file} argument, we can also write
such information into a logfile.


\subsection{Selecting parameters}

Suppose you have a strategy that depends on a parameter
vector~$\theta$.  For a given $\theta$, the signal for the strategy
would look like this. 
\begin{verbatim}
signal = function(theta) {
    compute signal(theta)
}
\end{verbatim}
Now suppose we do not know theta.  We might want to test several
values, and then keep the best one.  For this, we need to call btest
recursively: at a point in time t, the strategy simulates the results
for various values for theta and chooses the best theta, according to
some criterion~$f$.

A useful idiom is this:
\begin{verbatim}
signal = function(theta0) {
    if (not defined theta0) {
        ## run btest with theta_1, ... \theta_n, select best theta
        theta = argmin_theta f(btest(theta_i))
    } else
        theta = theta0

    compute indicator(theta)
    compute signal
}
\end{verbatim}

Let us look at an actual example.

<<eval=false>>=
require("tseries")
require("zoo")

tmp <- get.hist.quote("^GSPC", start = "2011-01-01", end = "2013-12-31", quote = "Close")

signal <- function(Data) {
    
    if (is.na(Data$N)) {
        
        price <- Close(Data$hist:1)
        Data0 <- list(N = 10, hist = 50)
        res1 <- btest(price, signal, Data = Data0, b = 100)
        Data0 <- list(N = 20, hist = 50)
        res2 <- btest(price, signal, Data = Data0, b = 100)
        if (tail(res1$wealth, 1) > tail(res2$wealth, 1))
            N <- 10 else N <- 20
        
    } else 
        N <- Data$N

    MA <- runStats("mean", Close(Data$hist:1), N = N)
    pos <- 0
    if (Close() > tail(MA, 1))
        pos <- 1
    pos
}
    
Data <- list(N = NA, hist = 200)
res <- btest(tmp$Close, signal, Data = Data, b = 202, initial.cash = 100, 
             convert.weights = TRUE)    
par(mfrow = c(2,1))
plot(index(tmp), res$wealth, type = "s")    
plot(tmp)

@ 




\newpage
\appendix
<<results=tex>>=
toLatex(sessionInfo())
@ 
\end{document}
